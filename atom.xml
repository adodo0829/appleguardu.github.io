<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AppleGuard的博客</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-26T10:02:22.481Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>huhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue阶段学习(一)</title>
    <link href="http://yoursite.com/2019/01/21/vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/21/vue学习/</id>
    <published>2019-01-21T02:53:33.000Z</published>
    <updated>2019-01-26T10:02:22.481Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面;本系列文章主要记录一下vue的学习历程, 相当于学习笔记; 相关内容总结都是基于了通读&lt;Vue实战&gt;这本书来做的, 首先是基础篇的内容…<br><a id="more"></a></p><h1 id="VUE学习"><a href="#VUE学习" class="headerlink" title="VUE学习"></a>VUE学习</h1><p>废话不多说了, Day01干了啥? </p><ol><li>主要针对于vue是什么? </li><li>vue实例:let app = new Vue({})和数据绑定,几个生命周期钩子方法,过滤器, 几个指令; </li><li>然后是计算属性computed;</li></ol><h2 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么?"></a>vue是什么?</h2><p>根据概念来说, vue是一套用于构建用户界面的渐进式框架; 以我初学者的角度来说我觉得vue就是一套用数据来渲染DOM结构的系统, 它给了模板,我们只需要把处理好的数据填充进去就好…</p><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><p>####1.vue使用基本步骤</p><pre><code>// 创建vue实例    1.先引入框架文件vue.js    2.使用Vue构造函数 实例化一个vue对象; new Vue({...})    3.在实例的初始化过程中添加必要的配置: 即必要的属性和方法!!!    4.这些属性和方法都是哪些呢?在之后的内容会逐一介绍        1.el属性: (DOM元素或选择器) 就是HTML结构中模板元素,也是vue实例要 操作的DOM对象        2.data属性: 模板中的数据来源  { 模板变量: 数据 }        3.生命周期钩子; vue实例在创建-执行-结束整个过程会执行的一些方法,如created, mounted, beforeDestroy        4.methods属性: 存放一些事件的处理逻辑        5.本篇先暂时介绍这几个....// 准备vue实例要用的html模板    1.vue实例与要与dom元素绑定才能对其进行相应操作,所以要准备好模板元素    2.接下来就可以向模板中传值(也可以叫插值), {{变量名}}要与实例的data属性中的字段一样    3.{{花括号中也可以使用js的简单的表达式}}// html模板中使用vue指令和事件    1.在DOM元素的标签中插入指令; 插值支持模板字符串写法    2.可以理解为往行内元素添加属性和值; 只不过它们它们的属性只是一个变量或者说对象,可以随意改变    3.当指令对应的值发生改变就会 执行值对应行为并反馈到DOM元素上    4.这一节学习的指令和事件:        v-if: 条件指令        v-html: 只会输出真正的 HTML; 慎用!!!不要使用用户的值进行插入, 容易导致XSS攻击        v-pre: 加了v-pre可以随意输出, {{}}中的内容不会被解析        v-bind: 使用v-bind:href 可以动态更新行内属性; 简写方式 :href=&quot;字段名&quot;; :src=&quot;字段名&quot;;        v-on: 用来绑定事件;&lt;button v-on:click=&quot;方法名&quot;&gt;点击&lt;/button&gt;;方法名也可以写成行内语句,                 简写的话就是 @click=&quot;方法名&quot;</code></pre><h4 id="2-下面上两个实践的例子"><a href="#2-下面上两个实践的例子" class="headerlink" title="2.下面上两个实践的例子"></a>2.下面上两个实践的例子</h4><ol><li><p>demo1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本插值 --&gt;</span></span><br><span class="line">&#123;&#123; text &#125;&#125; <span class="tag">&lt;<span class="name">span</span>&gt;</span>  花括号中放 vue实例 data属性中的一个字段 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>当前时间:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"font-size: 20px"</span>&gt;</span> &#123;&#123; date &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line">&#123;&#123;在这里写东西好像不起作用, 这里放的data中html标签内容&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span> 加了v-pre可以随意输出, 不会被解析  &#123;&#123; xxoo &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>在&#123;&#123;&#125;&#125;中写JavaScript代码: 只支持单个表达式, 不支持语句和流程控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123; `支持模板字符串语法: 这是一个模板字符串拼接: $&#123;name&#125;` &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123; name.split('').join("=") &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span> filters属性 &#123;&#123; 变量 | 过滤器函数(), 可以串联多个; 还可以传参; 主要是对数据进行简单的文本处理 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; data | formatData &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../vuelibs/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">// 创建 vue实例对象</span></span><br><span class="line"><span class="undefined">    let app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el: '#app',  // 指定一个 DOM元素 挂载vue实例</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // 也可以给data传一个已存在的变量, </span></span><br><span class="line"><span class="undefined">        // 变量中的数据和实例中的data数据是双向绑定的, 一变都变</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="undefined">            // 模板用到的数据字段 都在这里声明,这种方式为 显示声明</span></span><br><span class="line"><span class="undefined">            name: 'xxxx',  // 数据中name字段 对应模板中 name</span></span><br><span class="line"><span class="undefined">            text: '文本插值',</span></span><br><span class="line"><span class="undefined">            date: new Date(),</span></span><br><span class="line"><span class="undefined">            // 输出html</span></span><br><span class="line"><span class="xml">            html: '<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span> 这是绑定的一个html元素, 一个a标签 <span class="tag">&lt;/<span class="name">a</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // 生命周期钩子: created, mounted, beforeDestroy</span></span><br><span class="line"><span class="undefined">        created() &#123; </span></span><br><span class="line"><span class="undefined">            // 实例创建完后, 调用; 但还未挂载到DOM节点上, 主要用于初始化处理一些数据</span></span><br><span class="line"><span class="undefined">            console.log(this.name);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            let _this = this; // 让定时器函数可以使用vue实例对象中的 this</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.timer = setInterval(function () &#123;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="undefined">                // 修改date的值</span></span><br><span class="line"><span class="undefined">                _this.date = new Date();</span></span><br><span class="line"><span class="undefined">            &#125;, 1000)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        mounted() &#123;</span></span><br><span class="line"><span class="undefined">            // el挂载到实例后开始调用, 通常是第一个业务逻辑代码</span></span><br><span class="line"><span class="undefined">            console.log(this.$el);</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined">        // beforeDestroy: 实例销毁前调用, 用于解绑事件</span></span><br><span class="line"><span class="undefined">        beforeCreate() &#123;</span></span><br><span class="line"><span class="undefined">            // 清除定时器</span></span><br><span class="line"><span class="undefined">            if (this.date) &#123;</span></span><br><span class="line"><span class="undefined">                clearInterval(this.timer);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // 过滤器filters属性: 用于处理简单的文本转换</span></span><br><span class="line"><span class="undefined">        filters: &#123;</span></span><br><span class="line"><span class="undefined">            // formData</span></span><br><span class="line"><span class="undefined">            formatData: value =&gt; &#123;</span></span><br><span class="line"><span class="undefined">                // 过滤时间值</span></span><br><span class="line"><span class="undefined">                let date = new Date();</span></span><br><span class="line"><span class="undefined">                let year = date.getFullYear(); //年</span></span><br><span class="line"><span class="undefined">                // 月份数字为 0-11; 需要+1</span></span><br><span class="line"><span class="undefined">                let month = String(date.getMonth()+1).padStart(2, 0); </span></span><br><span class="line"><span class="undefined">                //进行小于10的补零处理</span></span><br><span class="line"><span class="undefined">                let day = String(date.getDate()).padStart(2, 0);   </span></span><br><span class="line"><span class="undefined">                let hour = String(date.getHours()).padStart(2, 0);   </span></span><br><span class="line"><span class="undefined">                let minutes = String(date.getMinutes()).padStart(2, 0);   </span></span><br><span class="line"><span class="undefined">                let seconds = String(date.getSeconds()).padStart(2, 0);  </span></span><br><span class="line"><span class="undefined">                // 返回处理好的字符串</span></span><br><span class="line"><span class="undefined">                return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hour&#125;:$&#123;minutes&#125;:$&#123;seconds&#125;`;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>2.demo2</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-if指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"condition"</span>&gt;</span>v-if指令: 满足条件就显示该文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"condition1"</span>&gt;</span>不满足条件就会移除文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"myLink"</span>&gt;</span>v-bind:href 动态更新行内属性; 简写,冒号:表示v-bind<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"myImg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>v-on指令: 用来绑定事件; 可以把方法名写成行内语句, 简写,@表示v-on:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"handleClose"</span>&gt;</span>点击移除上面文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"open"</span>&gt;</span>点击添加上面文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">// vue指令的主要职责就是当其表达式的值改变时，相应地 将某些行为应用到 DOM 上，</span></span><br><span class="line"><span class="undefined">const app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">    // 元素</span></span><br><span class="line"><span class="undefined">    el: '#app',</span></span><br><span class="line"><span class="undefined">    // 绑定数据</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="undefined">        // 数据驱动 DOM ; 控制对应数据的添加和移除</span></span><br><span class="line"><span class="undefined">        condition: 1,</span></span><br><span class="line"><span class="undefined">        condition1: 1,</span></span><br><span class="line"><span class="undefined">        // v-bind更新行内属性</span></span><br><span class="line"><span class="undefined">        myLink: 'https://www.baidu.com',</span></span><br><span class="line"><span class="undefined">        myImg: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Revista_t%C3%BA.jpg/200px-Revista_t%C3%BA.jpg', </span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    // 事件方法; 都写在实例的methods属性中</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">        handleClose() &#123;</span></span><br><span class="line"><span class="undefined">            // 方法中的 this 指向的是当前 Vue 实例本身</span></span><br><span class="line"><span class="undefined">            // 可以直接使用 this.xxx 的形式来访问或修改数据，</span></span><br><span class="line"><span class="undefined">            // this.condition1 = 0;</span></span><br><span class="line"><span class="undefined">            // 支持代理方法</span></span><br><span class="line"><span class="undefined">            this.close();  </span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        // 关闭方法</span></span><br><span class="line"><span class="undefined">        close() &#123;</span></span><br><span class="line"><span class="undefined">            this.condition1 = false;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        // 两种写法意思一样, 上面是简写模式</span></span><br><span class="line"><span class="undefined">        open: function () &#123;</span></span><br><span class="line"><span class="undefined">            // 修改condition1的值</span></span><br><span class="line"><span class="undefined">            this.condition1 = 1;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><p><strong>计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结 果就可以。当然，计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。</strong></p><p>下面直接上例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; textOutput &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算属性computed: 有返回值, 并且返回值可以依赖多个vue实例的数据来发生改变<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>举个栗子: 购物车价格变化<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     购物车结算: ¥&#123;&#123; goodPrice &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">// 1号购物栏</span></span><br><span class="line"><span class="undefined">let pack1 = [</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        name: 'XPS',</span></span><br><span class="line"><span class="undefined">        price: 7999,</span></span><br><span class="line"><span class="undefined">        count: 1,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        name: 'Mac',</span></span><br><span class="line"><span class="undefined">        price: 17999,</span></span><br><span class="line"><span class="undefined">        count: 2,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">];</span></span><br><span class="line"><span class="undefined">// 2号购物栏</span></span><br><span class="line"><span class="undefined">let pack2 = [</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        name: 'apple',</span></span><br><span class="line"><span class="undefined">        price: 88,</span></span><br><span class="line"><span class="undefined">        count: 3,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">        name: 'banana',</span></span><br><span class="line"><span class="undefined">        price: 19,</span></span><br><span class="line"><span class="undefined">        count: 5,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">]</span></span><br><span class="line"><span class="undefined">const app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">    el: '#app',</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="undefined">        text: '123456789',</span></span><br><span class="line"><span class="undefined">        // json的简写</span></span><br><span class="line"><span class="undefined">        pack1,</span></span><br><span class="line"><span class="undefined">        pack2,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    // 计算属性: computed; 专门用于计算</span></span><br><span class="line"><span class="undefined">    computed: &#123;</span></span><br><span class="line"><span class="undefined">        // 所有的计算属性都以函数的形式写在 Vue 实例内的 computed 选项内，最终返回计算后的结果</span></span><br><span class="line"><span class="undefined">        textOutput() &#123;</span></span><br><span class="line"><span class="undefined">            return this.text.split('').reverse().join('-');</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        // 计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行</span></span><br><span class="line"><span class="undefined">        // 计算上面商品的总价</span></span><br><span class="line"><span class="undefined">        goodPrice() &#123;</span></span><br><span class="line"><span class="undefined">            // 分别获取到pack1 和 pack2 的price &amp;&amp; count的属性值</span></span><br><span class="line"><span class="undefined">            let totalGoods = [...pack1, ...pack2];</span></span><br><span class="line"><span class="undefined">            // 拿到每一项元素的values().price 和values().count</span></span><br><span class="line"><span class="undefined">            return totalGoods.reduce(</span></span><br><span class="line"><span class="undefined">                // 每一项汇总</span></span><br><span class="line"><span class="undefined">                (num, item, index, arr) =&gt; &#123;</span></span><br><span class="line"><span class="undefined">                    return  num + item.price * item.count;</span></span><br><span class="line"><span class="undefined">                &#125;, 0);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>计算属性的缓存特性</li></ul><blockquote><p>计算属性缓存: 一个计算属性所依赖的数据发生变化时，它才会重新取值;不然他的值不会改变,可以缓存现在的值;当我们当遍历大数组和做大量计算时,就可以使用计算属性…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面;本系列文章主要记录一下vue的学习历程, 相当于学习笔记; 相关内容总结都是基于了通读&amp;lt;Vue实战&amp;gt;这本书来做的, 首先是基础篇的内容…&lt;br&gt;
    
    </summary>
    
      <category term="VUE学习" scheme="http://yoursite.com/categories/VUE%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(五)</title>
    <link href="http://yoursite.com/2019/01/17/ES6%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>http://yoursite.com/2019/01/17/ES6总结(五)/</id>
    <published>2019-01-17T02:53:33.000Z</published>
    <updated>2019-01-17T13:41:30.036Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是关于ES6中生成器函数 和 Promise对象的相关总结和理解…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h2><p><strong>书中的说法是:</strong><br>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象,也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p><strong>我的理解:</strong><br>生成器函数可以理解为: 函数内部是由多个小函数组成的, 使用yield关键字将函数内部 分割成多个块区域; 并且当函数执行时, 遇到yield就会停止, 并且将yield 后面的表达式结果输出(当然外部要调用next()方法); 下次再调用next()方法时, 就从上一个停止的地方开始执行(这意味着函数有有记忆功能); 如果下面没有再遇到yield的话 就像普通函数执行完. 函数的返回值是一个可迭代对象(遍历器对象); 我喜欢叫可迭代对象, 或者说可遍历对象…</p><h2 id="说一说可迭代对象-iterator-的next-方法"><a href="#说一说可迭代对象-iterator-的next-方法" class="headerlink" title="说一说可迭代对象(iterator)的next()方法"></a>说一说可迭代对象(iterator)的next()方法</h2><pre><code>function CreateIterator(iterator) {// 定义一个初始下标用来判断let nextIndex = 0;// 返回对象: 包含的next方法, return {    next: function () {        // 返回一个对象: value是当前对象下标对应的值, done是是否遍历完成        return nextIndex &lt; iterator.length ?                // i++ 先参数运算在 自增1                 {value: iterator[nextIndex++], done: false} :                {value: undefined, done: true};        }    }}// 实例化一个遍历器let iter1 = CreateIterator([1,2,3,4,5]);console.log(iter1); // 一个具有next方法的对象console.log(iter1.next().value); // 1console.log(iter1.next().value); // 2console.log(iter1.next().value); // 3console.log(iter1.next().value); // 4console.log(iter1.next().value); // 5console.log(iter1.next().value); // undefined</code></pre><h2 id="生成器函数的使用"><a href="#生成器函数的使用" class="headerlink" title="生成器函数的使用"></a>生成器函数的使用</h2><pre><code>generator生成器函数的使用:function *fn() {    代码1;     yield;     代码2;}普通函数: 执行到底生成器函数: 遇到yield会暂停,交出执行权,下次执行从上次的停止的位置继续生成器函数返回值为: 生成器对象生成器对象.next()方法才能执行 函数体中的代码// 可以解决函数回调嵌套的问题; 解决耗时操作function *func() {    // 请求数据.    // yield ajax()     // 处理数据} // generator函数本质上 分割成多个小函数来执行... yield关键字前后// 遇到yield就暂停; 没有就往下执行...// yield 起到了 暂停函数执行的作用</code></pre><h2 id="关于yield关键字的理解"><a href="#关于yield关键字的理解" class="headerlink" title="关于yield关键字的理解"></a>关于yield关键字的理解</h2><h4 id="yield传值"><a href="#yield传值" class="headerlink" title="yield传值"></a>yield传值</h4><p><img src="https://i.imgur.com/ZwwcK9s.png" alt=""></p><h4 id="yield输出值"><a href="#yield输出值" class="headerlink" title="yield输出值"></a>yield输出值</h4><p><img src="https://i.imgur.com/s3F9ZdG.png" alt=""></p><p>举个栗子:</p><pre><code>let output = [];function *g2(x, y) {    let sum = x+y;    yield sum; // sum是第一个输出结果    let agv = sum / 2;    yield agv; // agv 是第二个输出的结果    return {&quot;和&quot;: sum, &quot;平均数&quot;: agv}; // 最后一个结果}let gg2 = g2(100, 20);console.log(gg2.next().value);  // 120console.log(gg2.next().value);  // 60console.log(gg2.next().value);  // { &apos;和&apos;: 120, &apos;平均数&apos;: 60 }</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>这里只介绍一下使用的方法, 暂时理解的还不算透彻,后面会单独写一篇文章来说的…</p><p><strong>Promise对象 ==&gt; 主要是用来消除异步操作; 用同步的方式书写异步代码</strong></p><p>同步异步:</p><pre><code>// 异步: 操作之间没关系; 可以同时进行多个操作; 并发执行 &amp;&amp; 代码相对复杂// 同步: 同时只能做一个操作; 后面的操作需要等待        &amp;&amp; 代码相对简单</code></pre><p>promise的使用:</p><pre><code>let p = new Promise(function(resolve, reject) {    // 异步代码    // resolve 成功了    // reject 失败了    $.ajax({        type: &quot;method&quot;,        url: &quot;url&quot;,        data: &quot;data&quot;,        dataType: &quot;dataType&quot;,        success: function (response) {            resolve(response); // 成功的处理函数        },        error: function (obj){            reject(obj); // 失败的处理函数        }    });})// 然后调用promise对象.then()方法; 传两个函数p.then(function (结果1) {    console.log(&apos;成功&apos;);},function (结果2) {    console.log(&apos;失败&apos;);});</code></pre><p><strong>promise的应用</strong> </p><blockquote><p>如读取文件的操作, 如果是传统的ajax回调来实现, 则需要嵌套三层ajax请求才能完成三个文件的读取…<br>promise.all().then() 主要用于一次性读取操作…批量的;<br>如果是带有逻辑异步操作, 则使用生成器函数 + promise对象的方式来实现… let output = yield $.ajax({url: “test/arr.txt”, dataType: “json”})的方式; 这个以后单独说</p></blockquote><pre><code>Promise.all([    $.ajax({url: &quot;test/arr.txt&quot;, dataType: &quot;json&quot;}),    $.ajax({url: &quot;test/json.txt&quot;, dataType: &quot;json&quot;}),    $.ajax({url: &quot;test/str.txt&quot;, dataType: &quot;json&quot;}),]).then( success =&gt; {    // 异步任务请求成功; 返回的success就是成功的结果    let [arr, json, str] = success;    alert(&apos;异步任务请求成功...&apos;)    console.log(arr, &apos;\n&apos;,  json, &apos;\n&apos;, str);},error =&gt; {    // 异步任务失败;     console.log(&apos;fail to read file&apos;);})</code></pre><p>返回结果:</p><p><img src="https://i.imgur.com/Dvfa1e9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇是关于ES6中生成器函数 和 Promise对象的相关总结和理解…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>js中的正则</title>
    <link href="http://yoursite.com/2019/01/14/js%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2019/01/14/js中的正则/</id>
    <published>2019-01-14T02:53:33.000Z</published>
    <updated>2019-01-15T00:38:11.974Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于对js中正则表达式的一些小小的总结和使用…<br><a id="more"></a></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><pre><code>正则: 专门用来处理字符的工具; 常见的处理方式: 对源字符串进行过滤,得到目标字符串; 查找到目标字符串核心: 匹配模式 =&gt; 字符串对象 但我们使用正则时:  需要想到这几个方面: 字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。</code></pre><h2 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h2><pre><code>. ： 匹配除了换行符之外的任何单个字符\ ： 对特殊字符进行转义，使其呈现字面量的意思; 例: 模式 /a\*/ 将 &apos;*&apos; 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。| ： 逻辑或操作符[] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身[^]：对上面一个集合取非- ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面</code></pre><h2 id="数量字符"><a href="#数量字符" class="headerlink" title="数量字符"></a>数量字符</h2><pre><code>{m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次+ ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次* ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词 *,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式</code></pre><h2 id="位置字符"><a href="#位置字符" class="headerlink" title="位置字符"></a>位置字符</h2><pre><code>^ ： 匹配表达式的开始\$ ： 匹配表达式的结束</code></pre><h2 id="快捷匹配模式"><a href="#快捷匹配模式" class="headerlink" title="快捷匹配模式"></a>快捷匹配模式</h2><pre><code>\d：[0-9]，表示一位数字，记忆方式 digit\D：[^0-9]，表示一位非数字\s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character\S：[^\t\v\n\r\f]，表示非空白符\w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word\W：[^0-9a-zA-Z]，表示非单词字符</code></pre><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><pre><code>// g: 全局匹配// i: 忽略大小写</code></pre><h2 id="re对象的方法"><a href="#re对象的方法" class="headerlink" title="re对象的方法"></a>re对象的方法</h2><pre><code>// re: 正则对象// 1. re.rest(&quot;str&quot;) // 正则表达式匹配模式 =&gt; 目标字符串 :  就是拿正则去源字符串中去比对, 结构相同则返回// 返回值:  包含匹配模式则返回 true 否则返回 false// 2. re.exec(&quot;str&quot;)     // 没有匹配到; 返回null    // 匹配到了(分有g 和 无g), 返回一个数组// 使用场景: 字符串对象的方法: 查找,匹配,判断,替换等...// 1.String.search(re)  // 参数: 正则对象   返回值: 子串下标 或者 -1let str1 = &apos;dsahjoa@#$#$._-=--dsa4445da++11!!!&apos;;console.log(str1.search(/\d+/));console.log(str1.search(/[A-Z]/));// 2.String.match(re)// 参数: 正则对象   返回值: 不存在则返回 null; 数组,arr[0]是匹配到的元素// 加()会返回一个group,里面包含了我们想要的目标元素let str2 = &quot;hello world hell hall hole&quot;;console.log(str2.match(/ll/g).length); // 有全局标识g时, 返回匹配成员数组: [ &apos;ll&apos;, &apos;ll&apos;, &apos;ll&apos; ]console.log(str2.match(/hell/)); // 无g时, 返回值: [ &apos;hell&apos;, index: 0, input: &apos;hello world hell hall hole&apos; ], 长度为1// 默认时贪婪模式; 量词加?则为非贪婪模式// 3. String.replace(oldStr||re, newStr||function)// 参数1: 旧字符串或者正则// 参数2: 新字符串或者回调函数// 外部替换字符串let str3 = &quot;hello world&quot;;var str4 = str3.replace(&apos;hello&apos;, &apos;hi&apos;); // hi worldconsole.log(str3, &quot;\n&quot;, str4); // 内部子字符串替换var re = /(\w+)\s(\w*)/;str4 = str3.replace(re, &quot;$2, $1&quot;); //括号(分组)匹配出的字符串按顺序替换 console.log(str4); // world, hello// 4. String.split(param1, param2)// 参数1: 分割符: 字符||正则; 不传默认为空,全部分割; // 参数2: 指定分割字符的个数; // 返回值: 一个数组; 注意:正则中若有括号,返回值包括括号中的值console.log(str2.split(/\s/)); // [ &apos;hello&apos;, &apos;world&apos;, &apos;hell&apos;, &apos;hall&apos;, &apos;hole&apos; ]console.log(str2.split(/(\s)/)); // [ &apos;hello&apos;, &apos; &apos;, &apos;world&apos;, &apos; &apos;, &apos;hell&apos;, &apos; &apos;, &apos;hall&apos;, &apos; &apos;, &apos;hole&apos; ]</code></pre><h2 id="正则的模糊匹配"><a href="#正则的模糊匹配" class="headerlink" title="正则的模糊匹配"></a>正则的模糊匹配</h2><pre><code>// 1.指定多个数量的匹配: {m, n}; 也可以使用 * + let test = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log(test.match(/ab{1,3}/g));// 2. 指定多种情况的匹配: [字符组];  [^xx]非, /^xx/开头 [a-zA-Z0-9]表示范围// [xxx|yyy]: 惰性匹配, 匹配到xxx就不再往后匹配了let test1 = &quot;123456a123b456cdefGHIJKLM&quot;;console.log(test1.match(/\d+[a-c]/g)); // [ &apos;123456a&apos;, &apos;123b&apos;, &apos;456c&apos; ]// 3.指定位置的匹配: ^，$ 匹配字符的开头和结尾// 位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o* ， *代表位置// /^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置let test2 = &quot;hellodsadhello13123 dsawfa hellocahello2132&quot;;console.log(test2.match(/hello/g));console.log(test2.match(/^h.*?\d$/g));</code></pre><h2 id="几个练习题"><a href="#几个练习题" class="headerlink" title="几个练习题"></a>几个练习题</h2><pre><code>// 1. 驼峰改横线function tuo_to_heng(str) {    // helloWorld; 将字符串中大写字符找到, 用(-和自己)去替换(匹配到的大写)    // 那么我要确定字符的位置,还要用正则去匹配,     // 这个属于字符串内部子串替换, 可以使用$    var re = /([A-Z])/g;    return str.replace(re, &quot;-$1&quot;).toLowerCase();}console.log(tuo_to_heng(&quot;helloWorldJavaPython&quot;)); // hello-world-java-python// 2.获取网页链接中的参数// window.location.search() 获取的是: ?+参数// let url = &quot;https://www.baidu.com?name=哈喽world&amp;age=24岁&amp;gender=男&quot;;let url = &quot;https://www.baidu.com?    &quot;;function get_url_params(url) {    // 方法有很多; 可以截取?字符后的子串,在通过字符&amp;进行分割,再取=左右两边的值    // 1.判空,是否有参数    if (!url.includes(&apos;?&apos;) || !url.substr(url.indexOf(&apos;?&apos;)+1) == &apos;&apos;) {        // return &quot;链接没有参数&quot;;        return null;    }    // 2.取值    let str = url.substr(url.indexOf(&apos;?&apos;)+1);    let params = str.split(&apos;&amp;&apos;);    let paramObj = {};    // 也可以使用数组的forEach方法    for (let i = 0; i &lt; params.length; i++) {        paramObj[params[i].split(&apos;=&apos;)[0]] = decodeURIComponent(params[i].split(&apos;=&apos;)[1]);    }    return paramObj;}console.log(get_url_params(url));// 3.去除前后空格; 匹配到前面和后面的空格,用空字符替换字符串function trim(str) {    var re = /(^\s*) | (\s*$)/g;    return str.replace(re, &quot;&quot;);}var test = &quot;  sdd ds   &quot;;console.log(trim(test));</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于对js中正则表达式的一些小小的总结和使用…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="正则re" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99re/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(四)</title>
    <link href="http://yoursite.com/2019/01/10/ES6%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2019/01/10/ES6总结(四)/</id>
    <published>2019-01-10T02:53:33.000Z</published>
    <updated>2019-01-18T01:13:07.914Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是关于ES6中新增的两种数据结构Set和Map…用来存放多个数据的…这里总结比较浅,主要事掌握概念; 顺便提一下class关键字<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h2><blockquote><p>Set数据结构: 可以理解为没有重复成员的一个类似数组的对象; 就叫集合吧<br>结构形式: {1, 2, 3, 4}</p></blockquote><p>使用方法:<br>// 使用构造函数Set; 参数为一个可遍历的对象<br>const set = new Set([1,2,3,4]); // 实例化一个set; set结构是可迭代的对象<br>// 返沪值: {1, 2, 3, 4}</p><p>Set的属性和方法</p><pre><code>1. size: 返回set集合的大小, 即成员个数2. Set的增删查// add(value)：添加某个值，返回 Set 结构本身。// delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。// has(value)：返回一个布尔值，表示该值是否为Set的成员。// clear()：清除所有成员，没有返回值。3. Set遍历成员; Set的遍历顺序就是插入顺序。// keys()：返回键名的遍历器// values()：返回键值的遍历器// entries()：返回键值对的遍历器// forEach()：使用回调函数遍历每个成员, 回调参数为键值和set自身</code></pre><p>使用场景:</p><pre><code>Set作为一种数据结构,主要用来存放数据,并且内部成员不重复; 我们可以利用它的这个特性来做一些事.1.比如去重    let arr = [1,2,2,3,1,1,14];    let str = &apos;dsadaedwdwa&apos;;    console.log([...new Set(arr)]);    console.log([...new Set(str)].join());</code></pre><h2 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h2><blockquote><p>其实Map有点类似 python中的字典结构;<br>ES6中Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br>也就是说，Object 结构提供了“字符串: 值”的对应，Map 结构提供了“值 =&gt; 值”的对应</p></blockquote><p>结构形式: Map: { [ 1, 2, 3 ] =&gt; ‘数组’, ‘name’ =&gt; { name: ‘bob’ } }</p><p>使用方法:<br>使用构造函数Map 进行实例化; 参数为双元素的可迭代对象(能够调用next方法的对象)</p><pre><code>const newMap = new Map([[&apos;name&apos;, &apos;Blob&apos;], [&apos;age&apos;, 24]]);// 也可实例化一个空map对象,通过set(值1, 值2)方法去添加成员</code></pre><p>Map的属性和方法: 基本与上面的Set一致</p><pre><code>1.Map的增删查// set(key1, value1)：添加一个键值对// get(key); 获取某个键值对// delete(key)：删除某个键值对// has(key)：返回一个布尔值，表示该值是否为Map的成员。// clear()：清除所有成员，没有返回值。</code></pre><p>常用场景:</p><pre><code>可以使用扩展运算符...Map 可以实现与 数组,对象,json对象的互转</code></pre><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>for…of是ES6新增的语法;用来遍历具有Iterator 接口的对象; 这种对象有next()方法,\<br>可以对自身进行遍历,每一次调用便返回对应的值…</p><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、<br>Generator 对象，以及字符串。</p><h2 id="class关键字-类"><a href="#class关键字-类" class="headerlink" title="class关键字: 类"></a>class关键字: 类</h2><ul><li><p>ES5中的类实现</p><pre><code>// ES5中对象实例化的方法: 通过构造函数实例化function Func(x, y) {    this.x = x;    this.y = y;}// 给构造函数的原型添加属性Func.prototype.toString = function() {    // 把对象转为字符串    return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;}// 实例化一个对象var f = new Func(1,100);console.log(f.toString());</code></pre></li><li><p>ES6的类实现</p><pre><code>// ES6中 通class来定义类; 其实就是构造函数的改写,是js的语法更像后台语言class Func1 {    // 构造实例对象的方法; 相当于初始化    constructor(x, y) {        this.x = x;        this.y = y;    }    // 添加类方法: toString()方法    toString() {        return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;    }}// 类: 就是一个函数, 本身为一个构造函数; 也是通过new来实例化一个对象console.log(typeof Func1);console.log(Func1 === Func1.prototype.constructor); let f1 = new Func1();console.log(f1.__proto__.constructor); // 省略了__proto__// 类的方法都定义在prototype对象上</code></pre></li><li><p>ES6中的继承</p><pre><code>// ES6面向对象写法: class 替换 构造函数class User {    // 构造器, 初始化    constructor(name, pass) {        this.name = name;        this.pass = pass;    }    // 添加方法和属性    showName() {        console.log(this.name);    }    showPass() {        console.log(this.pass);    }}// 在继承 和 封装上的优势;  扩展性强...;  不用从0开始;; 可以使用前人造好的轮子// 继承超类的属性和方法    class VipUser extends User {        // 子类的初始化        constructor(level, ...args) {            // 相当于调用父类的constructor(name, pass)            super(...args);             // super作为函数调用时，代表父类的构造函数            // super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。            this.level = level;        }        // 方法        showLevel() {            console.log(this.level);        }    }    let vip = new VipUser(77, &apos;huhua&apos;, &apos;123&apos;); // 实例化    vip.showLevel();    vip.showName();    vip.showPass();    // 面向对象中类的应用实例    // 比如一个组件: 就是一个 class 继承一个组件    // JSX: == babel;  browser.js</code></pre></li></ul><h2 id="json简写模式"><a href="#json简写模式" class="headerlink" title="json简写模式"></a>json简写模式</h2><pre><code>// 1.JSON对象: 两个方法let json = {&quot;name&quot;: &apos;哈哈&apos;, &quot;sex&quot;: &quot;女&quot;}; // json对象键值必须是双引号let str1 = &apos;http://www.baidu.com?data=&apos; + encodeURIComponent(JSON.stringify(json)) ; // JSON对象转为json字符串console.log(str1);let str2 = JSON.parse(&apos;{&quot;a&quot;: 12, &quot;b&quot;: &quot;hello world&quot;}&apos;);console.log(str2); // JSON字符串 转为 对象console.log(str2.a);// 2.JSON简写// 简写:  如果key值和value是一样的; 直接写一个就可以了...// 可以省略一个funcion; 即 success: function(obj) {}  ==&gt; 可以写成 success(obj){}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇是关于ES6中新增的两种数据结构Set和Map…用来存放多个数据的…这里总结比较浅,主要事掌握概念; 顺便提一下class关键字&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(三)</title>
    <link href="http://yoursite.com/2019/01/09/ES6%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>http://yoursite.com/2019/01/09/ES6总结(三)/</id>
    <published>2019-01-09T02:53:33.000Z</published>
    <updated>2019-01-10T12:14:12.687Z</updated>
    
    <content type="html"><![CDATA[<p>第三篇是关于函数 和 rest参数方面的内容…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="函数参数设置默认值"><a href="#函数参数设置默认值" class="headerlink" title="函数参数设置默认值"></a>函数参数设置默认值</h2><pre><code>语法: function(x=默认值x, y=默认值y); 当然也可以使用解构赋值,使用对象的形式设置,({x=xxx, y=yyy})默认值参数放在括号尾部1. ES5中设置默认值的方式    function fn1(x, y) {        y = y || &quot;world&quot;; // ES5中,在函数体内赋值一个默认值        console.log(x, y);    }    fn1(&apos;hello&apos;); // hello world    fn1(&apos;hello&apos;, &apos;bob&apos;); // hello bob    fn1(&apos;hello&apos;, &apos;&apos;); // 传空值时也使用默认值    fn1(&apos;hello&apos;, false); // 传false时也使用默认值// ES6中 直接给()中参数赋默认值, 相当于初始化形参, 函数体内不允许let和const再次声明// ES6中会事先对参数y进行类型判断: typeof y === &apos;undefined&apos;; 是才给默认值    function fn2(x, y = &apos;ES6&apos;) {        console.log(x, y);    }    fn2(&apos;learning&apos;); //learning ES6     fn2(&apos;learning&apos;, &apos;&apos;); //learning 空也能输出    fn2(&apos;learning&apos;, false); //learning false 布尔值也可以2. 构造函数中用来初始化 函数的属性function Person(name=&apos;bob&apos;) {this.name = name};    也是可以直接在()中传默认值的3.解构赋值形式给函数传参例1:    function fn3({x, y = 100}) {        // 函数的形参接受一个对象; 函数传值也要传一个对象;        console.log(x, y);    };    // ES5中我们是传一个对象,然后再定义变量 保存 对象中对应的属性值    // ES6可以直接在形参中 去接受对应的属性值    fn3({}); // undefined 100;     fn3();  // 保错例2:    // 下面我们重写一下, 注意:::这种方式的传参是设置了对象解构赋值的默认值为空对象,这样直接调用便不会报错    function fn4 ({x, y = 101} = {}) {    // 不传值的情况下: 给函数一个默认参数: 空对象    console.log(x, y);    };    fn4(); //undefined 101; 相当于 fn4({});4.默认参数的作用域    函数()中式一个单独的作用域, ES6中函数体中的运算会先去()中找对应的变量进行运算</code></pre><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><pre><code>ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，参数都放在这个数组中。要使用的话,直接在函数体中遍历即可,当然...rest放在()尾部    举个栗子:        function add (...number) {            let sum = 0;            // number变量相当于一个存放形参的数组            // 可以使用数组的方法,也就是说,我们可以当作数组来操作这个参数number            // 基本方法 和 迭代方法都能使用            for (let num of number) {                sum += num;            }            return sum;        }         console.log(add(1,2,3,4,5)); // 15</code></pre><h2 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数 =&gt;"></a>箭头函数 =&gt;</h2><pre><code>1.箭头函数基本语法:     var 变量指向这个函数 = (参数1,参数2...) =&gt; {函数体大于一行时用大括号} 理解: ES6中箭头函数 相当于函数的简写,省略了function关键字,只有一个参数时还可以省略()    箭头左边是 (参数) =&gt; 箭头右边是函数体(一行代码可以省略大括号,直接写返回值表达式)     //如果返回的是一个对象则加括号({对象})2.常用的使用场景    2.1 回调函数的简化        // 比如数组常用的迭代方法map: 常规方法是 传入一个回调函数 function(x) {return x**2};        var arr1 = [1,2,5,3,6,0];        var result1 = arr1.map(x =&gt; x**2);        // 排序        var result2 = arr1.sort((a, b) =&gt; a - b); // [0,1,2,3,5,6]        // 箭头函数传rest参数        let arr3 = (...numbers) =&gt; numbers; // 自动将参数序列转为数组    2.2 嵌套使用; 函数式编程        例如:要实现将一个值 插入到数组 某个值的后面, 然后返回一个新数组        function insert (value) {            return {into: function (array) {                return {after: function (after_value) {                    // 起始位, 要删除的项, 替换项                    array.splice(array.indexOf(after_value) + 1, 0, value);                    return array;                }}            }}        }        // 用箭头函数实现; 简化了很多        // 声明一个变量指向函数; 不要忘记对象用()包起来        var insert = (value) =&gt; ({into: (array) =&gt; ({after: (after_value) =&gt; {            array.splice(array.indexOf(after_value) + 1, 0, value);            return array;        }})});        var res = insert(100).into([1, 2, 3]).after(2);        console.log(res); // [ 1, 2, 100, 3 ]3.箭头函数注意事项;     1.this对象 ==&gt; 指向定义时的对象, 而不是谁调用就指向谁了; 相当于固定了this指向        箭头函数根本没有自己的this，导致内部的this就是外层代码块的this        箭头函数中的this 相当于ES5中 引用了外层函数的this; 在外层函数用var _this = this; 然后在箭头函数中使用    2.箭头函数不能当作构造函数,不能使用new去声明    3.没有arguments对象了, 使用rest参数替代    4.不能使用yield, 不可以作为生成器函数</code></pre><h2 id="函数的尾调用"><a href="#函数的尾调用" class="headerlink" title="函数的尾调用"></a>函数的尾调用</h2><pre><code>函数的尾调用优化function f(x){    return g(x);    // 函数f的最后一步是 调用函数g，这就叫尾调用。}function f(x){    g(x);    // 函数没有明确返回值, 默认回返回undefined; 所以不是尾调用    return undefined;}优化思路: 用内层函数的调用帧，取代外层函数的调用帧(保存了函数调用后的信息)         相当于可以不用调用外层函数注意:    只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，    否则就无法进行“尾调用优化”。尾递归优化思路: 把所有用到的内部变量改写成函数的参数    1.参数设置成默认值的方式;      2.函数柯里化currying;意思是将多参数的函数转换成单参数的形式function Fibonacci (n , ac1 = 1 , ac2 = 1) {    if( n &lt;= 1 ) {return ac2};    // 尾部调用自身; 并且参数中保存了上一次调用帧; 节省内存    return Fibonacci (n - 1, ac2, ac1 + ac2);}console.log(Fibonacci(100)); // 注意:// ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三篇是关于函数 和 rest参数方面的内容…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(二)</title>
    <link href="http://yoursite.com/2019/01/07/ES6%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/01/07/ES6总结(二)/</id>
    <published>2019-01-07T02:53:33.000Z</published>
    <updated>2019-01-18T01:25:50.313Z</updated>
    
    <content type="html"><![CDATA[<p>第二篇是关于ES6中数据类型(字符串,数值,数组,对象)部分方法的扩展, 还有扩展运算符;我这里只总结了一些较为常用的方法扩展…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><pre><code>1. 处理4个字节存储的单个字符// 测试一个字符由两个字节还是由四个字节组成的最简单方法 (Unicode 编号大于0xFFFF)// codePointAt(下标): 返回10机制字节码;function is_32bit(char) {    return char.codePointAt(0) &gt; 0xFFFF;}console.log(is_32bit(&apos;𠮷a&apos;)); // true// 识别4个字节(32位)组成的单个字符console.log(String.fromCodePoint(0x20BB7)); // 𠮷 2.字符串的遍历for oflet text = &apos;我的名字&apos;;for (const char of text) {    console.log(char);}3.确定一个字符串中是否包含另一个目标字符串// includes(), startsWith(), endsWith() // 返回true和falseconsole.log(text.startsWith(&apos;我&apos;));console.log(text.endsWith(&apos;我&apos;));console.log(text.includes(&apos;我&apos;));4.repeat(num); 将字符串重复num次并返回console.log(text.repeat(3));5.字符串补全长度的功能// padStart()用于头部补全，padEnd()用于尾部补全// 参数1: 补全后的生效长度; 参数2: 用于补全的字符串(没有参数默认空格)// 长度过了; 会截取超出位数的字符串// 长度 &lt;= 原长度; 返回自己// 用途1: 将数值补全为指定位数console.log(&quot;1&quot;.padStart(10, &apos;0&apos;)); // 0000000001// 场景2: 日期补全console.log(&apos;09-12&apos;.padStart(10, &apos;2018-MM-DD&apos;)); // 2018-09-12</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>模板字符串: 反引号 ` 标识; // 变量名使用 ${变量名}; 可以省去字符串的拼接了let name = &quot;bob&quot;;let age = 24;console.log(`Hello ${name}, how are you ${age}?`);// ${这里面可以进行运算; 函数调用; 放对象的属性等}; 相当于执行js代码// 还可以相互嵌套当然,模板字符串的用法比较复杂,后续再深入总结</code></pre><h2 id="数值类型方法"><a href="#数值类型方法" class="headerlink" title="数值类型方法"></a>数值类型方法</h2><pre><code>// 1.检查数字为有限值Number.isFinite(12); // true; 其他类型都为false// 2.检查数值是不是NANNumber.isNaN(1+NaN); // true; NaN 数值与非数值运算的结果NaN// 3.Number.parseFloat 和 Number.parseInt; 将ES5的全局方法移到Number对象上// 4.Number.EPSILON * Math.pow(2, 2): 两个浮点数之间的最小误差; // 差值小于它, 就可以认为时相等// 5.Math方法的扩展console.log(Math.round(4.5)); // 5; 四舍五入// Math.trunc方法用于去除一个数(正负都可以)的小数部分，返回整数部分。console.log(Math.trunc(3.1)); // 兼容性写法// Math.trunc = Math.trunc || function(x) {//     return x &lt; 0 ? Math.ceil(x) : Math.floor(x);//  };// Math.sign()// 判断正负, 还是0; 对非数值,能转化的转化; 不能转的就是NaN// 返回值: 正 +1; 负 -1; 0; -0; 其他值 NaN</code></pre><h2 id="数组的扩展方法"><a href="#数组的扩展方法" class="headerlink" title="数组的扩展方法"></a>数组的扩展方法</h2><p>ES6将数组空位转为undefined</p><pre><code>1.Array.from(param1, param2)方法用于将两类对象转为真正的数组：    参数1: 一个对象 ==&gt; 伪数组对象和可遍历（iterable）的对象    参数2: 回调函数 ==&gt; 类似于数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。    return值: 一个数组;示例:    let arrayLike = {        &apos;0&apos;: &apos;a&apos;,        &apos;1&apos;: &apos;b&apos;,        &apos;2&apos;: &apos;c&apos;,        length: 3        // 0: &apos;a&apos;,        // 1: &apos;b&apos;,        // 2: &apos;c&apos;,        // length: 3    };    let real_arr = Array.from(arrayLike);2.Array.of(传一组数值); 用于将一组值，转换为数组。弥补了构造函数Array()传数值的缺点    参数: 一组数值,如: 1,2,3,4...    return值: 一个数组3.实例方法    3.1 arr.find(): 类似过滤函数filter(function(value, index, arr))        使用: 传入一个回调函数, 返回第一个符合要求的成员        示例: var res = [1,2,3,4,-100].find( n =&gt; n &lt; 0 ); // -100    3.2 arr.findIndex(): 同上,只不过是返回第一个符合条件的数组成员的位置        注意: 第二个参数是传一个对象，回调函数中若使用了 this, 则指向这个对象    3.3 arr.includes(): 判断数组中是否包含我们给定的值;这样以后就不用indexOf了    3.4 实例数组的遍历方法: entries()，keys() 和 values() 用于遍历数组 返回一个遍历器对象            // keys()是对键名的遍历:   对应索引            // values()是对键值的遍历: 对应值            // entries()是对键值对的遍历: 索引+值4.数组扩展方法 [a, b, c]    map映射, reduce汇总, filter过滤, forEach迭代    1. map: 一个映射一个     // [100, 59, 22] =&gt; [及格, 不及格, 不及格]    let score = [100, 59, 22];    let res = score.map( item =&gt; item&gt;60? &apos;及格&apos;:&apos;不及格&apos; );console.log(res);    2. reduce: 一堆变成一个    // temp为中间结果; 如果不设置,则为第一个下标为0的数    let res1 = score.reduce(function(temp, item, index, arr) {        if (index != arr.length - 1) {            return item + temp;        } else {            return (temp + item) / arr.length;        }    });     console.log(res1);    3.filter: 保留我想要的结果    let res2 = score.filter( item =&gt; item%11!=0);    console.log(res2);    4.forEach: 只是操作一下每一项; 返回值为undefined    let arr = [1,2,3,4]    arr.forEach(function (item, index, arr) {        // 这里可以用外部变量接受 这里面操作的值        console.log(index +&apos;:&apos;+ item);    });    console.log(res3); // undefined</code></pre><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>这里主要介绍一下对象的多种遍历方法;其他内容在扩展运算符…中总结.</p><pre><code>1.for...in    for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。2.Object.keys(obj),values(obj),entries(obj)    返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名,值,键值对。3.Object.getOwnPropertyNames(obj)    返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。4.Object.getOwnPropertySymbols(obj)    返回一个数组，包含对象自身的所有 Symbol 属性的键名。5.Reflect.ownKeys(obj)    返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</code></pre><h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><pre><code>1.扩展运算符是什么?    扩展运算符用三个点...表示: 相当于函数rest参数的逆运算, 可以将数组,对象中的成员序列化出来    我这里暂且把它理解为一种运算符吧, 用来解析各种数据类型的成员2.扩展运算符的使用场景?    2.1 将数组成员转为一个逗号分隔的参数序列:        这样调用一些数组的API时; 可以直接传一个...arr进去,省去了传参的麻烦        例1: console.log(...[1,2,3]); // 1 2 3        例2: var date = new Date(...[2015, 01, 01]);             console.log(date); // 2015-01-31T16:00:00.000Z    2.2 取代apply方法:         // ES5 的写法        let max1 = Math.max.apply(null, [14, 3, 77]);        // ES6 的写法        let max2 = Math.max(...[14, 3, 77]);    2.3 数组的深拷贝: 将对象全部拷贝一份,是一个独立的内存空间        let arr1 = [0, 1], arr2 = [...arr1]; // 用变量去接受经过扩展运算符运算的数组        arr1[0] = 100; // 修改数组arr1        console.log(arr1); // [ 100, 1 ] 发送改变        console.log(arr2); // [ 0, 1 ]   未改变    2.4 数组的合并        注意: 合并操作是浅拷贝: 是对数组中对象成员的引用        浅拷贝: (分为简单数据类型引用: 修改数据另一个不会变; 复杂数据类型引用: 修改后会改变)        arr3 = [...arr1, ...arr2]; // 此时arr3 为一个新数组; [ 100, 1, 0, 1 ],因为内部成员都是数值,        所以修改了arr1或者arr2中的元素也不会变        那么,如果数组中成员是对象; 则会改变成员属性,合并生成的数组成员也会变        const a1 = [{ foo: 1 }];        const a2 = [{ bar: 2 }];        const a3 = [...a1, ...a2];        console.log(a3); // [ { foo: 1 }, { bar: 2 } ]        a1[0].foo = 100;        console.log(a3); // [ { foo: 100 }, { bar: 2 } ]    2.5 可以和变量的解构赋值一起使用; 右边是对象也是可以的        let [first, second, ...rest] = [1,2,3,4,5,6];        console.log(first); // 1        console.log(second); // 2        console.log(rest); // [3,4,5,6]    2.6 还有与Array.from()方法类似的作用, 将 类似数组的对象和可迭代对象 转为真数组        console.log([...&apos;hello&apos;]); // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]        注意: 如果涉及到操作四个字节的 Unicode 字符的函数; 可以使用[...string], ...能够识别;    2.7 扩展运算符在对象中的使用        // 解构赋值, 如果右边数据是undefined或null 则解构会失败        let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; // x,1; y,2; z,{a:3, b:4}        // 注意: 如果扩展运算符后面不是对象，则会自动将其转为对象。        {...1}, {...true}, {...undefined}, {...null} 都会转为 空对象{}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二篇是关于ES6中数据类型(字符串,数值,数组,对象)部分方法的扩展, 还有扩展运算符;我这里只总结了一些较为常用的方法扩展…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(一)</title>
    <link href="http://yoursite.com/2019/01/04/ES6%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/01/04/ES6总结(一)/</id>
    <published>2019-01-04T02:53:33.000Z</published>
    <updated>2019-01-09T11:54:44.496Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于阮一峰的es6入门书籍的读书总结; 第一篇关于let和const关键字, 块级作用域, 以及变量的解构赋值…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="let和const声明变量"><a href="#let和const声明变量" class="headerlink" title="let和const声明变量"></a>let和const声明变量</h2><pre><code>// 块级作用域ES5中:     不合理场景1: 局部内层变量 可能覆盖掉 全局变量    合理场景2: for循环中 用var声明的 变量i; 会泄露成全局变量,循环结束并没有消失ES6中:**使用严格模式: &apos;use strict&apos;;1.声明的变量a的作用域为块级,并且只在自己所在的块级作用域起作用; 外层作用域不能访问内层, 内层可以访问外层的;2.内&amp;&amp;外层的同名变量互不干扰; 内层重新赋值也不会对外层造成影响;3.变量必须先声明,再使用,否则报错...(暂时性死区特性), 没有所谓的变量提升4.同一作用域不能重复声明同一个变量; 函数function第一层作用域变量声明不能和形参一样; 否则报错//注意:1. es5中var声明变量的特性:    a. var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。    b. es5中变量只有两种作用域: 全局 和 局部(函数内声明); 全局和局部都有变量提升现象;先提前,再进行赋值.    c. es6中可以使用var, 特性还是同es5一样2. es6中,变量在for循环中的使用    每一轮的i值 只在当前的循环中有效; 相当于每一次循环i都是一个新变量     // 1.循环变量在设置的时候是: 一个父作用域    // 2.循环体内部又是一个单独的子作用域    // 3.所以当同时两个块级作用域如使用相同的变量i,循环体内部会使用自己作用域声明的i3.ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。    // 1.避免在块级作用域内使用函数时声明的方式(function fn(){xxx})声明函数    // 2.可以使用表达式方式 let f = function(){}    // 也就是外层无法调用内层声明的函数...4.const声明一个常量: 该变量不能变化,是一个恒定值    const i = 100; // 定义时就需要初始化    // const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。    // 值类型:   数据就 等同于 这个常量的地址的值    // 引用类型: 这个常量 是一直指向一个固定的地址, 不能变的(修改指向就保错,即赋值操作); 只不过对象本身可变</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>解构赋值,我按照字面意思就是 解析数据解构, 然后给一一对应的变量进行赋值的一种语法</p><ul><li><p>解构的语法:</p><pre><code>=号左边是: 匹配模式; =号右边是: 实际的数据(或者数据对应的变量);解构的结果:    解构成功: 左边变量的值 就是右边对应变量的值    解构不成功: 即没有对应值匹配, 变量的值变为undefined    不完全解构: 左边的模式之匹配到右边数组的一部分</code></pre></li></ul><ul><li><p>变量是复杂数据类型(数组,对象)</p><pre><code>1.数组解构赋值    1.右边的值需要能够被遍历     2.允许左边给默认值: let [x=1, y=x] = [&apos;xxxx&apos;];    3.支持嵌套结构的 解构赋值注意:    let [x, y=true] = [&apos;xxxx&apos;]; // 右边数组对应成员要 === undefined    // console.log(x,y); // 如果是null, 则默认值不会生效;    // 如果右边 不是undefined, 则左边 会取到值2.对象的解构赋值    1.对象本身就是无序的, 是根据左右同名变量 来做赋值操作,匹配规则和数组类似    // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者    例: let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };    2.持嵌套结构的 解构赋值        let obj = {};        let arr = [];        ({foo: obj.num, bool: arr[0]} = {foo: 123, bool: true}); // 圆括号        console.log(obj, arr);3.对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量,几个例子    3-1 let {sin, cos} = Math; // 将math对象中方法给对象    3-2 取出数组的首尾2项        let list = [1,2,323,123,12,2];        let {0: first, [list.length-1]: last} = list;</code></pre></li><li><p>变量是简单数据类型(字符串,数值,布尔值)</p><pre><code>1.字符串的解构赋值    字符串被转换成了一个类似数组的对象: 可以理解未伪数组    let [a,b,c,d,e] = &apos;hello&apos;; // 每个变量对应一个字符2.数值和布尔值的解构赋值    解构赋值的规则: 只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined 和 null无法转为对象，所以对它们进行解构赋值，都会报错    所以, 数值和布尔值会先转成其包装对象Number 和 Boolean对象;然后可以赋值对象的属性</code></pre></li><li><p>函数参数的解构</p><pre><code>1.会将实参与形参一一对应console.log([[1, 2], [3, 4]].map(([a, b]) =&gt; a + b));</code></pre></li><li><p>圆括号注意事项</p><pre><code>// 圆括号问题// 解构模式中不能使用圆括号的情况// 1.变量声明语句// 2.函数参数也属于变量声明，因此不能带有圆括号// 3.赋值语句的模式; 左边的匹配模式不能使用圆括号可以使用圆括号// 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</code></pre></li><li><p>常用的使用场景</p><pre><code>变量之间值的交换; 函数中传参和接受返回值(对象的方式); 对象遍历...1.交换变量的值let v100 = 100;let v1 = 1;[v1, v100] = [v100, v1];console.log(v1, v100);2.接受函数的多个返回值: 比如数组,对象// 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。// 有了解构赋值，取出这些值就非常方便。function example() {return [1, 2, 3];}// let [a, b, c] = example();3.函数传参// 解构赋值可以方便地将一组参数与变量名对应起来// 参数是一组有次序的值function f([x, y, z]) {  }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) {  }f({z: 3, y: 2, x: 1});4.json数据的处理// 解构赋值对提取 JSON 对象中的数据，尤其有用。let jsonData = {id: 42,status: &quot;OK&quot;,data: [867, 5309]};let {id, status, data: arr1} = jsonData;console.log(id, status, arr1);5.设置函数参数的默认值// 避免了在函数体内部再写var foo = config.foo || &apos;default foo&apos;;// 在传参时; 特别是传一个对象参数时, 可以事先配置好参数的默认值// func({参数1 = true, 参数2 = false, ...} = {外部实参没有传值的就是用默认值}){}6.遍历 Map 结构// 可迭代对象, 都可以用for...of 来遍历const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) {console.log(key + &quot; is &quot; + value);}// 获取键名for (let [key] of map) {    console.log(key);}// 获取键值for (let [,value] of map) {    console.log(value);}7.模块导入// 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰// const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); </code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于阮一峰的es6入门书籍的读书总结; 第一篇关于let和const关键字, 块级作用域, 以及变量的解构赋值…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>关于H5的一些新特性总结</title>
    <link href="http://yoursite.com/2019/01/03/H5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/01/03/H5的一些新特性/</id>
    <published>2019-01-03T02:53:33.000Z</published>
    <updated>2019-01-09T01:28:57.375Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容是关于html5的一些新的特性和方法总结…<br><a id="more"></a></p><h1 id="H5中的新特性"><a href="#H5中的新特性" class="headerlink" title="H5中的新特性"></a>H5中的新特性</h1><h2 id="新增的一些标签"><a href="#新增的一些标签" class="headerlink" title="新增的一些标签"></a>新增的一些标签</h2><p>网页结构标签: 块级元素(可替换对应的div盒子)</p><pre><code>1.几个结构标签    header: 头部区域            nav：导航区域    main： 主体区域            section： 小区域                    aside：边栏                    article:文章    footer：页尾区域2.兼容方法(导入插件): 原理:利用JS创建标签元素，并修改为块级元素    &lt;!--[if lte IE 8]&gt;        &lt;script src=&quot;html5shiv.js&quot;&gt;&lt;/script&gt;     &lt;![endif]--&gt;3.媒体播放标签    video：播放视频    audio: 播放音频    以上两个标签的属性和方法都是一样的！只不过一个是播放视频的，一个是播放音频的    行内属性：            controls：显示播放的控件            autoplay：自动播放，谷歌新版浏览器禁用了自动播放，影响用户体验            muted： 静音的属性，而且如果谷歌浏览器要想能够用自动播放，就必须加muted静音            width: 宽度;  跟img像，给宽能自动计算出高度            height:高度</code></pre><h2 id="新增表单类型"><a href="#新增表单类型" class="headerlink" title="新增表单类型"></a>新增表单类型</h2><p>新增的一些input标签的 type类型: </p><pre><code>color:用来输入颜色的date：用来输入日期，只有年月日time：用来输入时间，只有时分datetime-local：上面两个的结合体email：用来输入邮箱，自带邮箱格式验证; 如果要进行非空判断,需加required属性number：只能输入数字; 可以加max,min,step,required属性url：只能输入网址，自带网址验证search：跟普通文本框一样，移动端有区别：它弹出的键盘是带搜索按钮tel：专门用来输入电话，移动端弹出的时候键盘是数字键盘range：滑块，设置音量可以用这个, max,min,value</code></pre><h2 id="新增的一些属性和webAPI-DOM方法"><a href="#新增的一些属性和webAPI-DOM方法" class="headerlink" title="新增的一些属性和webAPI(DOM方法)"></a>新增的一些属性和webAPI(DOM方法)</h2><p>1.行内自定义属性操作:dataset对象</p><pre><code>&lt;div class=&quot;info&quot; data-name=&quot;huahua&quot; data-age=&quot;24&quot; data-my-height=&quot;177cm&quot;&gt;&lt;/div&gt;H5中自定义属性是按data-这种形式写的，那么JS里有个属性叫 dataset可以拿到所有的自定义属性因为dataset是一个对象，所有的自定义属性都当做了它这个对象的属性var info = document.querySelector(&apos;.info&apos;);// 取值info.dataset[&apos;name&apos;]; // huahuainfo.dataset[&apos;myHeight&apos;] // 177cm// 赋值info.dataset[&apos;myHeight&apos;] = &apos;188cm&apos;;</code></pre><p>2.元素的类操作: classList属性; classList是一个伪数组，可以获取元素所有类</p><pre><code>方法：    classList.add() 加一个类    如果要加多个，就用逗号隔开，写多个参数，有几个就写几个字符串参数    例：box.classList.add(&apos;red&apos;,&apos;new&apos;);    classList.remove() 移除一个类            如果要移出多个，跟add是一样的，要写多个参数    classList.replace(); 替换一个类            参数1：被替换的类            参数2：要替换新的内容    classList.toggle(); 切换一个类            原来没这个类就加上，原来有这个类就去掉。一种开关效果;    classList.contains(); 是否有某个类，如果有返回true，没有返回false</code></pre><p>3.localStorage属性：本地存储;可以存储一些数据到本地（存到浏览器端, 而且不像cookie,他没有失效时间<br>4.sessionStorage属性: 作用同上; 只不过不能永久存储,浏览器关闭回自动清空(适用 多个页面临时传值…)</p><pre><code>几个方法:   setItem(key: value): 存储一个数据到浏览器。            严格来讲只能存字符串，如果传入复杂类型，会调用复杂类型的toString方法得到字符串再存            所以如果要存一个复杂类型，先把复杂类型转成JSON字符串(JSON.stringify)，再存到浏览器            取的时候，再把JSON字符串转为 JS数据(JSON.parse).    getItem()： 根据key来取出值;    removeItem() 根据key删除某个值;    clear(): 没有参数，直接清除所有的值；注意:    1.只要自己不删，就一直存在。    2.不同网站之间的本地存储无法共享。同一个网站里不同页面可以共享使用注意点:     1.使用local storage中存储的数据(字符串/json字符串)时;        如果是对同一key进行读写操作(可能出现覆盖的情况); 在首次加载时最好先取出来,        一般读取值进行的操作:            a. 判空处理            b. 判断是否已存在 if not existed: xxx</code></pre><p>5.地理定位</p><pre><code>navigator.geolocation.getCurrentPosition(function (loc) {    console.log(loc)    // 经纬度    console.log(loc.coords.longitude, loc.coords.latitude);})</code></pre><p>6.获取目标元素距离可视区的距离</p><pre><code>getBoundingClientRect().topgetBoundingClientRect().left// 获取鼠标点击相对于自身的位置距离可以用事件对象的clientX - 元素.getBoundingClientRect().left</code></pre><h2 id="新增的一些事件"><a href="#新增的一些事件" class="headerlink" title="新增的一些事件"></a>新增的一些事件</h2><p>1.鼠标拖拽事件<br>    // 先给拖动元素加 draggable属性为true</p><pre><code>// 跟拖动的元素相关的ondrag:  当拖动元素过程中触发ondragstart:  当拖动操作开始时触发 ondragend:  当拖动操作结束时触发 // 跟容器（目标元素）有关的事件：ondragenter:有元素进入时触发ondragleave：有元素离开时触发ondragover：有元素在容器范围内时不断触发，但这个事件主要是阻止默认行为，好方便让drop事件能得到触发ondrop：当有元素在容器范围内被放置时触发，需要先阻止over的默认行为才能触发</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇内容是关于html5的一些新的特性和方法总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>常用布局方式</title>
    <link href="http://yoursite.com/2018/12/17/%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/12/17/页面常用的布局方式/</id>
    <published>2018-12-17T02:53:33.000Z</published>
    <updated>2019-01-24T13:18:44.632Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中经常遇到布局的问题，下面我总结几种常用的css布局方案,直接用代码展示<br><a id="more"></a></p><h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><ul><li><p>水平居中</p><pre><code>/* 以不定宽为例 *//* 1: 父盒子text-aligin + 子盒子inline-block */.father {    text-align: center;}.son {    /* 此时宽高为内容撑起 */    display: inline-block;}/* 2: 子盒子 table+margin */.son {    display: table;    margin: 0 auto;}/* 3: 子盒子: absolute,left + transform *//* 当子元素定宽时, 则采用 负margin来实现 */.father {    position: relative;}.son {    position: absolute;    left: 50%;    transform: translateX(-50%);}</code></pre></li><li><p>垂直居中</p><pre><code>/* 1. 父元素: table-cell + vertical-align */.father {    display: table-cell;    /* 会继承父元素的宽度 */    vertical-align: middle; }/* 2. absolute + transform *//* 定宽使用负margin */.father {        position: relative;}.son {        position: absolute;                   top: 50%;        transform: translateY(-50%);}/* 3.flex + align-items */.father {    display: flex;    align-items: center;}</code></pre></li><li><p>水平垂直居中</p><pre><code>/* 1.父:table-cell + text-align + vertical-align  子:inline-block*/.father {    /* display: table-cell; 拥有行内块的属性 */    /* text-align: center; */    /* vertical-align: middle; */}.son {    /* display: inline-block; 内容撑开 */}/* 2. 子:absolute + transform */.son {    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);}/* 3.定宽子元素可以采用absolute + 负 margin *//* 4.还有absolute  ltrb:0 + margin: auto */</code></pre></li></ul><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><ul><li><p>一列定宽,另一列自适应</p><pre><code>/* 1. float + margin */.left {    width: 300px;    float: left;    background: red;}.right {    /* 50px的间距 */    margin-left: 350px;     background: green;}/* 2. float + overflow */.right {    overflow: hidden; }</code></pre></li><li><p>多列定宽，一列自适应</p><pre><code>/* 1.浮动加overfloat; float + overflow: hidden */.parent {    background: #ccc;}.box1,.box2 {    float: left;    width: 200px;    margin-right: 20px;}.auto {    overflow: hidden;}/* 2. flex方式实现 */.parent {    display: flex;}.box1,.box2 {    width: 200px;    padding-right: 20px;}.auto {    flex: 1;}</code></pre></li><li><p>等分布局(百分比)</p><pre><code>.parent {    height: 300px;    /* margin-left: -10px; */}.box {    float: left;    /* 等分父盒子宽度 */    width: 25%;    height: 100%;    padding-left: 10px;    /* 子元素盒子尺寸:为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 */    box-sizing: border-box;    border: 1px solid red;}</code></pre></li><li><p>等高布局</p><pre><code>1. 浮动 + overflow实现.parent {    overflow: hidden;}.left {    float: left;    width: 300px;    background: #ccc;}.right {    overflow: hidden;    background: #0f0;}</code></pre></li><li><p>三栏式圣杯布局</p><pre><code>将中间的模块放在dom树前面，可以实现浏览器在做重绘的时候有限显示**圣杯布局的主要内容是放在 中间main这个盒子中**/* 圣杯布局: 浮动 + 相对定位 + padding */.container {    width: 1000px;    margin: 100px auto;    text-align: center;}/* 头部 &amp;&amp; 底部 */.header,.footer {    height: 100px;    background-color: yellow;}/* 中间主体内容, padding保证中间盒子居中 */.wrapper {    padding: 0 100px;}.col {    float: left;    position: relative;}/* 主要内容 */.main {    width: 100%;    height: 400px;    background: red;}/* 左边内容栏: 定宽=父盒子的padding */.left {    width: 100px;    height: 400px;    /* 负margin 回到最左边 */    margin-left: -100%;    left: -100px;    background: #0f0;}/* 右边内容栏: 定宽=父盒子的padding */.right {    background: pink;    width: 100px;    height: 400px;    /* 负margin 回到最右边 */    margin-left: -100px;    right: -100px;}</code></pre></li><li><p>三栏式的双飞翼布局</p><pre><code>双飞翼布局: 同上面的圣杯一样, 也是将主体内容浮动起来, 中间设置margin, 两侧设置负margin/* 双飞翼布局: 浮动  */.container {    width: 1000px;    margin: 100px auto;    text-align: center;}/* 头尾部分 */.header,.footer {    height: 100px;    background: greenyellow;}/* 主体 */.col {    float: left;    height: 400px;}.main {    width: 100%;}/* main-wrap居中: */.main-wrap {    margin: 0 200px;    background: red;    height: 400px;}/* 两侧布局 */.left {    width: 200px;    margin-left: -100%;    background: pink;}.right {    width: 200px;    margin-left: -200px;    background: pink;}</code></pre></li></ul><h2 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h2><ul><li><p>flex布局是什么?</p><pre><code>H5中出来的一种新的布局方式,也称伸缩布局,可以给父盒子设置相应布局属性来伸缩子元素的内容,控制其在父盒子中的排布方式...用来做尺寸适配比较好,多用于移动端布局</code></pre></li><li><p>flex布局的使用方式</p><pre><code>1.flex中有两个轴: 默认主轴X方向; 副轴Y方向    使用flex布局会让子元素依次在主轴方向排列;并且子元素永远不会超过主轴方向2.使用方法    ** 可以在父元素上加上如下属性：        1.display:flex;  让子元素用伸缩布局        2.flex-direction：设置主轴方向，也就是说设置x还是y为主轴            默认是row,即X方向            Y方向是 column        3.justify-content：设置主轴上的对齐方式            设置子元素在主轴方向的排列方式            flex-start:在主轴起点对齐（默认值）            flex-end：在主轴终点对齐            center:在主轴方向居中            space-around:元素和元素之间有间距，两边也有间距            space-between：元素和元素之间有间距，但是两边没有间距        4.align-items：设置副轴上的对齐方式            设置子元素在副轴的排列方式            stretch：默认值，在副轴起点对齐。但是如果没有给子元素副轴方向大小，会铺满整个副轴方向            flex-start:副轴的起点对齐。如果没有给子元素副轴大小，会用内容撑开                        如果给了副轴大小，以上两个没区别            flex-end:在副轴终点对齐            center：在副轴居中        5.flex-wrap:wrap  代表允许换行            换行后会形成自己独立的空间轴    ** 可以在子元素身上加的属性        1.align-self：单独设置某个子元素在副轴的排列        2.flex:设置在主轴方向的占比            不过它计算的永远是主轴方向剩下的大小, 比如有元素定了宽高,它只能按比例分配余下尺寸</code></pre></li></ul><h2 id="bootstrap中的栅格布局"><a href="#bootstrap中的栅格布局" class="headerlink" title="bootstrap中的栅格布局"></a>bootstrap中的栅格布局</h2><ul><li><p>响应式</p><pre><code>/* 响应式布局 =&gt; 媒体查询 *//* 向上兼容, 向下覆盖 *//* 对屏幕的宽度或者高度进行获取同时判断，根据判断结果重置样式 */body {    background: #000;}/* max-width: 当屏幕宽度&lt;=这个值; 以里面的修改的样式为主 */ /* 当以max为参照时: 从大写到小 *//* min-width: 当屏幕宽度&gt;=这个值时; 以里面修改的样式为主 *//* 当以min为参照时: 从小写到大 */@media screen and (min-width: 768px) {    body {        background: #00f;    }   }@media screen and (min-width: 992px) {    body {    background: #0f0;    }} @media screen and (min-width: 1200px) {    body {    background: #f00;    }} 响应式基本使用:     1.容器: container:不同宽度容器对应不同宽度  和 container-fluid: 全屏等宽    2.row类写在容器里, 下面对应着column类; 一行对应一整块块内容;每一列是一个单独的盒子     3.col-xs; sm; md; lg 分别对应着 极小,小,中,大屏的宽度条件    4.col-xs-数字: 对应了该元素所占据容器的宽度的  数字/12     5.xs,sm,md,lg 满足向上兼容,向下覆盖的规则; 只能影响比他大的宽度    &lt;!-- class=&quot;col-xs-12 col-sm-6 col-md-4 col-lg-3&quot; 省去写媒体查询,从小往大    6.工具使用    不同屏幕下的显示隐藏: hidden-xs, hidden-sm: 表示在992以下的屏幕隐藏// 基本思路:分析项目原型图: 看设计稿有哪些结构可以使用 bootstrap 框架中的组件来完成...    拆分设计稿; 去框架中找对应的结构组件a. 需求分析: DOM结构在不同屏幕(尺寸)下的展示样式;     按条件去设计结构; 给row分配栅格的时候注意每一列的比例分配,注意什么屏下需要隐藏,或者样式改变b. 套用框架的时候注意,我们要对其进行修改, 包括样式和结构;     修改结构的时候,为了不改动原有结构, 有时候需要添加自定义的类名等等...    修改样式的时候, 我们需要找到直接起作用的元素; 参照源码逐一修改c. 使用框架的插件组件    注意依赖jquery, 并且要初始化....</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中经常遇到布局的问题，下面我总结几种常用的css布局方案,直接用代码展示&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于php的一些知识点</title>
    <link href="http://yoursite.com/2018/12/15/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/15/PHP相关知识点/</id>
    <published>2018-12-15T02:53:33.000Z</published>
    <updated>2018-12-25T06:15:18.013Z</updated>
    
    <content type="html"><![CDATA[<p>主要是总结一些网页中php的使用方式…<br><a id="more"></a></p><h1 id="php基础"><a href="#php基础" class="headerlink" title="php基础"></a>php基础</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一般一个语言的语法无非是由变量,数据类型,运算,流程控制,函数,然后就是封装的一些方法,库等…php可以与html一起混合使用,其语法与js大致相同,这里便不做太多介绍了,以下有几个注意点</p><pre><code>注意点:    1. 文件创建: filename.php 代码块: &lt;?php 代码块 ?&gt;    2. 变量声明: 要以$开头, 区分大小写    3. 关于字符串:         a. &quot;&quot;双引可以解析出变量名,&apos;&apos;单引号不行;        b. 字符串的拼接语法使用点 . 来拼接    4. 关于输出:        a. 简单数据类型(字符串,数值等)输出: echo         b. 复杂数据类型(数组,对象等)输出:  print_r() 或者 var_dump()输出详细信息    5. 关于数组        a. 索引数组: 与js一样, $arr = [1,2,3,4]            使用for循环遍历, 长度用count($arr)方法获取        b. 关联数组: 键值对形式的数组, $arr = [&apos;key&apos; =&gt; &apos;value&apos;,...];            b1. 取值使用$arr[&apos;key&apos;]方式            b2. 遍历使用foreach方法                foreach($arr as $key =&gt; $value){                    //循环体里$key就是当前遍历到的元素的$key                    //循环体里$value就是当前遍历到的元素的$value                }    6.指令式的混编写法         &lt;?php            $array = [&apos;php&apos;, &apos;java&apos;, &apos;python&apos;, &apos;ruby&apos;];            //循环开始            for($i = 0; $i &lt; count($array); $i++):        ?&gt;        &lt;!-- 每遍历一个元素就创建一个li标签 --&gt;        &lt;li&gt;&lt;?php echo $array[$i]; ?&gt;&lt;/li&gt;        &lt;!-- 循环结束 --&gt;        &lt;?php endfor; ?&gt;    7.文件引入:  include &quot;文件路径.php&quot;;</code></pre><h2 id="表单交互"><a href="#表单交互" class="headerlink" title="表单交互"></a>表单交互</h2><p>html中的表单(form), 主要是用来向后台提交数据…</p><ul><li><p>form表单,页面提交数据的入口</p><pre><code>&lt;!-- action属性是提交的地址，代表提交到哪个服务器页面, 默认get请求方式 --&gt;&lt;form action=&quot;./result.php&quot;&gt;// 必须要加name属性!!!!!, 后台通过name属性获取传递的数据&lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre></li><li><p>提取表单数据</p><pre><code>上面的表单数据会被提交到result.php文件,这时我们需要提取数据值通过$_GET[&apos;上面表单的name属性值&apos;]即可获取到: 如$res = $_GET[&apos;userName&apos;];isset可以用来判断是否存在某个值 isset($res);返回true/false</code></pre></li><li><p>get请求和post请求</p><pre><code>1. get请求:&lt;form action=&quot;login.php&quot; method=&quot;GET&quot;&gt;    &lt;input type=&quot;text&quot; name=&apos;id&apos; placeholder=&quot;请输入账号&quot;&gt;    &lt;input type=&quot;password&quot; name=&apos;pwd&apos; placeholder=&quot;请输入密码&quot;&gt;    &lt;input type=&quot;submit&quot; value=&apos;登录&apos;&gt;&lt;/form&gt;// 提交数据后的处理页面的链接为: 127.0.0.1/login/login.php?id=hello&amp;pwd=123// get请求会将我们输入的数据:         a. 先将我们输入的数据进行url的拼接        b. 然后以明文的方式发送服务器处理页面; 处理页面通过$_GET[&apos;name属性&apos;]方式取值进行处理// 所以get请求的特点:        1. 简单,传输快,主要用于获取        2. 不安全        3. 长度有限制(2KB)        4. 浏览器缓存// 注意点:    a标签的跳转，也可以理解为是一种get请求。因为get请求本身就是通过网址的跳转来进行的。    所以,我们可以直接构造href属性去请求其他页面, 传入参数通过$_GET方式获取</code></pre></li></ul><pre><code>2. post请求:&lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt;    &lt;input type=&quot;text&quot; name=&apos;id&apos; placeholder=&quot;请输入账号&quot;&gt;    &lt;input type=&quot;password&quot; name=&apos;pwd&apos; placeholder=&quot;请输入密码&quot;&gt;    &lt;input type=&quot;submit&quot; value=&apos;登录&apos;&gt;&lt;/form&gt;// 提交数据后的处理页面的链接为: 127.0.0.1/login/login.php// post请求会将我们输入的数据:         a. 先将我们输入的数据放入到请求体中        b. 然后发送服务器处理页面; 处理页面通过$_POST[&apos;name属性&apos;]方式取值进行处理// 所以post请求的特点:        1. 主要用于提交数据        2. 长度无限制        3. 相对安全(抓包可以抓到post的提交数据)</code></pre><ul><li><p>文件上传</p><pre><code>// 通过表单标签&lt;input type=&quot;file&quot;&gt;来上传1.上传到处理页面     &lt;!-- 表单里仅仅一个文件上传元素，提交到file.php --&gt;        &lt;form action=&quot;file.php&quot; method=&apos;POST&apos; enctype=&apos;multipart/form-data&apos;&gt;            // 需要指定enctype属性            &lt;input type=&quot;file&quot; name=&apos;icon&apos;&gt;            &lt;input type=&quot;submit&quot;&gt;        &lt;/form&gt;2.接受,处理文件: 使用$_FILES[&apos;name属性&apos;]接受, 返回结果为关联数组&lt;?php// 处理上传文件// 1.接受文件$files = $_FILES[&apos;files&apos;]; var_dump($files);// 返回一个关联数组, 有5个属性://  1.name：保存的是文件名// ​ 2.type：保存的是文件类型// ​ 3.tmp_name：保存的是客户端上传来的文件临时保存的路径// ​ 4.error：错误信息代码// ​ 5.size：文件大小// 2.保存文件到本地:  拿到临时路径, 指定文件新的路径地址$oldPath = $files[&apos;tmp_name&apos;];$newPath = &quot;./data/&quot;.$files[&apos;name&apos;]; //不转码的路径//文件名含中文需要转码$gbk = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $files[&apos;name&apos;]);$newPath = &quot;./data/&quot;.$gbk; // 转码路径// 3.转移到本地: 使用move_uploaded_file(old, new)方法$res = move_uploaded_file($oldPath, $newPath);if ($res):    echo &quot;success&quot;;    echo $res;else:    echo &quot;failed&quot;;endif;?&gt;3.文件读写操作    a. file_put_contents(&apos;文件路径&apos;,写入内容);    b. file_get_contents(&apos;文件路径&apos;)4.文件存在判断: 返回布尔值    file_exists(&apos;文件路径&apos;);</code></pre></li></ul><h2 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h2><ul><li><p>增删改查</p><pre><code>1. 增删改    // php操作数据库    // 1. 建立链接: 服务器地址, 主机用户名, 密码, 数据库名    $link = mysqli_connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;hh0127&apos;, &apos;userInfo&apos;);    // 2.准备sql语句    // 增    $sql = &quot;insert into user(userName, description) values(&apos;胡华&apos;, &apos;你最帅啦&apos;)&quot;;    // 删    $delete = &quot;delete from user where id = 2&quot;;    // 改    $sql = &quot;update user set userName=&apos;huhua&apos;,description=&apos;我是哈哈&apos; where id=5&quot;;    // 3.执行语句: mysqli_query(数据库链接, sql语句)  返回值: 是否成功    $res = mysqli_query($link, $sql);    $affect_row = mysqli_affected_rows($link);  // 返回受影响的行数    // 4.关闭链接    mysqli_close($link);2. 查询    // 1.建立连接    $link = mysqli_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;hh0127&apos;, &apos;userInfo&apos;);    // 2.sql查询语句    // $sql = &quot;select * from user&quot;;    // 查询语句    $sql = &quot;select userName,description,id from user&quot;;    $res = mysqli_query($link, $sql); // 返回的是一个对象,数据表结构    // 3.取数据: 使用,mysqli_fetch_all(执行sql语句后的对象)      // 传入参数MYSQLI_ASSOC或者1, 可以将返回的数组内的 键 改为 字段名    // $result = mysqli_fetch_all($res, MYSQLI_ASSOC);     $result = mysqli_fetch_all($res, 1); // 返回一个二维数组: 他的元素为: 一个个关系型数组    echo $result[2][&apos;description&apos;];    // 复杂类型输出    print_r($result);    // 断开连接    mysqli_close($link);</code></pre></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从Web服务器传输超文本到本地浏览器的传送协议,是一个协议集。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><ul><li><p>主要特点</p><pre><code>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。</code></pre></li><li><p>http的工作原理</p><pre><code>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</code></pre></li><li><p>请求和响应的结构</p><pre><code>1.HTTP请求: 请求行（request line）、请求头部（header）、空行和请求数据(实体)</code></pre></li></ul><p><img src="https://i.imgur.com/gxdAtNS.png" alt=""></p><pre><code>GET /index.html HTTP/1.1Host    img.mukewang.comUser-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept  image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明:请求类型为GET,index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等第三部分：空行，请求头部后面的空行是必须的;即使第四部分的请求数据为空，也必须有空行。第四部分：请求数据也叫主体，可以添加任意的其他数据。post请求时所传参数也在其中...2.HTTP响应: 也包括4部分,分别是: 状态行、响应报头、空行和响应正文。举个栗子:    HTTP/1.1 200 OK    Date: Fri, 22 May 2009 06:07:21 GMT    Content-Type: text/html; charset=UTF-8    &lt;html&gt;          &lt;head&gt;&lt;/head&gt;          &lt;body&gt;                &lt;!--body goes here--&gt;          &lt;/body&gt;    &lt;/html&gt;第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）第二部分：响应报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</code></pre><p><img src="https://i.imgur.com/SAkMEA9.png" alt=""></p><pre><code>响应状态码</code></pre><h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><ul><li><p>使用方法</p><pre><code>php中关于cookie和session的使用方法:1.cookie:    // 设置cookie    // 1.设置键, 2.设置值, 3.过期时间: time()+时间段    setcookie(&apos;key1&apos;, &apos;value1&apos;, time()+60);    // 修改cookie: 在原有的cookie上修改其值    setcookie(&apos;key1&apos;, &quot;value1111&quot;, time()+60*10);    // 手动删除cookie: 设置cookie的时间为过去时间: time()-10    setcookie(&apos;key1&apos;, &apos;value1111&apos;, time()-10);    // 获取cookie: $_COOKIE方法    echo &quot;我是cookie值&quot;.$_COOKIE[&apos;key1&apos;];    // cookie的值为string类型    // cookie是在服务器中设置,并随着响应报文返回到浏览器的2.session:    // 1.只要时使用到session: 必须先开启session    session_start();    // 2.设置session: 使用超全局变量$_SESSION    $_SESSION[&apos;admin&apos;] = &apos;huhua&apos;;    $_SESSION[&apos;admin1&apos;] = &apos;huhua1&apos;;    // 3.修改: 对键重新赋值即可    $_SESSION[&apos;admin1&apos;] = &apos;huhua_hello&apos;;    // 4.删除        // 1.开启会话        session_start();        // 2.删除会话 unset        unset($_SESSION[&apos;admin&apos;]);    // 5.获取session值        // 1.开启会话        session_start();        // 2. 通过超全局变量获取        $session = $_SESSION[&apos;admin&apos;];        $session1 = $_SESSION[&apos;admin1&apos;];    注意点:    // 6.session会话: 浏览器关闭就关闭会话    // 7.服务器会生成一个sessionID, 通过响应报文(包含在cookie字段中) 返回给浏览器    // 8.Session 可以存放复杂数据类型    $_SESSION[&apos;arr&apos;] = array(1,2,3,4);</code></pre></li></ul><h2 id="cookie和session的区别和使用"><a href="#cookie和session的区别和使用" class="headerlink" title="cookie和session的区别和使用"></a>cookie和session的区别和使用</h2><p>这个在网上查看了很多资料,选择一个比较好理解的放在这里</p><p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，需自己去解决这个问题。不然有些情况下即使是同一个网站每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>cookie时在我们访问某些网站后在本地存储的一些网站相关信息，下次访问时可以减少一些步骤。更准确的说法是：Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器，是在客户端保持状态的方案。</p><p><strong>Cookie的主要内容包括：名字，值，过期时间，路径和域。</strong><br>key, value形式。过期时间可设置的，如不设，则浏览器关掉就消失了，存储在内存当中，否则就按设置的时间来存储在硬盘上的，过期后自动清除，比方说开关机关闭再打开浏览器后他都会还存在，前者称之为Session cookie 又叫 transient cookie，后者称之为Persistent cookie 又叫 permenent cookie。路径和域就是对应的域名，a网站的cookie自然不能给b用。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session是存在服务器的一种用来存放用户数据的对象。</p><p>浏览器第一次发送请求时，服务器自动生成了一HashTable和一Session ID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。</p><blockquote><p>一般这个值会有个时间限制，超时后毁掉这个值，默认30分钟。</p><p>当用户在应用程序的 Web页间跳转时，存储在 Session 对象中的变量不会丢失而是在整个用户会话中一直存在下去。<br>Session的实现方式和Cookie有一定关系。建立一个连接就生成一个session id，打开几个页面就好几个了，这里就用到了Cookie，把session id存在Cookie中，每次访问的时候将Session id带过去就可以识别了.</p></blockquote><pre><code>设置session的过期时间:    1. 修改服务端中配置的session生命周期    2. 通过时间戳来手动删除(unset)session值</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>cookie </p><p>  登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</p></li><li><p>session</p><p>  session一个场景是购物车，添加了商品之后客户端可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</p></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1、Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。</p><p>2、Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session是没有大小限制和服务器的内存大小有关。</p><p>3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。</p><p>4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是总结一些网页中php的使用方式…&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Ajax相关总结</title>
    <link href="http://yoursite.com/2018/12/13/Ajax%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/13/Ajax基础/</id>
    <published>2018-12-13T02:53:33.000Z</published>
    <updated>2019-01-05T01:55:01.418Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于Ajax内容的总结,主要是总结一些基本用法和注意事项…以及封装的方法..日常使用中的一些注意事项.<br><a id="more"></a></p><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax?"></a>什么是Ajax?</h2><p>一般来说,我们向服务器发送一次HTTP请求就会对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。  </p><p>通俗的来讲,Ajax是一种技术, 一种可以让网页某个局部部分动态地给服务器发起请求，而不用整个页面刷新。是一种可以<strong>局部发请求</strong>的技术…</p><h2 id="Ajax的使用步骤"><a href="#Ajax的使用步骤" class="headerlink" title="Ajax的使用步骤"></a>Ajax的使用步骤</h2><pre><code>1.首先我们要确定好需求(使用场景), 也就是什么时候(在事件中使用,或者达到某一条件时)去使用Ajax...2.XMLHttpRequest对象, js中专门用于发送局部请求的对象    a.首先,需要使用new关键字去初始化一个xhr对象,别忘记少写new    var xhr = new XMLHttpRequest();    b.接着是构造请求: 一个请求包括: 请求行,请求头(各个字段),空行, 请求体(数据)    xhr.open(&apos;get&apos;,&apos;请求路径&apos;); // 默认异步, get方式,参数同过url拼接传入: ?key1=value1&amp;k2=v2    xhr.open(&apos;post&apos;,&apos;目标路径&apos;); // 参数通过后面的send方法传入    **b1** post方式请求时需要 构造一个请求头部,不然服务器不会返回数据    xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);    // 注意,服务器的响应体中 也会注明响应文件的content-type, 接受时也需要注意    c.发送请求    xhr.send(); // get方法不用传值,直接发送    xhr.send(&apos;name=huhua&amp;age=18&apos;) // post方式将目标参数同过键值对方式传入    d.进行事件监听,获取服务器响应回来的数据    // 需要判断  请求对象.请求状态和响应状态:   readyState 和  status    xhr.onreadystatechange = function() {        // 判断状态码        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            // 这里就可以处理 响应数据            document.getElementById(&apos;tips&apos;).innerHTML = xhr.responseText;        }    }</code></pre><h2 id="Ajax中传输的数据格式JSON"><a href="#Ajax中传输的数据格式JSON" class="headerlink" title="Ajax中传输的数据格式JSON"></a>Ajax中传输的数据格式JSON</h2><p>为了方便数据跨平台(各语言之间)传输,json对象就被发明了…<br><strong>JSON本质上就只是一个按规定格式写的字符串</strong></p><pre><code>json对象: 一种数据格式, 键为string(必须用双引号), 值为string,number,boolean类型 &apos;{&quot;key1&quot;: &quot;hello&quot;, &quot;key2&quot;: &quot;world&quot;, &quot;key3&quot;: 1, &quot;key4&quot;: true}&apos;;&apos;[{&quot;key1&quot;: &quot;hello&quot;, &quot;key2&quot;: &quot;world&quot;, &quot;key3&quot;: 1, &quot;key4&quot;: true}, {&quot;number&quot;:222}]&apos;;</code></pre><ul><li><p>json的转化</p><pre><code>json在各个语言都有对应的api进行转化,这里就讲一下js和php中的转化方法json对象(字符串包裹是对象或者数组)         通过 JSON.parse()  json转为js对象和数组        通过 stringify()   js转json字符串php中: json_encode() json编码为php对象       json_decode() php对象解码为json对象</code></pre></li></ul><h2 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h2><pre><code>XML也是一种标记语言,同json一样也是用于数据传输的...(体积较大)XML的结构:    &lt;root&gt;        &lt;item&gt;            &lt;id&gt;1&lt;/id&gt;             &lt;name&gt;华仔&lt;/name&gt;             &lt;age&gt;22&lt;/age&gt;         &lt;/item&gt;     &lt;/root&gt;由根节点,以及双标签组成, 标签名自己随意写,符合规范即可...XML和html中document相似, 也可以调用DOM方法, 比如元素的获取等等...</code></pre><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul><li><p>同源策略</p><pre><code>浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。基本上所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。 那么不同源就是跨域:    这里有两个url  http://www.example.com/index.html 和 https://www.example.com/demo.html/    以上两个url就是不同源的,他们的遵守的协议不一样; 如果协议, 域名, 端口中只要有一个不相同就为不同源;    所以, 不同源就是跨域...</code></pre></li><li><p>跨域问题地解决方案</p><pre><code>当我们需要在一个域名下请求另外一个域名的资源时,此时Ajax请求不能使用,该怎么办呢?1.jsonp    jsonp的原理就是利用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，    并且以get的方式将前端回调处理函数名称(callback=functionName)告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式(function(data))传递回去,然后script标签将返回的响应内容当作js代码执行。// 浏览器客户端实行步骤    1. 定义一个函数func用来处理接受到响应地json数据    2. 动态地创建script标签, 添加src属性,添加到body或者head标签中    3. 给这个src属性赋值, 值为api接口地址并拼接上回调函数callback=func    4. 在函数func内部处理接受到的参数args...注意: JS中还有其他三个标签可以进行跨域请求img 、iframe、link(stylesheet)但他们都有缺陷    a. img  //支持跨域但是无法实现获取服务端返回的数据    b. &lt;iframe src=&quot;https://www.baidu.com&quot;&gt;&lt;/iframe&gt; //支持跨域，可以接收服务端数据，但是过程复杂    c. &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://www.baidu.com&quot;&gt; //会在CSS处理阶段报错2.CORS    Cross-Origin Resource Sharing(跨域资源共享)是一种允许当前域（origin）的资源（比如html/js/web service）被其他域（origin）的脚本请求访问的机制。    当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头:origin,    后端在接受到请求后确定响应后会在Response Headers 中加入一个属性Access-Control-Allow-Origin: 这里是发起请求地地址, *表示所有人都能访问3.服务器跨域    在前后端分离的项目中可以借助服务器实现跨域，具体做法是：        a.前端向本地服务器发送请求，本地服务器代替前端再向api服务器接口发送请求进行服务器间通信，        b.本地服务器其实就是个中转站的角色，再将响应的数据返回给前端4.postmessage跨域    HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），    该方法可以通过绑定window的message事件来监听发送跨文档消息传输内容。    使用postMessage实现跨域的话原理就类似于jsonp，动态插入iframe标签，再从iframe里面拿回数据</code></pre></li></ul><h2 id="通过模板动态添加网页元素"><a href="#通过模板动态添加网页元素" class="headerlink" title="通过模板动态添加网页元素"></a>通过模板动态添加网页元素</h2><p>当我们从后端接口拿到数据后,需要动态的将元素添加到网页中; 一般有几种方式可以做到</p><pre><code>a. 找到数据填充的标签, 创建这个标签, 然后数据用 字符串拼接 的方式组合在一起,最后appendchild到父元素身上b. 通过 引入模板的方式 来实现元素的添加; 这种方式更为快速,方便举个粒子: obj是一个对象    a.字符串拼接法     var pList = document.querySelectorAll(&apos;p&apos;);    pList[0].innerHTML = &quot;QQ号:  &quot; +  obj.result.qq;    pList[1].innerHTML = &quot;得分:  &quot; +  obj.result.score;    pList[2].innerHTML = &quot;吉凶论断:  &quot; +  obj.result.luck;    pList[3].innerHTML = &quot;论断详情:  &quot; +  obj.result.content;    pList[4].innerHTML = &quot;性格分析:  &quot; +  obj.result.character;    pList[5].innerHTML = &quot;性格详情:  &quot; +  obj.result.characterdetail;    b.模板法添加元素    &lt;!-- 1.引入模板 --&gt;    &lt;script src=&quot;../../js/template-web.js&quot;&gt;&lt;/script&gt;    &lt;!-- 2.使用script标签创建模板, a.指定模板的 type 不能位JavaScript文件类型; b.定义一个id确定模板位置--&gt;    &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;        &lt;!-- 遍历这个data对象(单个对象) --&gt;        {{ each obj value key }}            &lt;p&gt;{{key}} : {{value}}&lt;/p&gt;        {{ /each }}    &lt;/script&gt;    // 3.调用模板的api: template函数    var html = template(&apos;tpl&apos;, {obj: obj.result}); // 返回一个html结构    document.getElementById(&apos;box&apos;).innerHTML = html; // 将内容添加到box的盒子</code></pre><h2 id="Ajax的封装"><a href="#Ajax的封装" class="headerlink" title="Ajax的封装"></a>Ajax的封装</h2><ul><li><p>原生js封装</p><pre><code>Ajax请求封装:     1.声明一个函数    2.相同部分放入函数体    3.调用函数    4.不同部分当作参数: 请求类型type 和 url    5.对请求方式大小写的处理    6.请求参数data    7.传入回调函数callback, 处理响应体    8.自动转换响应体数据的类型datatype, json,xml,或者普通json字符串(不做处理)    9.将参数作为对象    10.避免变量名污染, 定义一个对象,将参数放在一个对象中// 如果不想在回调函数内操作响应数据,可以使用一个全局变量去储存 Ajax接受到的响应体的值 xhr.responseTextdocument.getElementById(&apos;btn&apos;).onclick = function () {    // 参数: 请求方法, url, url参数, 回调处理函数function(res){}, 响应内容处理格式datatype    var params = {        type: &apos;get&apos;,        url: &apos;req.php&apos;,        data: &apos;name=helloworld&apos;,        callback: function (res) {            // 这里的函数是对Ajax响应体的处理函数            console.log(res);        },        datatype: &apos;json&apos;,    };    request.ajax(params);};var request = {}; // 定义一个对象request.ajax =  function(params) {    // 响应类型大小写转换    var type = params.type.toLocaleLowerCase();    // 判断请求类型,发送对应请求    if (type == &apos;get&apos;) {        // get请求的 url拼接        params.url += &quot;?&quot; + params.data;    }    // 创建请求    var xhr = new XMLHttpRequest();    xhr.open(type, params.url);    // 如果是发送post请求    if (type == &apos;post&apos;) {        xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);        xhr.send(params.data);    }else {        xhr.send();    }    // 响应监听    xhr.onreadystatechange = function () {        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            var xhr_res = xhr.responseText;        }else {            return &apos;访问失败&apos;;        }        // 处理响应数据, 判断用户需要哪种数据        var res;        if (params.datatype) {            params.datatype = params.datatype.toLocaleLowerCase();             if (params.datatype == &apos;json&apos;) {                res = JSON.parse(xhr_res);            }            if (params.datatype == &apos;xml&apos;) {                var parser = new DOMParser();                res = parser.parseFromString(xhr_res, &apos;text/html&apos;);            }        } else {            res = xhr_res; // 实际字符串        }        // 回调函数处理        params.callback(res);    }}</code></pre></li><li><p>jQuery中的封装调用</p><pre><code>// btn1点击事件$(&quot;#btn1&quot;).click(function () {    // 发送get请求    $.get({        url: &quot;./get.php&quot;,        // data: {name: &apos;get&apos;},        success: function(res) {        // 处理响应体的回调函数        // header(&apos;content-type:application/text;charset=utf-8&apos;);        // 注意!!! 后端设置的文件类型格式(text/html, json等等...)也会 限制响应体格式的输出..., 有可能拿不到res        console.log(res);    },        error: function(res) {    //  处理响应体的回调函数    //      console.log(res);    //  }        // dataType: &quot;json&quot; &quot;jsonp&quot; &quot;xml&quot;, 如果后端api返回的数据是普通字符串,就不需要传这个参数        // 如果用jQuery发jsonp请求，不用创建script，只要dataType写一个jsonp    })})// btn点击事件$(&quot;#btn2&quot;).click(function () {    // 发送post请求    $.post({        url: &quot;./post.php&quot;,        data: {name: &apos;post&apos;},        success: function(res) {            //处理响应体的回调函数            console.log(res);        },    })})// btn3点击事件$(&quot;#btn3&quot;).click(function () {    // 发送任意请求    $.ajax({        url: &quot;./ajax.php&quot;,        data: {name: &apos;bob&apos;},        type: &quot;get&quot;, // 指定请求类型        success: function(res) {            // 处理响应体的回调函数            console.log(res);        },        dataType: &quot;json&quot;,    })})</code></pre></li><li><p>form表单序列化</p><pre><code>$(&apos;.submit&apos;).click(function () {    // 先获取所有数据, 通过form表单序列化方法    // jQuery中的表单序列化：$(表单).serialize方法; 表单必须有name属性    // 获取的序列化字符串的key值 就是name属性的值    var data = $(&apos;#ajaxForm&apos;).serialize();    console.log(data);    // 发送请求核对    $.post({        url: &quot;_api/register.php&quot;,        data: {data},        // 回调函数处理响应内容        success: function (res) {            console.log(res);        }    });})</code></pre></li></ul><h2 id="Ajax应用中的一些注意事项"><a href="#Ajax应用中的一些注意事项" class="headerlink" title="Ajax应用中的一些注意事项"></a>Ajax应用中的一些注意事项</h2><pre><code>1.面向接口编程:    当网站数据变化时,页面需要动态的向服务器去发送局部请求(异步方式)数据,这时我们需要弄清楚:        a. 请求的接口(即一个url)        b. 请求方式(get, post, 其他....)        c. 请求的参数(data: {data1: xxxx, data2: yyyy,....}); 键值对的形式        d. 请求的响应体格式; (jQuery中的&quot;jsonp&quot;格式 是发送的跨域请求)        e. 回调函数(obj): 也就是我们去处理响应内容的方式...        // 一般就是拿到响应体后, 取出响应体的数据,去动态给网页上要变化的标签元素赋值,        // 对于同类型的网页元素模块我们可以使用模板去赋值,(script标签中导入模板, 准备模板(数据填入模板),) 这样可以节省开发时间 模板template(&apos;元素id&apos;, {data1: xxx, data2: yyy}) 传多个值2.页码刷新内容    a.通过a标签的href属性, href=&quot;javascript: func(page值)&quot;, 来实现传参,并发送请求, 完成页面刷新;    b.通过button标签的添加行内点击事件实现,调用一个Ajax请求函数        如: &lt;button onclick=&quot;update_all(&apos;approved&apos;)&quot; class=&quot;btn btn-info btn-sm&quot;&gt;批量批准&lt;/button&gt;3.动态加载的元素的事件注册问题    当元素是动态异步加载的时候,事先的事件注册不会实现给后来加载的元素    这里一般要用到 委托注册(冒泡原理: 当元素的事件触发时,父级的同名事件也会依次触发...)给父元素注册即可4.分页组件, 页面动态加载    a.前端分页的实现: 适用于数据较少/分页较少的情况。        在前端分页的实现中，通过接口一次性获取列表的所有内容，根据数据的总长度和每页需展示的个数计算总页数；        之后的每次加载操作（滚动/点击）中，依次执行数据截取、DOM 渲染、插入结构的过程，直至最后一页。    b.在后端分页的实现:        在加载时，前端通过页码page来拉数据，若返回非空数组，则进行 DOM 渲染，插入接口的操作；        若返回空数组，则说明当前请求的为最后一页的数据，无需再发送请求。        将需要的字段通过sql语句查询出来; 返回一个data数组,和数据的长度用来当作总页数;    c.注意事项:         1.当遇到多级分页时, 一种实现的方式是, 将SQL语句进行分离,判断,和拼接;不同情况使用不同的语句;        2.select表单元素的值: 如果有value属性, 通过方法获取的值会是value值;         而不是元素标签中的文本值; 所以要想动态获取option的去掉标签的value属性        3.模板的使用: twbsPagination插件; 导入jQuery,和bootstrap;        // 这个分页插件只会默认初始化一次; 要解决页码变化的问题:            // 调用模板的初始化方法, 传入destroy, 可以清除上一次的分页状态, 下一次重新生成新的分页            $(&apos;.pagination&apos;).twbsPagination(&apos;destroy&apos;);            $(&apos;.pagination&apos;).twbsPagination({                    totalPages: obj.total_page,                    visiblePages: 5,                    initiateStartPageClick: false,                    first: &quot;首页&quot;,                    prev: &quot;上一页&quot;,                    next: &quot;下一页&quot;,                    last: &quot;尾页&quot;,                    startPage: page, // 高亮页设置                    onPageClick: function (event, page) {                        // 每次点击时会自动加载                        load_post(page);                    }                })                }            })5.批量操作表格数据 tr    一般每个tr都会对应着一条数据; 那么在动态批量操作时需要注意:    a.需要将数据库中设置的id值赋值给每一行的标签的一个属性上 作为这条数据的标识;    b.然后前端在操作行数据时, 获取目标行的状态和id值(jQuery中使用each方法:each(function (index, ele) {xxxxx}操作比较好)    然后将获取的值传给后端, 后端通过sql语句的in语法来批量修改字段值;    // 注意一些特殊处理: 一般就是末页数据加载的问题, 末页单行数据操作等等.....6. FormData对象// 前提是form表单中&amp;&amp;带name属性的 input标签:    js中 FormData对象在实例化的时候传入一个表单对象，那么它就会自动获取到表单中所有带name属性的表单元素提交给服务器    jQuery里的表单序列化(serialize): $(&apos;#ajaxForm&apos;).serialize()，但是表单序列化不能拿到文件file，所以是无法做文件异步上传的    可是FormData是可以获取文件的; 一般在做表单数据上传时,    // 先获取页面表单的内容, 这里直接通过 FormData 对象来拿到表单里面的数据;     var fm = new FormData($(&apos;form&apos;)[0]); 传入的为DOM对象!!!!    // 非表单标签元素: 如富文本插件内容 需要手动添加, 并设置对应的 key值, 即字段值    fm.append(&quot;content&quot;, editor.txt.html());    // 上面讲到的富文本插件:  导入模板, 调用对应的api方法生成即可    // 实例化一个editor对象    var editor = new wangEditor(&apos;#content&apos;);    // 调用create方法创建    editor.create();// 注意事项:    使用ajax发送 post提交请求时, 不要忘记 加上下面两个参数    data: fm,    // 使用FormData时; 需要加上两个参数: 内容格式和数据处理 都为false    contentType: false,    processData: false,// 表单元素file    // file表单元素:  files属性: files[0];  上传多个文件 + multiple属性; 提交多个文件给服务器保存时需要注明name=&quot;icon[]&quot;    console.dir(this.files[0]); //可以打印出文件详细的属性信息    当上传文件为图片时:    要实现图片的预览功能: 可以给file表单添加: onchange事件, 当值改变时, 给img标签添加 src属性     // 图片保存方案:    a.临时url方案: URL.createObjectURL(表单.files[0])    b.永久url方案: 将上传图片发送到服务器, 服务器保存; 下次在返回路径7.混编时数据的添加    数据库中查找出的数据: 由于返回的是二维数组:        a.当页面渲染时只要添加一组数据时, 直接取出来做操作arr[0];        b.当页面需要添加多组数据时, 需要遍历二维数组中的内容arr, 将每项内容添加到指定位置    关于点赞数的局部刷新: 将数据库中字段值取出来存在 行内属性上,点击后将新数据提交给服务器,自己+1    文章阅读数+1: 页面加载一次则+1, 然后更新到数据库中</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于Ajax内容的总结,主要是总结一些基本用法和注意事项…以及封装的方法..日常使用中的一些注意事项.&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性学习</title>
    <link href="http://yoursite.com/2018/12/13/CSS3%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/13/CSS3特性学习总结/</id>
    <published>2018-12-13T02:53:33.000Z</published>
    <updated>2019-01-08T15:33:29.374Z</updated>
    
    <content type="html"><![CDATA[<p>关于css3的新特性学习总结…当然c3属性的使用要考虑到浏览器的兼容性问题…<br><a id="more"></a></p><h1 id="css3新特性学习"><a href="#css3新特性学习" class="headerlink" title="css3新特性学习"></a>css3新特性学习</h1><h2 id="边框系列"><a href="#边框系列" class="headerlink" title="边框系列"></a>边框系列</h2><ul><li><p>圆角</p><pre><code>/* 圆角border-radius */div {    /* 从左上角开始 */    /* border-radius: 20px 30px 40px 50px; */    /* 左上右下, 右上左下 */    /* border-radius: 20px 40px;  */    /* 全部一样 */    border-radius: 40px;}// 当半径为50%时,就会显示一个圆</code></pre></li><li><p>阴影</p><pre><code>/* 盒子阴影box-shadow */div {    /* 阴影水平偏移距离, 垂直偏移, 模糊半径, 阴影背景色 */    box-shadow: 10px 10px 10px #ccc,20px 20px 10px green;}文字阴影text-shadow和上面一样, 也可以同时叠加多个阴影...</code></pre></li></ul><h2 id="背景系列"><a href="#背景系列" class="headerlink" title="背景系列"></a>背景系列</h2><pre><code>.box {        /* 盒子必须要有宽高,才能存放背景图片 */        width: 400px;        height: 400px;        /* 可以设置多个背景图 */        background: url(&quot;../messi.jpg&quot;) no-repeat right top,        url(&quot;../xiaoxin.jpg&quot;) no-repeat left bottom,        #ccc;        // 背景连写中可以使用 / cover或者contain来等比例缩放图片,也可以写尺寸        /* 可以改变背景图尺寸 */        background-size: 25% 25%;        /* 背景图存放区域: 默认padding-box, 还有content和border  */        background-origin: padding-box;    }</code></pre><h2 id="渐变系列"><a href="#渐变系列" class="headerlink" title="渐变系列"></a>渐变系列</h2><p>css3渐变(gradients)可以让你在两个或者多个指定的颜色之间显示平稳的过度。</p><ul><li><p>线性渐变（Linear Gradients)</p><pre><code>这种渐变可以向上、向下、向左、向右甚至是各个你想要的方向(角度45deg)。div {    width: 400px;    height: 100px;    /* 线性渐变: 指定渐变方向, 和至少两种颜色, 浏览器兼容 */    background: -webkit-linear-gradient(left, red, green, blue);    background: -o-linear-gradient(left, red, green, blue);    background: -moz-linear-gradient(left, red, green, blue);    background: linear-gradient(to right, red, green, blue);}// 按角度方向渐变.san {    width: 100px;    height: 100px;    background: linear-gradient(-135deg, blue 20px, red 0);}</code></pre></li><li><p>径向渐变（Radial Gradients）</p><pre><code>这种渐变即由中心出发，向四周渐变。创建一个径向渐变，我们至少定义两种颜色结点。同时也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是center，形状是ellipse，渐变的大小是fasthest-corner（表示最远的角落）。其中形状还可以是circle（圆形）、大小还可以是choset-side和closest-corner和farthest-side。语法:background: radial-gradient(center, shape size, start-color, ..., last-color);// 还可以写成 (半径 at 方位值, 渐变颜色 开始渐变位置 渐变结束位置,....).radial {    width: 400px;    height: 300px;    /* 默认渐变, 渐变距离位置由父容器决定 */    background: radial-gradient(red, blue);    /* 圆形渐变, 默认半径是容器对角线的一半,也可以指定渲染半径 */    background: radial-gradient(100px circle, red, yellow);    /* at指定起始位置: 距离左上角的距离, 默认是中心*/    background: radial-gradient(at 50% 50%, red, yellow);    /* 指定终止位置: 父容器的近边, 近角; 远边,远角 */    background: radial-gradient(closest-side circle at 20% 20%, red, yellow);    /* 指定颜色断点,当多个颜色一起时,默认是均匀分配渐变区域的 */    background: radial-gradient(closest-side circle, yellow 20%, orange 40%, red 60%, #ccc);    /* 椭圆渐变, 渐变叠加*/    background: radial-gradient(100px 200px ellipse, transparent 40px, yellow, red 50px, transparent),    radial-gradient(30px circle, red, red 29px, transparent);    /* background-size: 40px; */}/* 水波纹效果: 通过伪类添加效果 */.shuibo {    width: 200px; height: 100px;    background: yellow;    position: relative;}.shuibo:after {    content: &apos;&apos;;    position: absolute;    height: 10px;    left:0 ;     right: 0;    bottom: -10px;    background: radial-gradient(20px 15px ellipse at top, red 10px, transparent 11px);    background-size: 20px 10px;}</code></pre></li></ul><h2 id="transform-2d转换"><a href="#transform-2d转换" class="headerlink" title="transform 2d转换"></a>transform 2d转换</h2><pre><code>/* transform 2d方法 */img {    /* 1.translate(): 相对元素自身原来位置向X,Y轴移动 */    transform: translate(100px,100px);    /* 2.ratote(): 旋转的度数, 正数就是顺时针旋转 */    /* 会覆盖上面的位移方法 */    transform: rotate(45deg);    /* 3.scale(): 基于原图宽高放大缩小 */    /* 高度或宽度设为0就隐藏了 */    transform: scale(0.5, 1);    /* transform: scale(0.5, 0); */    /* 4.skew(): 沿X,和Y轴倾斜转换 */    transform: skew(20deg, 0deg);    /* 转换的基点属性: 默认为中心 */    // 也可以给方位值,top, right bottom left    /* transform-origin：0 0；表示以左上角为原点    transform-origin：100% 0；表示以右上角为原点    transform-origin：0 100%；表示以左下角为原点    transform-origin：100% 100%；表示以右下角为原点 */}</code></pre><h2 id="transform-3d转换"><a href="#transform-3d转换" class="headerlink" title="transform 3d转换"></a>transform 3d转换</h2><ul><li><p>rotateXYZ</p><pre><code>.box1 {    /* 2d的rotate()方法只是在平面内顺时针旋转,相当于rotateZ() */    /* 3d的方法绕X,Y,Z轴进行空间旋转 */    transform: rotateX(30deg) perspective(600-800px);      transform: rotateY(30deg);      transform: rotateZ(30deg);  }// 加上一个perspective(600-800px)立体效果更好看一些; // 注意: 视距perspective属性要给 不参与运动的 父元素加 动画效果比较合理// 还需要开启3D效果, transform-style: preserve-3d;// 通过3D转换 + animation属性可以实现比较炫酷的动画效果; 一般都是通过将元素向X,Y,Z方向平移或者旋转进行组合;注意transform属性中将 rotate,translate等...连写起来组合效果.</code></pre></li></ul><h2 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h2><p>这个属性可以轻松的实现从某种效果到另一种效果的渐变过程</p><pre><code>一般情况下，该属性即transition必须规定2项内容指定要添加效果的css属性（这样才能识别做哪个方向的过渡，通常是width、height）指定效果的持续时间（默认持续时间为0，所以必须要指定;还有运动的类型(匀速linear,ease-in...), 还有steps()参数, 分几步完成过渡</code></pre><blockquote><p>  <strong>注意：该属性必须结合伪类:hover来使用</strong>。</p></blockquote><pre><code>.box {    /* 开始的样式 */    width: 100px;    height: 100px;    background-color: rgb(75, 214, 110);    font-size: 14px;    /* transition:指定要过渡的属性, 过渡时间 */    /* transition: width 3s, height 3s, transform 3s, font-size 3s; */    /* (all表示所有属性都过渡),/*第2个时间参数是delay,过1秒才触发 */     transition: all 3s 1s;}.box:hover {    /* 最终的样式 */    width: 500px;    height: 500px;    transform: rotate(360deg);    background-color: red;    font-size: 40px;}</code></pre><h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>创建css3动画，需要使用@keyframes规则。使用该规则即创建动画，它规定了一个css样式和动画将逐步从目前的样式更新为新的样式。</p><p><strong>使用语法:</strong></p><blockquote><p> 1.先给目标元素设置一个animation属性: </p></blockquote><p><img src="https://i.imgur.com/Y0HTfzS.png" alt=""></p><pre><code>animation-name: wobble;/*动画属性名，也就是我们前面keyframes定义的动画名*/animation-duration: 10s;/*动画周期持续时间*/animation-timing-function: ease-in-out; /*动画频率，匀速为linear, 分步为steps*/ animation-delay: 2s;/*动画延迟时间*/animation-iteration-count: 10;/*定义循环次数，infinite为无限次*/animation-direction: alternate;/*动作方式:往返*/animation-play-state: 播放状态animation-fill-mode: 是否停留在动画最终样子 当然, 一般都会采用连写方式,下面举例说明</code></pre><blockquote><p>2.再来规定动画的名称 @keyframes 动画名 {阶段值}</p></blockquote><pre><code>.letter {        float: left;        padding: 10px;        line-height: 200px;        font-size: 30px;        animation: showHide 2s linear infinite;    } @keyframes showHide  // 注意 /* 百分比表示从0到动画时长的百分之多少, 执行{}中的动画; */ /* 注意,执行多种动画效果,需要将{}前面阶段的属性在写一遍; 不然会覆盖同类属性 */ /* 如果只写到80%阶段; 剩下的时间则用来复原到初始状态 */    {        0% {opacity: 1;}        50% {opacity: 0.1;}        100% {opacity: 1;}    }// 还可以使用form to语法// 多个动画使用逗号,隔开// 一般可以使用封装好的动画库</code></pre><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>img来添加border-radius属性，可以添加border属性，可以添加padding属性（注意：img是行内元素，但是也可以添加padding属性）。<br>我们还可以制作响应式图片。并且可以在图片上添加文本。以及图片滤镜。和响应式图片相册。</p><pre><code>img {        /* 图片添加边框,padding,圆角,阴影属性 */        border: thin solid red;        padding: 10px;        border-radius: 10px;        box-shadow: 5px 5px 5px greenyellow;    }img {        /* 响应式图片: 宽度随父盒子变化而变化 */        width: 100%;        height: auto;    }/* 图片过滤处理filter属性 */img {        width: 25%;        float: left;        height: auto;        max-width: 250px;    }/* 图片滤镜filter */.blur {filter: blur(4px)}    /* 模糊 */.opacity {opacity: 0.5;}     /* 透明度 */.brightness {filter: brightness(1.5)}  /* 亮度: 0变黑 大于1变亮 */.contrast {filter: contrast(2)}  /* 对比度: 0变黑 大于1变亮 */.grayscale {filter: grayscale(1)}  /* 灰度: 0-1之间  变灰*/.hue-rotate {filter: hue-rotate(180deg)}  /* 色相旋转: 0-360deg之间 */.invert {filter: invert(1)}  /* 反转输入图像: 0-1之间  曝光效果*/.sepia {filter: sepia(1)}  /* 转为深褐色: 0-1之间, 怀旧风格 */</code></pre><p>C3属性就先写到这,以后用到再继续更新…</p><h2 id="伪元素-伪类选择器"><a href="#伪元素-伪类选择器" class="headerlink" title="伪元素,伪类选择器"></a>伪元素,伪类选择器</h2><pre><code>1.伪元素选择器    ::before,::after        可以在不改变html结构的情况下，给某个元素里面再加内容        我们一般用它做清除浮动带来的影响    ::first-letter            设置首字母样式    ::first-line            设置首行样式    ::selection            设置选中样式2.伪类选择器(类选择)    // a标签类    :hover 相当于鼠标悬停的效果    :active：a标签点击时的样式（按下去没松手那个状态）    :link   默认样式    :visited 访问之后的样式    // 匹配标签元素    // 搭配其他选择器组成交集选择器（常用的写法）如 li:first-child    :first-child：找到第一个子元素    :nth-child：找到某一个                可以传入具体的数字，就代表找到第几哥。例：传8，就代表找到第8个                可以传n，代表找到所有                可以传odd，代表找到奇数                可以传even，代表找到偶数                mn：代表找到m的倍数，例：3n代表找到3和3的倍数，3,6,9……………………                n+m：代表从m开始一直到最后，例：n+12 从12开始到最后    :last-child：找到最后一个    :not() 排除()中的元素    :focus 设置获得焦点时的样式</code></pre><h2 id="css3动态计算元素的高度及宽度"><a href="#css3动态计算元素的高度及宽度" class="headerlink" title="css3动态计算元素的高度及宽度"></a>css3动态计算元素的高度及宽度</h2><pre><code>1、px    　　像素，我们在网页布局中一般都是用px。2、百分比　　百分比一般宽泛的讲是相对于父元素，自适应网页布局越来越多，百分比也经常用到了3、Viewport　　　当已知一个div的高度时，它的同胞div高度是根据窗口高度减去已知div高度而得到，此时就需要calc函数    　　viewport：可视窗口，也就是浏览器。    　　vw Viewport宽度， 1vw 等于viewport宽度的1%    　　vh Viewport高度， 1vh 等于viewport高的的1%CSS3使用Calccalc()使用通用的数学运算规则，但是也提供更智能的功能：    &gt;使用“+”、“-”、“*” 和 “/”四则运算；    &gt;可以使用百分比、px、em、rem等单位；    &gt;可以混合使用各种单位进行计算；    &gt;表达式中有“+”和“-”时，其前后必须要有空格，如&quot;width: calc(12%+5em)&quot;这种没有空格的写法是错误的；    &gt;表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。    例如 ：设置div元素的高度为 当前窗口高度-100px    div{    height: calc(100vh - 100px);         }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于css3的新特性学习总结…当然c3属性的使用要考虑到浏览器的兼容性问题…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>jQuery常用知识总结</title>
    <link href="http://yoursite.com/2018/12/06/jQuery%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/06/jQuery语法基础/</id>
    <published>2018-12-06T02:53:33.000Z</published>
    <updated>2018-12-24T12:10:52.613Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容是对jQuery和原生JS进行了对比和归纳,主要是总结一些jQuery的常用知识点…<br><a id="more"></a></p><h1 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h1><p>jQuery是一个js库, 它将原生js的一些方法封装起来,简化了js对DOM的动态操作,还做了一些浏览器的兼容处理;另外jquery的很多方法传参后返回就是自己,因此可以进行链式操作;还可以进行隐式迭代等;下面将从几个方面(jQuery对象, 选择器, css样式操作, html节点操作(增删改),位置, 动画, 事件操作等)来对jquery进行解析.</p><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p>当我们引入jquery文件时,相当于执行jquery的代码, 返回的是一个jQuery对象(也可以用$来表示),里面包含很多封装好的方法.</p><ul><li><p>jQuery对象和DOM对象</p><p>  DOM对象: 用原生JavaScript获取的DOM对象<br>  通过document.getElementById()  返回的是元素(DOM对象)<br>  通过document.getElementsByTagName()  返回伪数组(集合)，集合中的每一个对象是DOM对象</p><p>  jQuery对象: jQuery对象用$()的方式获取的对象<br>  jQuery对象又可以叫做包装集(包装的DOM对象的集合)</p><p>  <strong>jQuery对象不能使用DOM对象的成员，DOM对象不能使用jQuery对象的成员</strong></p></li><li><p>jQuery对象和DOM对象的相互转换</p><p>  jQuery对象转换成DOM对象：   </p><pre><code>jQuery对象.get(索引值); jQuery对象[索引值]; jQuery对象是包装集(集合)，从集合中取数据可以使用索引的方式</code></pre><p>  DOM对象转换成jQuery对象：   </p><pre><code>$(DOM对象) 只有这一种方法;</code></pre></li><li><p>入口函数</p><p>  关于jQuery的入口函数：</p><pre><code>// 第一种写法$(document).ready(function() {    });// 第二种写法$(function() {});</code></pre><p>  jQuery入口函数与window.onload的对比:</p><p>  JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。<br>  jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</p></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>jQuery中选择器的作用是用来快速匹配到要操作的元素,使用$(selector)获取jQuery对象, 而原生js是通过document.getElementById(‘box’)等这些方法获取到DOM对象.</p><ul><li><p>基本选择器</p><pre><code>ID选择器     $(&apos;#id&apos;);    获取指定ID的元素类选择器     $(&apos;.class&apos;);    获取同一类class的元素标签选择器     $(&apos;div&apos;);    获取同一类标签的所有元素并集选择器     $(&apos;div,p,li&apos;);    使用逗号分隔，只要符合条件之一就可。交集选择器     $(&apos;div.redClass&apos;);    获取class为redClass的div元素</code></pre></li><li><p>层级选择器</p><pre><code>子代选择器    $(&apos;ul &gt; li&apos;);    获取儿子层级的元素，注意，并不会获取孙子层级的元素后代选择器    $(&apos;ul li&apos;);     代表后代选择器，获取ul下的所有li元素，包括孙子等</code></pre></li><li><p>过滤选择器</p><pre><code>:eq（index）    $(&apos;li:eq(2)&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为2的元素，索引号index从0开始。:odd    $(&apos;li:odd&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为奇数的元素:even    $(&apos;li:even&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为偶数的元素 :enabled :disabled :checked :selected 获取到表单对象属性还有很多不常用的,用到时可以查文档...</code></pre></li><li><p>jQuery筛选选择器(这些都是jQuery对象的方法)  </p><pre><code>通常我们可以用一个$xxx变量将定位地元素先存起来,然后再调用其方法取定位到目标元素...返回地也是jQuery对象.children(selector)     $(&apos;ul&apos;).children(&apos;li&apos;)    相当于$(&apos;ul&gt;li&apos;)，子类选择器find(selector)        $(&apos;ul&apos;).find(&apos;li&apos;);    相当于$(&apos;ul li&apos;),后代选择器siblings(selector)    $(&apos;#first&apos;).siblings(&apos;li&apos;);    查找兄弟节点，不包括自己本身。parent()      $(&apos;#first&apos;).parent();      查找父亲eq(index)      $(&apos;li&apos;).eq(2);    相当于$(&apos;li:eq(2)&apos;),index从0开始next()          $(&apos;li&apos;).next()    找下一个兄弟prev()          $(&apos;li&apos;).prev()    找上一次兄弟....其他可以查阅文档</code></pre></li></ul><h2 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h2><p>属性操作一般是用来获取表单元素和其他元素地内容,以及修改删除等等…<br>原生js中的DOM对象操作属性:</p><p>自定义属性操作: setAttribute(‘attr_name’) getAttribute等…还有点语法操作行内属性</p><ul><li><p>attr的用法</p><pre><code>1. 获取, 设置属性值&lt;!-- 不传参获取不到 --&gt;$(&quot;img&quot;).attr(&quot;src&quot;); //获取文档中所有图像的src属性值。$(&quot;img&quot;).attr({ src: &quot;test.jpg&quot;, alt: &quot;Test Image&quot; }); //为所有图像设置src和alt属性值$(&quot;img&quot;).attr(&quot;title&quot;, function() { return this.src }); //把src属性的值设置为title属性的值2. 删除属性$(&quot;img&quot;).removeAttr(&quot;src&quot;);</code></pre></li></ul><ul><li><p>prop的用法</p><pre><code>对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。1.获取, 设置$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;); // 获取属性, 返回值为true or false$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop({checked: true}); // 全设置为true// 传入回调函数  // 通过函数来设置所有页面上的复选框被选中。$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, function( i, val ) {        return !val;    });2.删除属性$(&quot;input[type=&apos;checkbox&apos;]&quot;).removeProp(&apos;disabled&apos;); // 删除禁用属性</code></pre></li><li><p>addClass的用法(类名) </p><pre><code>给元素添加类名属性, 添加多个接的加空格1.添加$(&apos;.sec&apos;).addClass(&apos;hello world&apos;); // 添加了2个类名// 传入回调函数$(&apos;ul li&apos;).addClass(function() {    return &apos;index&apos; + $(this).index();  // 给所有li添加index+自己下标的类名});console.log($(&apos;ul li.index3&apos;).index()); // 返回自己在父元素中的索引2.删除$(&apos;ul li&apos;).removeClass(); // 不传参删除所有,传参删除选定类名同样可以传入一个回调函数, return你处理后的结果3.切换toggleClass$(&apos;#btn&apos;).on(&apos;click&apos;, function () {    $(&apos;.sec&apos;).toggleClass(&apos;red&apos;);  // 点击一次按钮,便切换类名})&lt;!-- 还可以传入一个布尔参数 --&gt;var count = 1;$(&apos;#btn&apos;).on(&apos;click&apos;, function () {    console.log(count);    $(&apos;.sec&apos;).toggleClass(&apos;red&apos;, count++ % 5 == 0); // 点击5次li变红})</code></pre></li><li><p>html,text,val的用法</p><pre><code>这些都是获取标签元素文本内容和设置内容的方法...1.html()方法  对应原生js中的innerHTML方法var $ht = $(&apos;.sec&apos;).html(); // 不传参返回标签网页内容console.log($ht);设置内容: 传入一个标签,会添加到网页,但会覆盖之前的内容$(&apos;.sec&apos;).html(&quot;&lt;b&gt;hello jquery&lt;/b&gt;&quot;);也可以传入回调函数...2.text()方法  对应原生js中的innerText和textContentconsole.log($(&apos;.sec&apos;).text());  // 返回文本$(&apos;.sec&apos;).text(&apos;hello text&apos;)   // 设置文本,会把子元素全部覆盖掉$(&apos;.sec a&apos;).text(&apos;hello text&apos;)// 回调函数var a = &apos;hello&apos;$(&quot;.sec&quot;).text(function(n){    return &quot;这个 li 元素的 index 是：&quot; + n;}(a));3.val()方法  对应js 中的表单元素的value属性的值的操作console.log($(&apos;input&apos;).eq(1).val()); // 获取值// 传入参数就是设置值// 也可以传回调函数$(&apos;input:text.items&apos;).val(function() {    return this.value + &apos; &apos; + this.className;});</code></pre></li></ul><h2 id="jQuery操作文档节点"><a href="#jQuery操作文档节点" class="headerlink" title="jQuery操作文档节点"></a>jQuery操作文档节点</h2><p>jQuery也可以做创建,添加,删除文档节点的操作…</p><ul><li><p>创建节点</p><pre><code>var $p = $(&apos;&lt;p&gt;Hello&lt;/p&gt;&apos;); // $(传入一个html格式字符串), 此时内存中便创建了一个节点对象,js中使用createElement(&apos;标签名&apos;)$(&apos;body&apos;).append($p);</code></pre></li><li><p>节点的增删改</p><pre><code>1.增加A.append(B) === B.appendTo(A)    在被选元素的结尾插入内容prepend prependTo    在被选元素的开头插入内容before                在被选元素之后插入内容after                在被选元素之前插入内容insertAfter() // 把所有匹配的元素插入到另一个、指定的元素元素集合的后面。 注意: appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，返回值是所有被追加的内容，sh是前者!!!而不仅仅是先前所选中的元素。所以，要选择先前选中的元素，需要使用end()方法2.替换A.replaceWith(html字符串) // 将所有匹配的元素A替换成指定的HTML或DOM元素$(html字符串).replaceAll(jQuery对象) // 与上面反过来3.清空节点与删除节点$(&apos;div&apos;).empty(); // 清空div的所有内容（使用较多，会清除子元素上绑定的内容，源码）,但会自身保留$(&apos;div&apos;).html(&apos;&apos;);// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。$(&apos;div&apos;).remove(); // 相比于empty，自身也删除（自杀）4.克隆节点// 按钮克隆$(&apos;#btn&apos;).on(&apos;click&apos;, function(){    // 布尔值（true 或者 false）参数表示事件处理函数是否会被复制    $(this).clone(true).insertAfter(this);    // $(this).clone(true).before(this); 这个方法不行!!})</code></pre></li></ul><h2 id="jQuery操作CSS样式"><a href="#jQuery操作CSS样式" class="headerlink" title="jQuery操作CSS样式"></a>jQuery操作CSS样式</h2><p>通过css()方法jQuery对象可以获取,设置或者修改样式，操作的是style属性。</p><ul><li><p>css()方法</p><pre><code>1.获取样式$(&apos;div&apos;).css(&apos;background-color&apos;)  // 获取背景色2.设置或修改$(&apos;div&apos;).css({    &apos;background&apos;:&apos;gray&apos;,    &apos;width&apos;:&apos;400px&apos;,    &apos;height&apos;:&apos;200px&apos;});注意:    设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值    获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</code></pre></li><li><p>jQuery中元素的几个位置,尺寸方法</p><pre><code>1.width()方法和height()方法// 获取内容宽高.console.log($(&apos;div&apos;).width()); //200console.log($(&apos;div&apos;).height()); //200//设置内容宽高.$(&apos;div&apos;).width(300);$(&apos;div&apos;).height(300);2.innerWidth()和innerHeight();    获取内容宽高+paddingconsole.log($(&apos;div&apos;).innerWidth());console.log($(&apos;div&apos;).innerHeight());//设置还是会把padding计算进来,修改内容的宽高.$(&apos;div&apos;).innerWidth(300);$(&apos;div&apos;).innerHeight(300);3.outerWidth(); outerHeight();    获取内容宽高+padding+border;console.log($(&apos;div&apos;).outerWidth());console.log($(&apos;div&apos;).outerHeight());//设置还是会把 padding和 border计算进来,修改内容的宽高.$(&apos;div&apos;).outerWidth(300);$(&apos;div&apos;).outerHeight(300);4.outerWidth(true); outerHeight(true); 获取内容宽高+padding+border+margin;console.log($(&apos;div&apos;).outerWidth(true));console.log($(&apos;div&apos;).outerHeight(true));5.获取页面可视区的宽高获取可视区宽度 $(window).width();获取可视区高度 $(window).height();6.offset()方法与position()方法offset()方法获取元素距离document(即当前网页窗口)的位置，var $offset = $(&apos;#son&apos;).offset();console.log($offset); // 返回一个对象, {top:200,left:200};注意: 它是可以设置的,传入一个对象参数; 如果元素没有定位, 设置offset,那么就会自动给他一个relative定位.position方法获取的是元素距离有定位的父元素(offsetParent)的位置。var $position = $(&apos;#son&apos;).position();console.log($position); // 返回一个对象, {top:100,left:100};注意: position方法不能设置7.scrollTop与scrollLeft: 设置或者获取垂直滚动条的位置//获取页面被卷曲的高度, 常用于返回顶部, window的onscroll事件$(window).scrollTop();// 获取页面被卷曲的宽度$(window).scrollLeft();</code></pre></li></ul><h2 id="jQuery操作元素动画效果"><a href="#jQuery操作元素动画效果" class="headerlink" title="jQuery操作元素动画效果"></a>jQuery操作元素动画效果</h2><p>jQuery中封装了几个基本的自定义动画的功能。</p><ul><li><p>显示隐藏show/hide</p><pre><code>这个相当于操作 display属性hide和block, 并由高度和宽度的变化1.显示  show(参数1,参数3, 参数2); // 参数3是默认缓动, 可以传入&apos;linear&apos;就是匀速//参数1: 执行动画的时长  可以是毫秒数 也可以是代表时长的字符串  slow  fast  normal  如果字符串单词写错了相当于写了一个normal//参数2: 动画执行完毕后的回调函数.$(&apos;#div1&apos;).show(1000, function () {    alert(&apos;动画执行完毕了.&apos;);});2.隐藏 hide()  同上3.toggle()  切换显示隐藏效果</code></pre></li><li><p>slideDown()/slideUp()/slideToggle()</p><pre><code>这个动画相当于调整元素的高度height, 让元素有一个缓慢滑下和向上滑的效果,用法同上</code></pre></li><li><p>fadeIn()/fadeOut();fadeToggle()/fadeTo</p><pre><code>这组动画相当于调整元素的透明度, 0~1之间</code></pre></li><li><p>自定义动画animate</p><pre><code>$(selector).animate({params},[speed],[easing],[callback]);// {params}：要执行动画的CSS属性，带数字（必选）, 属性书写为驼峰// speed：执行动画时长（可选）// easing:执行效果，默认为swing（缓动）  可以是linear（匀速）// callback：动画执行完后立即执行的回调函数（可选）$(&quot;#go&quot;).click(function(){    $(&quot;#block&quot;).animate({         width: &quot;90%&quot;,        height: &quot;100%&quot;,         fontSize: &quot;10em&quot;,         borderWidth: 10    }, 1000 );});</code></pre></li><li><p>动画队列,停止stop,延迟delay</p><pre><code>当给一个元素加动画时,我们多次触发动画效果,它会执行完所有的动画才会停止,而我们有时候需要停止动画stop([clearQueue],[jumpToEnd])方法clearQueue:如果设置成true，则清空队列。可以立即结束动画。jumpToEnd:如果设置成true，则完成队列。可以立即完成动画,跳转到最终值常用stop(true, false)来实现一些之前结束之前的动画,进行下一个动画的场景delay(时间)设置一个延时来推迟执行队列中之后的项目。$(&apos;#foo&apos;).slideUp(300).delay(800).fadeIn(400); // 在.slideUp() 和 .fadeIn()之间延时800毫秒</code></pre></li></ul><h2 id="jQuery事件操作"><a href="#jQuery事件操作" class="headerlink" title="jQuery事件操作"></a>jQuery事件操作</h2><p>这里主要讲一下事件注册,触发,解绑以及事件对象…</p><ul><li><p>on注册事件</p><pre><code>1. on注册简单事件// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on(&apos;click&apos;, function() {    alert(&apos;hello world);}); 2. on注册事件委托// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on(&apos;click&apos;,&apos;span&apos;, function() {    alert(&apos;span的父元素下的后来创建的span元素都有可以触发这个函数&apos;);})</code></pre></li><li><p>解绑事件 off(事件名)</p><pre><code>$(&apos;#btn2&apos;).on(&apos;click&apos;, function () {//给div解绑事件//$(&apos;div&apos;).off();//解绑所有的事件.     $(&apos;div&apos;).off(&apos;click&apos;);//解绑指定的事件.});</code></pre></li><li><p>触发事件trigger</p><pre><code>当事件满足某一条件或者有时候需要去出发定义自定义事件,可以使用.trigger(事件名)//2.点击按钮,满足条件触发div的单击事件.var i = 0;$(&apos;#btn1&apos;).on(&apos;click&apos;, function () {i++;//当i等于3的时候,要调用一下div的单击事件.if(i == 3){    //a.调用div的click事件.    //$(&apos;#one&apos;).click();    //b.使用触发器.    $(&apos;#one&apos;).trigger(&apos;click&apos;); //条件触发}});</code></pre></li><li><p>jQuery事件对象</p><pre><code>jQuery 事件对象是对原生js事件对象的一个封装，并做了兼容性的处理$(&apos;#one&apos;).on(&apos;click&apos;, function (e) {    console.log(e); // e就是事件对象    //三个常用的坐标. 和原生js中的一样.    console.log(e.screenX + &quot;-&quot; + e.screenY); //屏幕左上角 距离触发事件的那一点的距离    console.log(e.clientX + &quot;-&quot; + e.clientY); //页面可视区左上角距离触发事件的那一点之间的距离.    console.log(e.pageX + &quot;-&quot; + e.pageY);//页面左上角 距离触发事件那一点之间的距离.}还有几个常用的属性    event.keyCode    按下的键盘代码    event.data    存储绑定事件时传递的附加数      event.stopPropagation()    阻止事件冒泡行为    event.preventDefault()    阻止浏览器默认行为, 如跳转    return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</code></pre></li></ul><h2 id="jQuery注意事项"><a href="#jQuery注意事项" class="headerlink" title="jQuery注意事项"></a>jQuery注意事项</h2><ul><li><p>链式编程中end()方法的使用</p><pre><code>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</code></pre></li><li><p>显示迭代方法,如each,reduce,filter等等,</p><pre><code>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。举个例子:    $(function () {        //找到所有的li标签,分别设置透明度,透明度是递增到1.        var $lis = $(&apos;#ulList&gt;li&apos;);        //jQuery中的each()方法        $lis.each(function (index,ele) {            //console.log(index);//索引,下标            //console.log(ele);//遍历出来的对象,是dom对象.            //ele.style.opacity = (index+1)/10; //dom对象调用dom属性或者方法        $(ele).css(&apos;opacity&apos;,(index+1)/10); //jQuery对象调用jQuery属性或者方法        });    });</code></pre></li><li><p>多库共存</p><pre><code>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.当我需要引入多个jQuery文件时, 就需要规避变量名$冲突的影响1. 比如:如果要做浏览器兼容处理就要引入1.x版本, 那如果要使用最近更新的新方法,就要使用3.x版本的.现在引入2个jQuery文件, 那如何调用者两个文件中的方法呢?var _$ = $.noConflict(); //把$的控制权给释放了. 这个方法有返回值,返回值可以看成是释放$的替代.console.log($.fn.jquery); //1.12.4  // 可以使用3.0.0上面的1.12.4版,不会被覆盖console.log(jQuery.fn.jquery); //3.0.0console.log(_$.fn.jquery);//3.0.0(function ($) {//我们可以把代码放入一个自调用函数中,这里就可以继续使用$代替_$来工作了!!!    console.log($.fn.jquery);//3.0.0}(_$));2. 如果引入了3个包含$的文件, 依次释放即可    var _$30 = $.noConflict();    var _$10 = $.noConflict    console.log(_$30.fn.jquery);    console.log(_$10.fn.jquery);    console.log($);</code></pre></li><li><p>jQuery插件添加</p><pre><code>1. 静态方法,直接在jQuery($)对象身上加    直接给$添加方法. 静态方法    (function ($) {             $.add = function (a, b) {            return a + b;        }    }(jQuery));    console.log($.add(10, 20)); // 302. 实例方法, 则是给jQuery的原型添加方法    (function($) {        $.fn.method = function(参数1,参数2...){            函数体: 要实现的功能;        }      }(window.jQuery))调用的话, 直接调用并传入对应的参数就可以了.....</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇内容是对jQuery和原生JS进行了对比和归纳,主要是总结一些jQuery的常用知识点…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>css中一些常用技巧的总结</title>
    <link href="http://yoursite.com/2018/12/02/css%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/02/css技巧总结/</id>
    <published>2018-12-02T02:53:33.000Z</published>
    <updated>2019-01-18T00:59:00.061Z</updated>
    
    <content type="html"><![CDATA[<p>关于平时个人用到的一些css常用技巧的记录,持续更新ing….<br><a id="more"></a></p><h1 id="css常用技巧总结"><a href="#css常用技巧总结" class="headerlink" title="css常用技巧总结"></a>css常用技巧总结</h1><h2 id="伪类元素实现标题两侧中间加横线"><a href="#伪类元素实现标题两侧中间加横线" class="headerlink" title="伪类元素实现标题两侧中间加横线"></a>伪类元素实现标题两侧中间加横线</h2><pre><code>h3 {    /* margin: 0 auto; */    font-size: 40px;    position: relative;}.line::before,.line::after {    position: absolute;    content: &quot;&quot;;    top: 50%;    background-color: red;    width: 10%; // 父盒子的宽度    /* width: 10px; */    height: 10px;}.line::before {    left: 40%;}.line::after {    right: 40%;}&lt;!-- 百分比的数值都是基于父盒子的基础上变化的 --&gt;</code></pre><h2 id="CSS实现单行、多行文本溢出显示省略号…"><a href="#CSS实现单行、多行文本溢出显示省略号…" class="headerlink" title="CSS实现单行、多行文本溢出显示省略号…"></a>CSS实现单行、多行文本溢出显示省略号…</h2><pre><code>单行:    overflow: hidden;    text-overflow:ellipsis;    white-space: nowrap;多行:    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 3;  // 行数</code></pre><h2 id="无依赖定位"><a href="#无依赖定位" class="headerlink" title="无依赖定位"></a>无依赖定位</h2><pre><code>给一个元素设置绝对定位时，定位的元素仍会保持在html结构位置，不占据空间;其实就是脱离了标准流,层级变高了;然后可以使用margin相对于自身原始位置定位该元素以实现各种功能.还可以使用relative相对于自己原始位置进行定位.logo {        position: absolute;         width: 20px;        height: 20px;        background: url(../image/.png);        margin: 10px 0 0 10px; // 两个方向来调控位置    }</code></pre><h2 id="伪元素实现在元素内设置部分样式"><a href="#伪元素实现在元素内设置部分样式" class="headerlink" title="伪元素实现在元素内设置部分样式"></a>伪元素实现在元素内设置部分样式</h2><pre><code>.logo::after {  content: &apos;&apos;;  &lt;!-- 居中 --&gt;  position: absolute;  left: 50%;  top: 50%;  transform: translate3d(-50%, -50%, 0);  width: 10px;  height: 10px;  border-radius: 50%;  box-shadow: 0 0 0 3px rgba(255, 0, 0, .5);  background-color: #f00;}</code></pre><h2 id="not-选择器使用"><a href="#not-选择器使用" class="headerlink" title=":not()选择器使用"></a>:not()选择器使用</h2><pre><code>nav li:not(:last-child) {    /* 更语义化一点, 最后一个li标签没有右边框作为分隔符 */    border-right: 1px solid #666;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于平时个人用到的一些css常用技巧的记录,持续更新ing….&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css常用技巧" scheme="http://yoursite.com/tags/css%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>js中对this的使用和理解</title>
    <link href="http://yoursite.com/2018/11/29/js%E4%B8%ADthis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/29/js中this的使用/</id>
    <published>2018-11-29T02:53:33.000Z</published>
    <updated>2018-11-29T13:00:23.827Z</updated>
    
    <content type="html"><![CDATA[<p>之前虽然知道this的指向是指向调用它的对象,要找this的指向,就看它所在的活动环境在哪里;但是在实际的应用中还是有i点模糊,这里做一个集中总结…<br><a id="more"></a></p><h1 id="探究this的本质"><a href="#探究this的本质" class="headerlink" title="探究this的本质"></a>探究this的本质</h1><p><strong>js中this的设计,跟内存中数据的存储有很大关系</strong></p><p>下面举两个例子:</p><pre><code>var obj = { foo:  5 };上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存堆里，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。{    foo: {        [[value]]: 5        [[writable]]: true        [[enumerable]]: true        [[configurable]]: true    }}此时，foo属性的值保存在属性描述对象的value属性里面。那么当foo的属性对应的值是一个函数时呢?var obj = { foo: function () {} };这时，引擎会开辟一块内存空间,将函数单独保存在里面，然后再将函数的地址赋值给foo属性的value属性。{    foo: {        [[value]]: 函数的地址        ...    }}由于此时函数是一个单独的值，所以它可以在不同的环境（上下文）执行。如下面的这个例子:var f = function () {};var obj = { f: f };f(); // 全局环境下执行, 相当于window.f()obj.f(); // obj 环境执行由于JavaScript允许在函数体内部，引用当前环境的其他变量。var f = function () {    console.log(x);  // 函数体里面使用了变量x。该变量由运行环境提供.};现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境....var f = function () {    console.log(this.x); // 函数体里面的this.x就是指当前运行环境的x}**看下面的示例会加深一下理解:**var f = function () {    console.log(this.x);}var x = 1;var obj = {    f: f,    x: 2,};// 全局下执行, window环境f() // 1// obj 环境执行obj.f() // 2</code></pre><h1 id="常见的使用场景"><a href="#常见的使用场景" class="headerlink" title="常见的使用场景"></a>常见的使用场景</h1><ul><li><p>全局环境</p><pre><code>全局环境使用this，它指的就是顶层对象windowfunction f() {    console.log(this === window);}f() // true; 此处其实相当于window.f(),只是省略了window</code></pre></li><li><p>构造函数</p><pre><code>构造函数中的this，指的是实例对象function Person(name) {    this.name = name;}var p = new Person(&apos;huhua&apos;); 每一个实例化出来的对象都会有一个name属性    console.log(p.name) // huhua</code></pre></li><li><p>对象的方法</p><pre><code>1.如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。// 不过这里有些地方理解起来会有点难,主要是搞清楚调用的方法是通过什么方式获取的下面举个例子:    var obj ={        foo: function () {        console.log(this);        }    };    obj.foo() // 我们都知道此时this指向的是obj 但是,我这里再做一下变化,this的指向也会发生变化    (obj.foo = obj.foo)() // this指向的是window    上面的代码相当于: (function () {                console.log(this);            })() // 相当于匿名函数的调用上面的代码可以这样理解: 在JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二;obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是上面这种情况是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境window。2.如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。举个栗子:    var a = {        p: &apos;Hello&apos;,        b: {            m: function() {                console.log(this.p);            }        }    };    a.b.m(); // undefined, 此时this指向的是a.b,不是a,所以不能调用对象a中的属性    // 所以只能把属性p放在b属性中    var a = {        b: {            m: function() {                console.log(this.p);            },            p: &apos;Hello&apos;,        }    };    var hello = a.b;    hello.m() // Hello</code></pre></li></ul><h1 id="this在使用时注意点"><a href="#this在使用时注意点" class="headerlink" title="this在使用时注意点"></a>this在使用时注意点</h1><ul><li><p>避免this的多层使用</p><pre><code>由于this的指向时动态变化的,所以在函数中要避免多层使用this指向,很容易搞混淆var obj = {    f1: function () {        console.log(this); // obj环境        var f2 = function () {            console.log(this); // 全局环境下执行, 匿名函数,指向window        }();    }}obj.f1(); // obj // window为了解决上面的问题,我们可以在外层声明一个变量来存储this的指向...var obj = {    f1: function () {        console.log(this); // obj环境        var that = this;   // 在外层声明一个变量指向this        var f2 = function () {            console.log(that);  // 内层引用外层变量that,也可以保存this的指向        }();    }}obj.f1();</code></pre></li><li><p>避免回调函数中使用this</p><pre><code>回调函数中的this往往会改变指向，最好避免使用。</code></pre></li></ul><h1 id="this的绑定方法"><a href="#this的绑定方法" class="headerlink" title="this的绑定方法"></a>this的绑定方法</h1><p>JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p><ul><li><p>call()</p><pre><code>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 func.call(对象, 参数1, 参数2...) // 适用于传入一个参数或者没有参数var n = 100;var obj = { n: 1 };function func() {    console.log(this.n);}func.call() // 100func.call(null) // 100func.call(undefined) // 100func.call(window) // 100func.call(obj) // 1func函数中的this关键字，如果指向全局对象，返回结果为100。如果使用call方法将this关键字指向obj对象，返回结果为1。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象还比如调用对象原型中的方法:    // 1.伪数组的排序(元素,下标, 长度),    var fake = {        // 指定如下属性,从0开始,长度length属性        0: 100,        1: 10,        2: 1,        3: 102,        4: 12,        5: 1220,        length: 6    }    Array.prototype.sort.call(fake, function(a, b){return a-b;}); // 直接在原数据上修改    console.log(fake); // [1,10,12,100,102,1220]</code></pre></li><li><p>apply()</p><pre><code>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...]) // 可以接受一个参数集合应用:找出数组最大值:    var a = [10, 2, 4, 15, 9];    var res = Math.max.apply(null, a);     console.log(res); // 15转化伪数组:    var fake = {        0: &apos;java&apos;,        1: &apos;javascript&apos;,        2: &apos;css&apos;,        3: &apos;html&apos;,        length: 4,    }        // 1.通过apply的传参特点    var arr = [];    arr.push.apply(arr,fake); // 直接在原数组上修改    console.log(arr); // [&apos;java&apos;,&apos;javascript&apos;,&apos;css&apos;,&apos;html&apos;]    var arr1 = [];    arr1 = arr1.concat.apply(arr1, fake); // 返回一个新数组,需要用变量接受    console.log(arr1);  // [&apos;java&apos;,&apos;javascript&apos;,&apos;css&apos;,&apos;html&apos;]还可以用来绑定回调函数...</code></pre></li><li><p>bind()</p><pre><code>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。举个栗子: 注释的请忽略    var counter = {    count: 0,    inc: function () {            // var count = 100;            this.count++;            // console.log(this.count);  // 这里打印undefined; 因为函数是在全局中调用,无法访问函数内的count        }    };    // var func = counter.inc;    var func = counter.inc.bind(counter);    func();    console.log(counter.count);  // 这里打印1,因为修改了this指向对象counter,可以访问内部属性</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前虽然知道this的指向是指向调用它的对象,要找this的指向,就看它所在的活动环境在哪里;但是在实际的应用中还是有i点模糊,这里做一个集中总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>js中闭包的理解</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/js中闭包的理解/</id>
    <published>2018-11-28T02:53:33.000Z</published>
    <updated>2018-11-27T11:45:29.484Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要深入去理解JS中的闭包…<br><a id="more"></a>  </p><h1 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么?"></a>闭包是什么?</h1><p>闭包的定义很简单：就是函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，此时函数 B 就被称为闭包。</p><pre><code>function A() {    var a = 1    function B() {        console.log(a)    }    return B;}var b = A();b()  // 此时函数外部可以访问函数内部的变量</code></pre><blockquote><p>闭包的本质就是一个函数,可以沟通函数内部和函数外部…</p></blockquote><h1 id="闭包示例"><a href="#闭包示例" class="headerlink" title="闭包示例"></a>闭包示例</h1><pre><code>示例1: function outer() {        var a = 1;        function inner() {            a++;            return a;        };        return inner;    };var res = outer()(); var res1 = outer()();var res2 = outer()();console.log(res,res1,res2); // 2, 2, 2; 三次调用都是不同的函数,每一次访问的都是内部重新声明的变量console.log(outer()); // 函数innervar func = outer();console.log(func(), func(), func()); // 2, 3, 4; 同一个函数访问了三次这个变量示例2:for (var i = 1;i&lt;=5;i++){    function outer () {        var num = i;        function closure () {            return num;        }        return closure;    }    console.log ( &apos;循环内&apos; + outer()());// 1,2,3,4,5}console.log (&apos;循环外&apos; +  outer()());// 6,</code></pre><h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><pre><code>// 1.延长变量的生命周期// 局部变量的生命周期：从执行函数开始，到函数执行完毕被回收    function outer() {        var a = 1;        function inner() {            console.log(a);        };        return inner;    };    var func = outer();    func(); // 1//闭包唯一弊端：会消耗内存资源//如何手动回收闭包内存：  变量名 = null;// 2. 设置权限// 定义一个匿名函数用person接受var person = function () {    //声明局部变量    var age = 38;    //使用闭包访问局部变量    function getAge () {        return age;    };    function setAge (value) {        if (value &gt; 0 &amp;&amp; value &lt;= 100){            age = value;        }    };    //返回一个对象，对象中存储2个闭包函数用于操作局部变量    return {        getAge:getAge,        setAge:setAge    }};var p1 = person();//得到闭包函数对象p1.setAge(-1);//修改无效p1.setAge(33);//修改有效console.log (p1.getAge());  // 33</code></pre><h1 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h1><pre><code>当我们需要创建独立的内存空间时，隔绝外部的环境,可以用到闭包(匿名函数自调用)    a.提供不同的作用域----可以避免全局变量污染    b.模块化的开发----不同的功能对应不同的作用域// 闭包实现斐波那契数列// 从定义出发, 一个函数嵌套另一个函数,内层函数访问外层函数的变量并返回自己    function outer() {        // 在外面定义一个数组用来存储        var arr = [1,1,0];        // 创建闭包函数        function inner(num) {            // num 表示斐波那契数列第几位数            if (num == 1 || num == 2){                return 1;            }            else {                for(var i = 2; i &lt; num; i++) {                    // 让数组第三位来存储斐波那契的计算位                    arr[2] = arr[1] + arr[0];                    // 将数组数据前推一位,让第三位来存储下一个计算位                    arr[0] = arr[1];                    arr[1] = arr[2];                };                return arr[2];            }        };         return inner;    };    console.log(outer()(10));  // 55    // 等价于上面    var func = outer();    console.log(func(10)); // 55</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要深入去理解JS中的闭包…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>js基础思维导图</title>
    <link href="http://yoursite.com/2018/11/27/js%E5%9F%BA%E7%A1%80%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/11/27/js基础思维导图/</id>
    <published>2018-11-27T02:53:33.000Z</published>
    <updated>2018-12-20T00:42:12.999Z</updated>
    
    <content type="html"><![CDATA[<p>一篇关于js基础的思维导图,虽然自己页总结了,感觉这个更好一点,这里是引用别人的…<a href="https://segmentfault.com/a/1190000011151972" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011151972</a><br><a id="more"></a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="https://i.imgur.com/hI7IgLn.gif" alt=""></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="https://i.imgur.com/KX3T1mT.gif" alt=""></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><img src="https://i.imgur.com/KcsykKX.gif" alt=""></p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p><img src="https://i.imgur.com/zEuI9GS.gif" alt=""></p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p><img src="https://i.imgur.com/aU4x1QQ.gif" alt=""></p><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p><img src="https://i.imgur.com/ATXVDSY.gif" alt=""></p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p><img src="https://i.imgur.com/leuQYL9.gif" alt=""></p><h2 id="正则操作"><a href="#正则操作" class="headerlink" title="正则操作"></a>正则操作</h2><p><img src="https://i.imgur.com/Exfsb7K.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇关于js基础的思维导图,虽然自己页总结了,感觉这个更好一点,这里是引用别人的…&lt;a href=&quot;https://segmentfault.com/a/1190000011151972&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000011151972&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js中隐式转换</title>
    <link href="http://yoursite.com/2018/11/26/js%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/11/26/js中的隐式转换/</id>
    <published>2018-11-26T02:53:33.000Z</published>
    <updated>2018-11-26T06:17:55.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了js中数据类型的隐式转换…<br><a id="more"></a>  </p><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>当运算符两边数据类型不一样的时候，编译器会自动将数据类型转换成一致之后再计算. </p><p>有如下几种转换情况:  </p><pre><code>1.其他数据类型转number: 算术运算符（+ - * /  %） 自增自减  关系运算符（&gt; &gt;= &lt; &lt;= == === != !==）2.其他数据类型转string：字符串连接符 +3.其他数据类型转boolean：逻辑非 ！</code></pre><p>这里以比较运算符<strong>==</strong>为例, 介绍会发生隐式转换的情况:</p><pre><code>1. 全等运算符： ===//严格匹配：不会类型转换，必须要数据类型与值完全一致console.log ( &quot;1&quot; === 1 );//fase2.相等运算符： ==// 非严格匹配：会类型转换，但是有前提条件,一起有五种情况    //2.1 x和y都是null或undefined :    /*规则：没有隐式类型转换，无条件返回true*/    console.log ( null == undefined );//true    console.log ( null == null );//true    console.log ( undefined == undefined );//true    //2.2 x或y是NaN : NaN与任何数字都不等    /*规则：没有隐式类型转换，无条件返回false*/    console.log ( NaN == NaN );//false    //2.3 x和y都是string，boolean，number    /*规则：有隐式类型转换，会将不是number类型的数据转成number */    console.log ( 1 == true );//true    (1) 1 == Number(true)    console.log ( 1 == &quot;true&quot; );//false   (1) 1 == Number(&apos;true&apos;)    console.log ( 1 == ! &quot;true&quot; );//false  (1) 1 == !Boolean(&apos;true&apos;)  (2) 1 == !true  (3) 1 == false  (4)1 == Number(false)    console.log ( 0 == ! &quot;true&quot; );//true    另外:        console.log ( Number ( undefined ) );//NaN        console.log ( Number ( null ) );//0    //2.4 x或y是复杂数据类型 : 会先获取复杂数据类型的原始值之后再左比较    /*复杂数据类型的原始值： 先调用valueOf方法，然后调用toString方法            * valueOf:一般默认返回自身        数组的toString：默认会调用join方法拼接每个元素并且返回拼接后的字符串    */    console.log ( [].toString () );//空字符串    console.log ( {}.toString () );//[object Object]    console.log ( [ 1, 2, 3 ].valueOf().toString());//‘1，2，3’    console.log ( [ 1, 2, 3 ] == &quot;1,2,3&quot; );//  (1)[1,2,3].toString() == &apos;1,2,3&apos;  (2)&apos;1,2,3&apos; == &apos;1,2,3&apos;    console.log({} == &apos;[object Object]&apos;);//true    //2.5 x和y都是复杂数据类型 : 只比较地址，如果地址一致则返回true，否则返回false    var arr1 = [10,20,30];    var arr2 = [10,20,30];    var arr3 = arr1;//将arr1的地址拷贝给arr3    console.log ( arr1 == arr2 );//虽然arr1与arr2中的数据是一样，但是它们两个不同的地址    console.log ( arr3 == arr1 );//true  两者地址是一样    console.log ( [] == [] );//false    console.log ( {} == {} );//false</code></pre><p>几个隐式转换的实例:</p><pre><code>// e:x和y都是复杂数据类型，比较地址console.log ( [] ==  [] );//false// [] 与右边逻辑非表达式结果比较//(1) [] == !Boolean([])   (2) [] == !true  (3)[] == false  (4) [].toString() == false  (5)&apos;&apos; == false   (6)Number(&apos;0&apos;) == Number(false)console.log ( [] == ! [] );//trueconsole.log ( {} ==  {} );//false// {} 与右边逻辑非表达式结果比较//(1){} == !{} (2){} == !true  (3){} == false  (4){}.toString() == false  (5)&apos;[object Object]&apos; == false  (6)Number(&apos;[object Object]&apos;) == falseconsole.log ( {} == ! {} );//false// 八种情况转boolean得到false: 0 -0 NaN undefined null &apos;&apos; false document.all()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了js中数据类型的隐式转换…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="隐式转化" scheme="http://yoursite.com/tags/%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于js中原型的理解</title>
    <link href="http://yoursite.com/2018/11/24/js%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/24/js中原型的理解/</id>
    <published>2018-11-24T11:39:26.000Z</published>
    <updated>2018-11-29T05:09:59.490Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要是记录一下对js中对于原型的理解…<br><a id="more"></a></p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>原型涉及到构造函数, 原型对象, 实例化对象三者之间的关系…</p><hr><ul><li><p>构造函数</p><pre><code>function Person (name,age) {    //(1)创建一个空对象： {}    //(2)将this指向这个空对象 : this = {}    //(3)执行构造函数赋值代码（完成对象的赋值）    this.name = name;    this.age = age;    this.sayHi = function () {        console.log(this.name + &apos;hello world&apos;);    };    //(4)返回这个对象};var man = new Person(&apos;huahua&apos;,18); 1.何为构造函数?    构造函数：首先，它是函数，并且任何的函数都可以作为构造函数存在，它的本质是初始化对象。    构造函数都是和new关键词一起使用的。 new就是在创建对象，从声明开始一共做了4件事(如上)，构造函数就是在为初始化的对象添加属性和方法(成员)2.构造函数的特点：    a:构造函数的首字母必须大写，用来区分于普通函数    b:内部使用的this对象，来指向即将要生成的实例对象    c:使用New来生成实例对象</code></pre></li><li><p>实例对象</p><pre><code>1.上面的 man 就是通过Person这个构造函数实例化出来一个对象,我们称为 **实例化对象**;何为对象的实例化呢? 2.在我看来就是给一个空对象添加了一些属性和方法,使其具有了一些特征和行为...也就是上面new关键字干的事;跟面向对象中的一些概念比较类似...面向对象编程: 面向对象就是对现实中的事物进行抽象化...然后再给其设置特征属性和行为使之具体化; 面向对象就是对面向过程进行封装后的结果...3.实例对象中存在一个__proto__属性; 这个属性指向了构造函数的原型prototype...  注意: 实例对象访问成员的规则：先看自己有没有这个成员，如果有则访问，没有则访问原型的  </code></pre></li><li><p>原型对象</p><pre><code>上面已经聊过构造函数和实例化对象了,那么原型对象又是什么呢?    当我们在声明一个函数时, 系统会帮我们创建一个与该函数对应的属性prototype,我们称它为原型对象;    以上面的Person为例,这个prototype是该函数的一个属性,我们可以调用Person.prototype来修改其成员或者进行重写;    原型对象中有一个构造器指针constructor属性来指向对应的构造函数,他的作用是可以让实例对象知道自己是哪一个构造函数生成的;    如 man.constructor 即man.__proto__.constructor指向了 Person. </code></pre></li><li><p>下面用一张图来表示他们之间的关系…</p><p>  <img src="https://i.imgur.com/zltNIlG.jpg" alt=""></p><p>  原型对象中可以存储很多成员属性和方法,多个实例对象之间就能共享这些属性和方法; 类似实现了面向对象中 <strong>继承</strong> 的效果…</p><p>  <strong>面向对象的三大特性:</strong>  </p><pre><code>封装：将功能代码封装到对象中，只暴露外部接口(API),使用者无需关心内部实现继承：一个对象拥有另一个对象所有的成员变量(属性和方法)多态: 一个对象在不同情况下的多种状态; 一个对象经过不同操作后会有不同的行为....     (js从语法的角度上来说没有多态，因为js是基于对象的语言)js实现继承的方式:    1. 我们可以遍历父对象,将父对象的属性动态添加到子对象中 (适用于一个子对象的继承)        for (var key in father){            son[key]  = father[key];         };    2. 替换原型：将父对象作为子对象构造函数的原型(但是会丢失之前的原型对象的成员)         // 子对象用构造函数来实例化         function Son(name, age) {             this.name = name;             this,age = age;         }         Son.prototype.father = {             parent: &apos;laosong&apos;,             age: 47,         } // Son 原型对象中的成员         var son = new Son(&apos;xiaowang&apos;, 24)         var father = {             name: &apos;laowang&apos;,             age: 48,         }         Son.prototype = father; // 相当于Son的原型被重新赋值,替换了,laosong不在了    3. 综合上面两种情况: 将父对象的成员动态添加到子对象的原型中, 这样就不会丢失了        for (var key in father){            Son.prototype[key]  = father[key];         };        /**混合式继承封装        @param method:子对象的构造函数         @param father:要继承的父对象         */        function extendMehtd ( method,father ) {            for (var key in father){                method.prototype[key] = father[key];            }        };    4. 构造函数实现继承        // 通过更改this的指向来实现        function Person(name, age) {            this.name = name || &apos;hello&apos;;            this.age = age || 200;        };        function Stu(sex, name, age) {            this.sex = sex;            // 调用Person构造函数，修改Person中的this指向为当前Student这个构造函数中new创建的对象            // 继承Person中默认的初始化属性            Person.call(this, name, age);        };        var s = new Stu(&apos;male&apos;);        console.log(s); // age: 200,name: &quot;hello&quot;,sex: &quot;male&quot;</code></pre></li></ul><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><blockquote><p><strong>js中, 每一个实例对象都存在一个__proto__属性指向了自己的原型prototype; 但是原型本身也是一个对象,</strong><br><strong>也有自己的__proto__属性,指向自己的原型，以此类推就形成一个链式结构，称之为原型链…</strong></p><p>对象访问原型链中成员规则：<strong>就近原则</strong><br><strong>先看对象自己有没有，有则访问，没有则看原型有没有，有则访问，没有则看原型的原型有没有，以此类推…直到原型链的终点（null）;</strong><br>如果还没有 ：  <strong>如果是访问属性：则返回undefined   如果访问的是方法：则会报错   xxxx is not a function</strong></p></blockquote><ul><li><p>图解原型链</p><p>  以数组对象为例:</p><p>  <img src="https://i.imgur.com/R2wyeQf.png" alt=""></p></li><li><p>DOM中的原型链</p><p>  <img src="https://i.imgur.com/p9p92gl.png" alt=""></p></li></ul><h2 id="图解完整原型链"><a href="#图解完整原型链" class="headerlink" title="图解完整原型链"></a>图解完整原型链</h2><p><img src="https://i.imgur.com/xmwylPu.png" alt="JS中原型链完整图"></p><p>以上便是JS中完整的原型链图解了…</p><h2 id="关于对象的一些知识点补充"><a href="#关于对象的一些知识点补充" class="headerlink" title="关于对象的一些知识点补充"></a>关于对象的一些知识点补充</h2><pre><code>1.静态成员和实例成员    静态成员: 函数对象持有的成员(属性,方法)    实例成员: 构造函数实例化出来的对象持有的成员2.instanceof 关键字    语法: 对象 instanceof 构造函数    作用: 用来检测右边函数的原型 是否 在左边对象的原型链中(true/false)    如: Object instanceof Object // true3.Object.prototype(对象原型)    --所有对象的原型链中都会指向它;所以所有的对象都可以访问Object.prototype原型中的成员    常用几个成员:        1.hasOwnProperty(): 检查对象是否包含某个成员;            条件: 自己的成员        2.isPrototypeOf(): 检查(左边)一个对象是不是(右边)另一个对象的原型        3.propertyIsEnumerable(): 检查对象是否可以枚举某个属性            条件: （1）是自己的成员  （2）可以被for-in循环遍历 （自己的和原型的）    4.Function.prototype(函数对象Function的原型)    --所有的函数对象原型都会指向Function构造函数的原型,所有的函数对象都可以访问Function.prototype中的成员    常用的一些成员:        1. name:获取函数名 (比较鸡肋)        2.caller:获取调用本函数的引用;通过console.log(fn.caller)可以知道自己在哪个地方被人调用(全局调用函数,这里的caller指向null)        3.length：获取函数形参的数量; fun.length 可以知道函数设置的形参个数        4.arguments:获取函数所有的实参;             可以理解为函数内部一个隐藏的形参,作用是获取函数所有的实参，与形参一一对应...            arguments对象的两个常用属性:                1.callee:指向函数自身, 应用于匿名函数的递归调用...                  arguments.callee === fn //true                2. length: 实参的个数                  arguments是一个伪数组...        5.给内置的构造函数原型添加自定义成员            当内置构造函数自带的方法不够用，无法实现需求时,我们就需要给添加自定义方法;直接添加可能会出现多个人员操作出现相同的方法名,导致被覆盖掉了            所以需要采用安全的方法添加来避免覆盖...            使用替换原型继承(自定义构造函数，将原型指向内置对象)                // 通过构造函数的方式来添加;                function NewArr(name) {                    this.name = name;                };                NewArr.prototype = []; // 修改为一个空数组对象;此时NewArr的原型拥有数组对象所有的方法                NewArr.prototype.hello = {                    name: &apos;hello world&apos;,                };                NewArr.prototype.min = function () {                    var min = Infinity;                    for(var i=0; i&lt; this.length; i++) {                        if (this[i] &lt; min) {                            min = this[i];                        }                    };                    return min;                };                // 创建一个新对象                var arr1 = new NewArr(&apos;huhua&apos;);                var arr3 = new NewArr();                arr3.push(1,2,3,-1);                console.log(arr3.min());                console.log(arr1);                console.log(arr1.__proto__);                console.log(NewArr);                console.log(NewArr.prototype);                console.log(NewArr.__proto__.constructor);                var arr2 = [12,241,21];                console.log(arr2.min());  // 不能访问                Array.prototype：对象类型赋值的时候拷贝的是地址，修改了NewArr的原型之后，Array.prototype也会修改                []：  由于空数组的原型会指向Array.prototype，根据原型链中成员访问规则，NewArr实例对象可以访问数组成员的成员                      并且，修改MyArr的原型对象，本质上是修改这个空数组，不会对Array.protpotype造成影响</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要是记录一下对js中对于原型的理解…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>js程序设计读书笔记之BOM与DOM操作</title>
    <link href="http://yoursite.com/2018/11/20/js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BBOM%E4%B8%8EDOM%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/11/20/js读书笔记之BOM与DOM操作/</id>
    <published>2018-11-20T01:19:13.000Z</published>
    <updated>2018-11-26T05:33:49.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录js中一些BOM与DOM的操作方法…<br><a id="more"></a></p><h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><p>关于JS操作文档内容,可以总结为网页元素的增删改查</p><h2 id="网页节点操作"><a href="#网页节点操作" class="headerlink" title="网页节点操作"></a>网页节点操作</h2><ul><li>查</li></ul><hr><p>所谓的查找元素, 可以理解为从文档中获取元素…  </p><ul><li>常用的网页元素获取方式  </li></ul><p><img src="https://i.imgur.com/uogEo0u.png" alt=""></p><ul><li>获取元素文本/元素内容   </li></ul><p><img src="https://i.imgur.com/veJihts.png" alt=""></p><ul><li>DOM节点</li></ul><p><img src="https://i.imgur.com/w1kYkxg.png" alt=""></p><ul><li>节点和元素的获取</li></ul><p><img src="https://i.imgur.com/K1UYjDV.png" alt="">  </p><ul><li><p>属性的获取  </p><blockquote><p>1.点语法</p></blockquote><p>  1-1 获取行内标准属性(不能获取行外属性和自定义属性)<br>  1-2动态添加属性和修改其值   </p></li></ul><blockquote><p>2.attribute语法 (<strong>应用场景1:tab栏切换效果</strong>)  </p></blockquote><pre><code>获取属性方法: 元素.getAttribute(&apos;属性名&apos;)  设置属性方法: 元素.setAttribute(&apos;属性名&apos;, 属性值)  2-1 可以获取行内标准属性和行内自定义属性(**常用**), 不可以获取行外和点语法动态添加的属性...</code></pre><ul><li>增</li></ul><hr><p>增加元素: 要思考增加哪些元素? 新创建的元素, 已存在的, 带子元素的父元素(已存在的元素只是移动,原来的位置消失)</p><pre><code>// 创建元素: document.createElement(&apos;标签名&apos;) var p = document.createElement(&apos;p&apos;) //传入标签名p.innerText = &apos;hello world&apos;;   // 传入相应文本box.appendChild(p);   //添加到想加入的父元素, 尾部插入// 插入元素 insertBefore(new, 父元素的子元素节点) 插入到父元素 ul2.insertBefore(ul1, li7); //还可以通过innerHTML赋值的方式来设置元素的内容,这个方法可以解析标签//innerText是获取文本,也可以设置文本; 它不能解析标签...</code></pre><ul><li>改</li></ul><hr><p>修改, 即替换子元素  </p><pre><code>// 插入元素 replaceChild(new, 父元素的子元素节点) 插入到父元素   ul2.replaceChild(ul1, li7); </code></pre><ul><li>删</li></ul><hr><p>即删除父元素下的子元素</p><pre><code>/ 移除子元素 removeChild(子元素)    // 只能自己移除自己的子元素    ul2.removeChild(li7);</code></pre><ul><li>注意</li></ul><hr><p>以上的增,删,改都是基于父元素的基础上来做操作!!!   </p><p><strong>一般父元素都是一个伪数组,我们在操作其子元素时,特别时for循环遍历使用时,别忘了数组的长度是会动态变化的,所以要注意循环增量的处理; 像比较常见的删除,循环加入到另一个元素中等等…</strong></p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM定义了一套操作浏览器窗口的API</p><h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><p>Bom对象主要由五大对象组成：</p><pre><code>window:浏览器核心对象location：包含当前页面的URL信息history：history对象主要用于记录你当前窗口的历史记录navigator：包含当前浏览器的信息，例如用的什么浏览器，操作系统版本等screen：获取用户电脑的屏幕分辨率(这个一般不用)</code></pre><ul><li><p>window对象 </p><pre><code>指的是当前浏览器窗口，它是JS中的顶级对象(所有全局变量都是它的属性)他有一个特殊的属性name; 无论怎么赋值,都是一个字符串...  1.常用的方法    open():打开一个窗口 params:URL,默认_blank,特征大小,true/false, 返回值:新打开的window对象...    close(关闭对象):关闭一个窗口, window.open(&quot; &quot;,&quot;_self&quot;).close();防拦截2.window对象的三个事件    1.window.onload:界面上所有的内容加载完毕之后才触发这个事件    2.window.onbeforeunload:界面在关闭之前会触发这个事件//常用来存储重要的数据    3.window.onunload:界面在关闭的那一瞬间会触发这个事件</code></pre></li><li><p>location对象  </p><pre><code>包含当前页面的URL信息1.打开新网页：location.assign(&apos;你要打开的新网页的url&apos;)  2.替换当前网页：location.replace(&apos;要替换的网页url&apos;)  3.刷新当前网页: location.reload() //刷新</code></pre></li><li><p>history对象</p><pre><code>history对象主要用于记录你当前窗口的历史记录主要作用就是前进和后退网页（相当于浏览器的左上角前进后退按钮功能）history.forward():前进history.back():后退</code></pre></li><li><p>navigator对象</p><pre><code>navigator对象：包含当前浏览器的信息工作中应用场景：用户信息统计（统计我这个网站平台的用户群体分布，什么浏览器，windows什么版本等）//使用场景：判断用户当前使用哪种浏览器if(navigator.userAgent.indexOf(&apos;Chrome&apos;) != -1){console.log ( &quot;谷歌浏览器&quot; );}else if(navigator.userAgent.indexOf(&apos;Firefox&apos;) != -1){console.log ( &quot;火狐浏览器&quot; );}else{console.log ( &quot;IE浏览器&quot; );//也有可能是其他小众浏览器，可以忽略不计}</code></pre></li></ul><h1 id="动画部分"><a href="#动画部分" class="headerlink" title="动画部分"></a>动画部分</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul><li><p>setInterval</p><pre><code>1.一旦创建立即计时，必须要手动停止，否则会无限的每隔一段时间执行代码2.创建定时器：setInterval(函数,时间间隔)    1.返回这个定时器的id    2.时间间隔的单位是毫秒    3.每隔一段时间就会执行函数中的代码3.移除定时器：clearInterval(定时器id)4.常用案例      电商网页上的秒杀时间, 时钟, 电子表等...动画的实现也是依靠定时器来完成的...</code></pre></li><li><p>setTimeout(函数,时间间隔)  </p><pre><code>与setInterval唯一的区别就是这个定时器只会执行一次，之后会自动移除</code></pre></li></ul><h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><pre><code>1.结构上: 一个盒子包含着一个ul标签,嵌套多个浮动的li标签(每个里标签中放一张图片);还包括两个切换键, 多个页码显示键...2.实现思路: 基于需求出发, 盒子中只显示当前图片, 鼠标移入切换键显示;点击切换键会往左或往右切换图片,在实现以上手动轮播功能后加入定时器实现自动轮播...3.代码实现: 从交互事件出发, 分析需求实现的步骤...足以实现功能分析过程:    第一步:鼠标移入盒子,切换键显示,移出则消失:            父盒子.onmouseover/onmouseout    第二步:设置一个全局变量index来给每个图片添加编号,             给切换键绑定事件,点击下一张则编号+1,上一张则编号-1                next.onclick; 则index++                pre.onclick; 则index--        这里完成上下页切换时要注意几点:                因为ul是由若干个图片浮动成一行显示的;所以超出的部分给父盒子设置一个overflow:hidden来消除;                每次点击切换键时,ul会移动一张图片的宽度;每张图片都有编号,编号*图片宽度即为位移宽度;                盒子的宽度为真实宽度;**需要用offsetWidth来获取**; 位移方式我们用定时器来做;                最后,ul的移动还需要设置边界检测...注意第一页和最后一页的处理;                同时还要完成页码的高亮显示(排他思想实现...添加自定义属性值,然后与图片编号对比)    第三步:         手动无限轮播:             这里主要是处理第一张图片和最后一张:                下一页:手动设置ul的位置为第一张;重置index的值...                上一页:手动设置ul的位置为最后一张图片的位置;重置index的值为最后一张的索引...                同时,因为位置的变化时突变的;无法实现动画滑动的效果;这里需要做一个视觉欺骗的效果;                给ul最后再添加一张图片来实现滑动效果...    第四步:        实现点击页码跳转到对应的图片,点击后动画移动对应的位移:-index*图片宽度    第五步:        自动无限轮播实现:            相当于每隔一段时间,自动触发点击下一页的功能            这里可以将轮播部分代码封装成一个函数,放在定时器中,每隔一段时间执行此函数,鼠标移入停止轮播;            即清除定时器;移出后启动定时器...</code></pre><h2 id="缓动动画"><a href="#缓动动画" class="headerlink" title="缓动动画"></a>缓动动画</h2><p>缓动动画可以理解为元素某些属性的渐变效果,实现元素属性值非匀速的变化,使元素在视觉上给人一种缓慢变化的感觉</p><ul><li><p>缓动动画的核心思想</p><pre><code>1. 开启定时器2. 获取需要改变的属性值3. 每次的变化值(我习惯叫做 步长step) = (目标值 - 当前值)/10 //核心公式4. 判断变化方向(正/父)// 正:步长向上取整; 负:步长向下取整5. 改变元素的属性值(重新赋值) // 注意有些元素的单位  要做+ &apos;px&apos;处理6. 终点检测// 当然以上步骤只是一个大概的步骤, 下面再来补充...</code></pre></li><li><p>缓动动画注意点</p><pre><code>1.缓动动画要求我们动态地改变元素的属性值,要做到多个元素复用,必须要封装...2.函数参数处理:     2-1元素的属性和值用对象来储存    2-2属性值的获取: 使用window.getComputerStyle()来获取//需要做兼容IE8                    // 注意对象的点语法取值 和 字符串语法取值[&apos;str&apos;]    2-3属性分类处理: 如果定位层级zIndex,背景色这类瞬变的属性, 在遍历时进行判断后,直接赋值                   如果是透明度opacity这类0~1直接变化的属性, 需要单独进行放大缩小处理//parseFloat                   如果是宽高,垂直水平方向距离这类按一般步骤处理即可3.保证多个属性都达到目标值:    开关思想来实现; 在遍历参数加上一个开关,每次循环遍历一遍后进行判断,只要有一个属性没到目标值,就继续遍历,    直到所有属性都达到目标值4.回调函数callback    在动画结束后,我们可以在运行一个函数,来实现动画结束后的其他特效, 只需要往函数传入回调函数名即可    </code></pre></li><li><p>缓动动画示例代码</p></li></ul><pre><code>// 获取元素var box = document.getElementById(&apos;box&apos;);var btn = document.getElementById(&apos;btn&apos;);// btn绑定点击事件btn.onclick = function () {    // 同一盒子的不同属性用对象来存储    var ele_attrs = {        // 键值对: 键为元素的属性名, 值为移动的目标位置         top: 500,        left: 500,        width: 300,        height: 300,        zIndex: 2, //层级属性        opacity: 0.5, //透明度    };    // 回调函数的参数    var ele_attrs1 = {        backgroundColor: &apos;yellow&apos;,    }    // 这里传一个函数的引用即可    var callback1 = function() {        // alert(&apos;hello world&apos;);        animation_move(box, ele_attrs1)    }    animation_move(box, ele_attrs, callback1);};// 这里给动画函数再传一个函数参数: 用来执行此次动画结束后继续执行下一回调函数function animation_move(ele, attrs, callback) {    // 用定时器来完成缓动动画,先清除之前的定时器    clearInterval(ele.tid);    ele.tid = setInterval(function () {        // 定时器里用到的值都是attrs里面的, 我们要遍历传入的attrs对象        var flag = true;        for (var key in attrs) {            // 这里要对层级属性进行单独处理; 背景色也是..,            if (key == &apos;zIndex&apos; || key == &apos;backgroundColor&apos;) {                // 如果存在,则直接赋值...                ele.style[key] = attrs[key];            }             else if (key == &apos;opacity&apos;) {                // 透明度(0~1的小数)的数值要放大处理                var target = attrs[key]*100;                var cur = parseFloat(get_style(ele, key))*100;                 var step = (target - cur)/10;                step = cur &lt; target ? Math.ceil(step) : Math.floor(step);                cur += step;                // 赋值给对象,更新其属性值                ele.style[key] = cur/100;                if (cur != target) {                    flag = false;                }            }            else {               // 此时的目标位置相当于key对应的值, 我们取出来                var target = attrs[key]; // 对对象中的属性进行动画操作                var cur = parseInt(get_style(ele, key)); //带单位需转化                var step = (target - cur)/10;//存在小数                step = cur &lt; target ? Math.ceil(step) : Math.floor(step);                cur += step;                // 赋值给对象,更新其属性值                ele.style[key] = cur + &apos;px&apos;; //这里只能采用对象字符串的方法来赋值/取值                if (cur != target) {                    // 如果有一个元素没到达目标位置,让循环继续走, 直到每一个属性都走完                    flag = false;                }             }        };        if (flag) {            clearInterval(ele.tid);            // 这里要对函数进行判断            if (typeof callback == &apos;function&apos;) {                callback();            }        }    }, 50);};function get_style(ele, attr) {    //兼容性处理,能力检测,这里要使用window.getComputerStyle()    if (window.getComputedStyle) {        return window.getComputedStyle(ele, null)[attr];//对象的取值法    }else {        // IE8的方法        return ele.currentStyle[attr];    };};</code></pre><ul><li><p>旋转木马思路</p><pre><code>旋转木马实现: 将盒子中所有li元素的属性用数组存储,每次点击切换键,只需要交换li元素的属性, 然后动态的取改变每个li元素的属性值...主要代码:// 点击事件绑定arrRight.onclick = function () {    // 点击切换下一个li标签, 数组中的元素位置轮换,然后每个样式的属性都进行动态的变化    // 第一个样式放到最后一个位置    li_style.push(li_style.shift());    // 位置互换后,开始动态变化    for(var i=0; i&lt;ul1.children.length; i++) {        animation_move(ul1.children[i], li_style[i]);    };};arrLeft.onclick = function () {    // 点击切换下一个li标签, 数组中的元素位置轮换,然后每个样式的属性都进行动态的变化    // 最后一个样式放到第一个位置    li_style.unshift(li_style.pop());    // 位置互换后,开始动态变化    for(var i=0; i&lt;ul1.children.length; i++) {        animation_move(ul1.children[i], li_style[i]);    };};    </code></pre></li></ul><h2 id="元素的几个常用的坐标属性"><a href="#元素的几个常用的坐标属性" class="headerlink" title="元素的几个常用的坐标属性"></a>元素的几个常用的坐标属性</h2><p><strong>这里JS中各种宽高属性值的一些介绍</strong><br><a href="https://juejin.im/entry/582eb783d203090067037b70" title="JavaScript 中的各种宽高属性" target="_blank" rel="noopener">https://juejin.im/entry/582eb783d203090067037b70</a></p><ul><li><p>offset属性</p><pre><code>1.offsetWidth与offsetHeight：获取的是元素的实际宽高 = width + border + padding2.offsetParent:获取最近的定位父元素 （自己定位参照的父元素）3.offsetLeft:获取自己左外边框与offsetParent的左内边框的距离  offsetTop:获取自己上外边框与offsetParent的上内边框的距离</code></pre></li><li><p>scroll属性</p><pre><code>1.scrollWidth和scrollHeight：元素内容真实的宽高(包括padding)2.scrollLeft和scrollTop：元素在滚动时超出内容区域的部分3.滚动事件:onscroll:元素的滚动条事件一般来说,我们经常会对浏览器整个页面进行滚动操作window.onscroll...如固定导航或者搜索框; 这里要注意元素脱标后的影响, 需要给下面的盒子加margintop值页面获取的方式(存在兼容性):      谷歌/火狐 ： window.pageXOffset （左） window. pageYOffset（上）    IE浏览器： document.documentElement.scrollLeft/Top    某些情况下:document.body.scrollLeft/Top代码:    function getPageScroll(){        return {        scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0,        scrollLeft :  window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0        };    }</code></pre></li><li><p>client属性</p><pre><code>clientWidth/clientHeight：获取可视区域的宽高(可视内容+padding)clientTop/clientLeft:不常用，其实就是左边框border-left和上边框border-top属性的获取:    getClientSize = function (  ) {        return {        clientWidth : window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,        clientHeight : window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0,        }    }监听浏览器窗口变化的事件: window.onresize()//常用于判断终端设备界面大小, 响应式布局中常用到</code></pre></li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><img src="https://i.imgur.com/C2vXX6l.png" alt="">  </p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件对象event:当某一个事件被触发时,此时浏览器会记录触发时的某些信息， 例如你是在哪个位置点击的,浏览器把这些所有的信息放到一个变量中存储，这个变量的数据类型是对象，所以称之为事件对象.</p><ul><li><p>获取事件对象</p><pre><code>document.getElementById(&apos;box&apos;).onclick = function ( e ) {//IE8及之前用window.event获取，可以用逻辑或的短路运算解决浏览器兼容性问题e = e || window.event;console.log (e);}</code></pre></li><li><p>事件对象中的三大坐标</p><pre><code>//事件对象里面的常用的三个坐标var box = document.getElementById(&quot;box&quot;);box.onclick = function (e) {e = e || window.event;//电脑屏幕的左上角console.log(&quot;e.screenX:&quot;+e.screenX+&quot;---e.screenY:&quot;+ e.screenY);//浏览器可视区域console.log(&quot;e.clientX:&quot;+e.clientX+&quot;---e.clientY:&quot;+ e.clientY);//页面的原点位置//浏览器兼容问题：IE8及之前不支持console.log(&quot;e.pageX:&quot;+e.pageX+&quot;---e.pageY:&quot;+ e.pageY);console.log ( getPagePoint ( e ).pageX, getPagePoint (e).pageY );}//pageX和pageY的兼容//pageX/Y坐标系相对于页面左上角，实际上就是界面滚定出去的距离 + 可视区域的距离function getPagePoint ( e ) {    e = e || window.event;//事件对象兼容    return {    pageX : e.pageX || getScroll().scrollLeft + e.clientX,    pageY : e.pageY || getScroll().scrollTop + e.clientY,    }}</code></pre></li><li><p>盒子拖拽注意点<br>以事件对象的pagex为基础出发,找到盒子移动的left和鼠标点击位置之间的关系…<br>另外,这是针对定位元素<br><img src="https://i.imgur.com/k305E5z.jpg" alt="">        </p></li></ul><p>另外,如果盒子带外边距,定位的元素会将外边距也算进去,所以在最后计算定位的left和top时,若要让鼠标的位置在内容区,需要减去margin值…<br>还有就是鼠标松开事件,要清除文档的鼠标移动事件…</p><ul><li><p>获取事件触发点相对于元素的位置</p><pre><code>在控制元素的某些移动效果时,针对定位的元素,我们一般都是去修改其定位的属性值;  如left,top来实现元素位置的动态变化,那么常用的几个坐标值会经常用到;    1.事件对象的坐标:        pageX, pageY 触发点相对页面的原点的值        clientX,clientY 触发点相对于浏览器可视区域的点的值    2.元素自身的一些属性值        三大属性值: offset,  scroll , client        两个方向: box.style.left, box.style.top //带单位的,以上都是不带单位的,所以最后赋值时要加px...</code></pre></li><li><p>事件冒泡</p><pre><code>1.事件冒泡：如果一个元素的事件被触发，该元素所有的父元素的同名事件会被依次触发冒泡的顺序: 元素 -&gt; 父元素 -&gt;body -&gt;html -&gt; document -&gt;window -&gt; null2.冒泡的优点:    应用场景: 当一个父元素的所有子元素(如ul&gt;li*5)都要注册同名事件时,只需要给父元素注册即可...    这里可以使用事件的一个属性来完成        **注意前提时获取事件对象e**         e.target : 事件触发源  (真正触发父元素事件的那个子元素) // IE8: e.srcElement            e.currentTarget : 与this一样的，不同点：currentTarget有浏览器兼容性，this没有         this:谁调用这个方法this代表谁3.冒泡的缺点    可能导致子元素与父元素出现事件冲突,影响需求;     如何规避:        // 注意先获取事件对象e        阻止事件冒泡:在子元素触发事件后,调用事件对象的e.stopPrapagation()方法...4.注册/删除多个同名事件    // 注册    addEventListener(&apos;事件类型&apos;,函数名, false/true)    // 事件类型不需要加on, 第三个参数默认为false:冒泡方式;true:事件捕捉    // 删除        removeEventListener(type, 函数名)** 这两个方法需要做兼容性处理&apos;&apos;&apos;/** @description 元素多个同名事件监听    * @param ele事件对象,即元素    * @param type,事件类型 (str)    * @param func,事件处理函数    * @return func的结果*/   function addEvent(ele, type, func) {    // 能力检测    if (ele.addEventListener) {    //执行函数    ele.addEventListener(type, func);        }    else if (ele.attachEvent) {    // IE8, 方法需要加on    ele.attachEvent(&apos;on&apos;+type, func);    }    else {    // 其他    ele[&apos;on&apos;+type] = func;    }};/** @description 元素多个同名事件移除    * @param ele事件对象,即元素    * @param type,事件类型    * @param func,事件处理函数    * @return func的结果    */function removeEvent(ele, type, func) {       // 能力检测    if (ele.removeEventListener) {    //执行函数    ele.addEventListener(type, func);    }    else if (ele.detachEvent) {    // IE8, 方法需要加on    ele.detachEvent(&apos;on&apos;+type, func);        }    else {    // 其他    ele[&apos;on&apos;+type] = null;    }};    </code></pre></li><li><p>事件捕捉</p><pre><code>1.事件捕获：如果一个元素的事件被触发，先从最顶级元素往下依次触发，直到目标元素window-&gt;document-&gt;html-&gt;body-&gt;父元素-&gt;元素2.只有一种方式注册事件才是捕获：addEventListener方式注册并且第三个参数为true3.1.事件三个阶段    1：捕获阶段    2：目标阶段    3：冒泡阶段 3.2.获取事件的阶段：  e.eventPhase3.3事件类型: e.type</code></pre></li><li><p>键盘事件</p><pre><code>1.键盘事件    键盘按下： onkeydown    键盘松开：onkeyup    键盘按下：onkeypress  2.获取键盘按键    e.keyCode  || e.char Code  ||  e.which    注意: 默认获取的是ASCII码 ： 键盘上每一个按键对应一个数字，这个数字就是ASCII码    另外:ASCII码转字符串:  String.fromCharCode ( ascii码 )  3.onkeydown和onkeypress（常用）的区别    onkeydown: (1)不区分大小写，大写   （2）不过滤特殊按键 （f1-f12 ctrk）    onkeypress: （1）区分大小写    2）过滤特殊按键4.如果是对本次操作进行取值 / 或者是循环注册多个事件; 一定要注意**this关键字**的使用!!!!!!!!</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录js中一些BOM与DOM的操作方法…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="BOM和DOM" scheme="http://yoursite.com/tags/BOM%E5%92%8CDOM/"/>
    
  </entry>
  
</feed>
