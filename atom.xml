<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AppleGuard的博客</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-18T12:43:21.127Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>huhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用布局方式</title>
    <link href="http://yoursite.com/2018/12/17/%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/12/17/页面常用的布局方式/</id>
    <published>2018-12-17T02:53:33.000Z</published>
    <updated>2018-12-18T12:43:21.127Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中经常遇到布局的问题，下面我总结几种常用的css布局方案,直接用代码展示<br><a id="more"></a></p><h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><ul><li><p>水平居中</p><pre><code>/* 以不定宽为例 *//* 1: 父盒子text-aligin + 子盒子inline-block */.father {    text-align: center;}.son {    /* 此时宽高为内容撑起 */    display: inline-block;}/* 2: 子盒子 table+margin */.son {    display: table;    margin: 0 auto;}/* 3: 子盒子: absolute,left + transform *//* 当子元素定宽时, 则采用 负margin来实现 */.father {    position: relative;}.son {    position: absolute;    left: 50%;    transform: translateX(-50%);}</code></pre></li><li><p>垂直居中</p><pre><code>/* 1. 父元素: table-cell + vertical-align */.father {    display: table-cell;    /* 会继承父元素的宽度 */    vertical-align: middle; }/* 2. absolute + transform *//* 定宽使用负margin */.father {        position: relative;}.son {        position: absolute;                   top: 50%;        transform: translateY(-50%);}/* 3.flex + align-items */.father {    display: flex;    align-items: center;}</code></pre></li><li><p>水平垂直居中</p><pre><code>/* 1.父:table-cell + text-align + vertical-align  子:inline-block*/.father {    /* display: table-cell; 拥有行内块的属性 */    /* text-align: center; */    /* vertical-align: middle; */}.son {    /* display: inline-block; 内容撑开 */}/* 2. 子:absolute + transform */.son {    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);}/* 3.定宽子元素可以采用absolute + 负 margin *//* 4.还有absolute  ltrb:0 + margin: auto */</code></pre></li></ul><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><ul><li><p>一列定宽,另一列自适应</p><pre><code>/* 1. float + margin */.left {    width: 300px;    float: left;    background: red;}.right {    /* 50px的间距 */    margin-left: 350px;     background: green;}/* 2. float + overflow */.right {    overflow: hidden; }</code></pre></li><li><p>多列定宽，一列自适应</p><pre><code>/* 1.浮动加overfloat; float + overflow: hidden */.parent {    background: #ccc;}.box1,.box2 {    float: left;    width: 200px;    margin-right: 20px;}.auto {    overflow: hidden;}/* 2. flex方式实现 */.parent {    display: flex;}.box1,.box2 {    width: 200px;    padding-right: 20px;}.auto {    flex: 1;}</code></pre></li><li><p>等分布局</p><pre><code>.parent {    height: 300px;    /* margin-left: -10px; */}.box {    float: left;    /* 等分父盒子宽度 */    width: 25%;    height: 100%;    padding-left: 10px;    /* 子元素盒子尺寸:为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 */    box-sizing: border-box;    border: 1px solid red;}</code></pre></li><li><p>等高布局</p><pre><code>1. 浮动 + overflow实现.parent {    overflow: hidden;}.left {    float: left;    width: 300px;    background: #ccc;}.right {    overflow: hidden;    background: #0f0;}</code></pre></li><li><p>三栏式圣杯布局</p><pre><code>将中间的模块放在dom树前面，可以实现浏览器在做重绘的时候有限显示**圣杯布局的主要内容是放在 中间main这个盒子中**/* 圣杯布局: 浮动 + 相对定位 + padding */.container {    width: 1000px;    margin: 100px auto;    text-align: center;}/* 头部 &amp;&amp; 底部 */.header,.footer {    height: 100px;    background-color: yellow;}/* 中间主体内容, padding保证中间盒子居中 */.wrapper {    padding: 0 100px;}.col {    float: left;    position: relative;}/* 主要内容 */.main {    width: 100%;    height: 400px;    background: red;}/* 左边内容栏: 定宽=父盒子的padding */.left {    width: 100px;    height: 400px;    /* 负margin 回到最左边 */    margin-left: -100%;    left: -100px;    background: #0f0;}/* 右边内容栏: 定宽=父盒子的padding */.right {    background: pink;    width: 100px;    height: 400px;    /* 负margin 回到最右边 */    margin-left: -100px;    right: -100px;}</code></pre></li><li><p>三栏式的双飞翼布局</p><pre><code>双飞翼布局: 同上面的圣杯一样, 也是将主体内容浮动起来, 中间设置margin, 两侧设置负margin/* 双飞翼布局: 浮动  */.container {    width: 1000px;    margin: 100px auto;    text-align: center;}/* 头尾部分 */.header,.footer {    height: 100px;    background: greenyellow;}/* 主体 */.col {    float: left;    height: 400px;}.main {    width: 100%;}/* main-wrap居中: */.main-wrap {    margin: 0 200px;    background: red;    height: 400px;}/* 两侧布局 */.left {    width: 200px;    margin-left: -100%;    background: pink;}.right {    width: 200px;    margin-left: -200px;    background: pink;}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中经常遇到布局的问题，下面我总结几种常用的css布局方案,直接用代码展示&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于php的一些知识点</title>
    <link href="http://yoursite.com/2018/12/15/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/15/PHP相关知识点/</id>
    <published>2018-12-15T02:53:33.000Z</published>
    <updated>2018-12-25T01:12:29.047Z</updated>
    
    <content type="html"><![CDATA[<p>主要是总结一些网页中php的使用方式…<br><a id="more"></a></p><h1 id="php基础"><a href="#php基础" class="headerlink" title="php基础"></a>php基础</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一般一个语言的语法无非是由变量,数据类型,运算,流程控制,函数,然后就是封装的一些方法,库等…php可以与html一起混合使用,其语法与js大致相同,这里便不做太多介绍了,以下有几个注意点</p><pre><code>注意点:    1. 文件创建: filename.php 代码块: &lt;?php 代码块 ?&gt;    2. 变量声明: 要以$开头, 区分大小写    3. 关于字符串:         a. &quot;&quot;双引可以解析出变量名,&apos;&apos;单引号不行;        b. 字符串的拼接语法使用点 . 来拼接    4. 关于输出:        a. 简单数据类型(字符串,数值等)输出: echo         b. 复杂数据类型(数组,对象等)输出:  print_r() 或者 var_dump()输出详细信息    5. 关于数组        a. 索引数组: 与js一样, $arr = [1,2,3,4]            使用for循环遍历, 长度用count($arr)方法获取        b. 关联数组: 键值对形式的数组, $arr = [&apos;key&apos; =&gt; &apos;value&apos;,...];            b1. 取值使用$arr[&apos;key&apos;]方式            b2. 遍历使用foreach方法                foreach($arr as $key =&gt; $value){                    //循环体里$key就是当前遍历到的元素的$key                    //循环体里$value就是当前遍历到的元素的$value                }    6.指令式的混编写法         &lt;?php            $array = [&apos;php&apos;, &apos;java&apos;, &apos;python&apos;, &apos;ruby&apos;];            //循环开始            for($i = 0; $i &lt; count($array); $i++):        ?&gt;        &lt;!-- 每遍历一个元素就创建一个li标签 --&gt;        &lt;li&gt;&lt;?php echo $array[$i]; ?&gt;&lt;/li&gt;        &lt;!-- 循环结束 --&gt;        &lt;?php endfor; ?&gt;    7.文件引入:  include &quot;文件路径.php&quot;;</code></pre><h2 id="表单交互"><a href="#表单交互" class="headerlink" title="表单交互"></a>表单交互</h2><p>html中的表单(form), 主要是用来向后台提交数据…</p><ul><li><p>form表单,页面提交数据的入口</p><pre><code>&lt;!-- action属性是提交的地址，代表提交到哪个服务器页面, 默认get请求方式 --&gt;&lt;form action=&quot;./result.php&quot;&gt;// 必须要加name属性!!!!!, 后台通过name属性获取传递的数据&lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre></li><li><p>提取表单数据</p><pre><code>上面的表单数据会被提交到result.php文件,这时我们需要提取数据值通过$_GET[&apos;上面表单的name属性值&apos;]即可获取到: 如$res = $_GET[&apos;userName&apos;];isset可以用来判断是否存在某个值 isset($res);返回true/false</code></pre></li><li><p>get请求和post请求</p><pre><code>1. get请求:&lt;form action=&quot;login.php&quot; method=&quot;GET&quot;&gt;    &lt;input type=&quot;text&quot; name=&apos;id&apos; placeholder=&quot;请输入账号&quot;&gt;    &lt;input type=&quot;password&quot; name=&apos;pwd&apos; placeholder=&quot;请输入密码&quot;&gt;    &lt;input type=&quot;submit&quot; value=&apos;登录&apos;&gt;&lt;/form&gt;// 提交数据后的处理页面的链接为: 127.0.0.1/login/login.php?id=hello&amp;pwd=123// get请求会将我们输入的数据:         a. 先将我们输入的数据进行url的拼接        b. 然后以明文的方式发送服务器处理页面; 处理页面通过$_GET[&apos;name属性&apos;]方式取值进行处理// 所以get请求的特点:        1. 简单,传输快,主要用于获取        2. 不安全        3. 长度有限制(2KB)        4. 浏览器缓存// 注意点:    a标签的跳转，也可以理解为是一种get请求。因为get请求本身就是通过网址的跳转来进行的。    所以,我们可以直接构造href属性去请求其他页面, 传入参数通过$_GET方式获取</code></pre></li></ul><pre><code>2. post请求:&lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt;    &lt;input type=&quot;text&quot; name=&apos;id&apos; placeholder=&quot;请输入账号&quot;&gt;    &lt;input type=&quot;password&quot; name=&apos;pwd&apos; placeholder=&quot;请输入密码&quot;&gt;    &lt;input type=&quot;submit&quot; value=&apos;登录&apos;&gt;&lt;/form&gt;// 提交数据后的处理页面的链接为: 127.0.0.1/login/login.php// post请求会将我们输入的数据:         a. 先将我们输入的数据放入到请求体中        b. 然后发送服务器处理页面; 处理页面通过$_POST[&apos;name属性&apos;]方式取值进行处理// 所以post请求的特点:        1. 主要用于提交数据        2. 长度无限制        3. 相对安全(抓包可以抓到post的提交数据)</code></pre><ul><li><p>文件上传</p><pre><code>// 通过表单标签&lt;input type=&quot;file&quot;&gt;来上传1.上传到处理页面     &lt;!-- 表单里仅仅一个文件上传元素，提交到file.php --&gt;        &lt;form action=&quot;file.php&quot; method=&apos;POST&apos; enctype=&apos;multipart/form-data&apos;&gt;            // 需要指定enctype属性            &lt;input type=&quot;file&quot; name=&apos;icon&apos;&gt;            &lt;input type=&quot;submit&quot;&gt;        &lt;/form&gt;2.接受,处理文件: 使用$_FILES[&apos;name属性&apos;]接受, 返回结果为关联数组&lt;?php// 处理上传文件// 1.接受文件$files = $_FILES[&apos;files&apos;]; var_dump($files);// 返回一个关联数组, 有5个属性://  1.name：保存的是文件名// ​ 2.type：保存的是文件类型// ​ 3.tmp_name：保存的是客户端上传来的文件临时保存的路径// ​ 4.error：错误信息代码// ​ 5.size：文件大小// 2.保存文件到本地:  拿到临时路径, 指定文件新的路径地址$oldPath = $files[&apos;tmp_name&apos;];$newPath = &quot;./data/&quot;.$files[&apos;name&apos;]; //不转码的路径//文件名含中文需要转码$gbk = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $files[&apos;name&apos;]);$newPath = &quot;./data/&quot;.$gbk; // 转码路径// 3.转移到本地: 使用move_uploaded_file(old, new)方法$res = move_uploaded_file($oldPath, $newPath);if ($res):    echo &quot;success&quot;;    echo $res;else:    echo &quot;failed&quot;;endif;?&gt;3.文件读写操作    a. file_put_contents(&apos;文件路径&apos;,写入内容);    b. file_get_contents(&apos;文件路径&apos;)4.文件存在判断: 返回布尔值    file_exists(&apos;文件路径&apos;);</code></pre></li></ul><h2 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h2><ul><li><p>增删改查</p><pre><code>1. 增删改    // php操作数据库    // 1. 建立链接: 服务器地址, 主机用户名, 密码, 数据库名    $link = mysqli_connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;hh0127&apos;, &apos;userInfo&apos;);    // 2.准备sql语句    // 增    $sql = &quot;insert into user(userName, description) values(&apos;胡华&apos;, &apos;你最帅啦&apos;)&quot;;    // 删    $delete = &quot;delete from user where id = 2&quot;;    // 改    $sql = &quot;update user set userName=&apos;huhua&apos;,description=&apos;我是哈哈&apos; where id=5&quot;;    // 3.执行语句: mysqli_query(数据库链接, sql语句)  返回值: 是否成功    $res = mysqli_query($link, $sql);    $affect_row = mysqli_affected_rows($link);  // 返回受影响的行数    // 4.关闭链接    mysqli_close($link);2. 查询    // 1.建立连接    $link = mysqli_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;hh0127&apos;, &apos;userInfo&apos;);    // 2.sql查询语句    // $sql = &quot;select * from user&quot;;    // 查询语句    $sql = &quot;select userName,description,id from user&quot;;    $res = mysqli_query($link, $sql); // 返回的是一个对象,数据表结构    // 3.取数据: 使用,mysqli_fetch_all(执行sql语句后的对象)      // 传入参数MYSQLI_ASSOC或者1, 可以将返回的数组内的 键 改为 字段名    // $result = mysqli_fetch_all($res, MYSQLI_ASSOC);     $result = mysqli_fetch_all($res, 1); // 返回一个二维数组: 他的元素为: 一个个关系型数组    echo $result[2][&apos;description&apos;];    // 复杂类型输出    print_r($result);    // 断开连接    mysqli_close($link);</code></pre></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从Web服务器传输超文本到本地浏览器的传送协议,是一个协议集。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><ul><li><p>主要特点</p><pre><code>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。</code></pre></li><li><p>http的工作原理</p><pre><code>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</code></pre></li><li><p>请求和响应的结构</p><pre><code>1.HTTP请求: 请求行（request line）、请求头部（header）、空行和请求数据(实体)</code></pre></li></ul><p><img src="https://i.imgur.com/gxdAtNS.png" alt=""></p><pre><code>GET /index.html HTTP/1.1Host    img.mukewang.comUser-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept  image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明:请求类型为GET,index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等第三部分：空行，请求头部后面的空行是必须的;即使第四部分的请求数据为空，也必须有空行。第四部分：请求数据也叫主体，可以添加任意的其他数据。post请求时所传参数也在其中...2.HTTP响应: 也包括4部分,分别是: 状态行、响应报头、空行和响应正文。举个栗子:    HTTP/1.1 200 OK    Date: Fri, 22 May 2009 06:07:21 GMT    Content-Type: text/html; charset=UTF-8    &lt;html&gt;          &lt;head&gt;&lt;/head&gt;          &lt;body&gt;                &lt;!--body goes here--&gt;          &lt;/body&gt;    &lt;/html&gt;第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）第二部分：响应报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</code></pre><p><img src="https://i.imgur.com/SAkMEA9.png" alt=""></p><pre><code>响应状态码</code></pre><h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><ul><li><p>使用方法</p><pre><code>php中关于cookie和session的使用方法:1.cookie:    // 设置cookie    // 1.设置键, 2.设置值, 3.过期时间: time()+时间段    setcookie(&apos;key1&apos;, &apos;value1&apos;, time()+60);    // 修改cookie: 在原有的cookie上修改其值    setcookie(&apos;key1&apos;, &quot;value1111&quot;, time()+60*10);    // 手动删除cookie: 设置cookie的时间为过去时间: time()-10    setcookie(&apos;key1&apos;, &apos;value1111&apos;, time()-10);    // 获取cookie: $_COOKIE方法    echo &quot;我是cookie值&quot;.$_COOKIE[&apos;key1&apos;];    // cookie的值为string类型    // cookie是在服务器中设置,并随着响应报文返回到浏览器的2.session:    // 1.只要时使用到session: 必须先开启session    session_start();    // 2.设置session: 使用超全局变量$_SESSION    $_SESSION[&apos;admin&apos;] = &apos;huhua&apos;;    $_SESSION[&apos;admin1&apos;] = &apos;huhua1&apos;;    // 3.修改: 对键重新赋值即可    $_SESSION[&apos;admin1&apos;] = &apos;huhua_hello&apos;;    // 4.删除        // 1.开启会话        session_start();        // 2.删除会话 unset        unset($_SESSION[&apos;admin&apos;]);    // 5.获取session值        // 1.开启会话        session_start();        // 2. 通过超全局变量获取        $session = $_SESSION[&apos;admin&apos;];        $session1 = $_SESSION[&apos;admin1&apos;];    注意点:    // 6.session会话: 浏览器关闭就关闭会话    // 7.服务器会生成一个sessionID, 通过响应报文(包含在cookie字段中) 返回给浏览器    // 8.Session 可以存放复杂数据类型    $_SESSION[&apos;arr&apos;] = array(1,2,3,4);</code></pre></li></ul><h2 id="cookie和session的区别和使用"><a href="#cookie和session的区别和使用" class="headerlink" title="cookie和session的区别和使用"></a>cookie和session的区别和使用</h2><p>这个在网上查看了很多资料,选择一个比较好理解的放在这里</p><p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，需自己去解决这个问题。不然有些情况下即使是同一个网站每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>cookie时在我们访问某些网站后在本地存储的一些网站相关信息，下次访问时可以减少一些步骤。更准确的说法是：Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器，是在客户端保持状态的方案。</p><p><strong>Cookie的主要内容包括：名字，值，过期时间，路径和域。</strong><br>key, value形式。过期时间可设置的，如不设，则浏览器关掉就消失了，存储在内存当中，否则就按设置的时间来存储在硬盘上的，过期后自动清除，比方说开关机关闭再打开浏览器后他都会还存在，前者称之为Session cookie 又叫 transient cookie，后者称之为Persistent cookie 又叫 permenent cookie。路径和域就是对应的域名，a网站的cookie自然不能给b用。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session是存在服务器的一种用来存放用户数据的对象。</p><p>浏览器第一次发送请求时，服务器自动生成了一HashTable和一Session ID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。</p><blockquote><p>一般这个值会有个时间限制，超时后毁掉这个值，默认30分钟。</p><p>当用户在应用程序的 Web页间跳转时，存储在 Session 对象中的变量不会丢失而是在整个用户会话中一直存在下去。<br>Session的实现方式和Cookie有一定关系。建立一个连接就生成一个session id，打开几个页面就好几个了，这里就用到了Cookie，把session id存在Cookie中，每次访问的时候将Session id带过去就可以识别了.</p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>cookie </p><p>  登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</p></li><li><p>session</p><p>  session一个场景是购物车，添加了商品之后客户端可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</p></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1、Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。</p><p>2、Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session是没有大小限制和服务器的内存大小有关。</p><p>3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。</p><p>4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是总结一些网页中php的使用方式…&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Ajax相关总结</title>
    <link href="http://yoursite.com/2018/12/13/Ajax%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/13/Ajax基础/</id>
    <published>2018-12-13T02:53:33.000Z</published>
    <updated>2018-12-24T15:55:26.458Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于Ajax内容的总结,主要是总结一些基本用法和注意事项…以及封装的方法..<br><a id="more"></a></p><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax?"></a>什么是Ajax?</h2><p>一般来说,我们向服务器发送一次HTTP请求就会对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。  </p><p>通俗的来讲,Ajax是一种技术, 一种可以让网页某个局部部分动态地给服务器发起请求，而不用整个页面刷新。是一种可以<strong>局部发请求</strong>的技术…</p><h2 id="Ajax的使用步骤"><a href="#Ajax的使用步骤" class="headerlink" title="Ajax的使用步骤"></a>Ajax的使用步骤</h2><pre><code>1.首先我们要确定好需求(使用场景), 也就是什么时候(在事件中使用,或者达到某一条件时)去使用Ajax...2.XMLHttpRequest对象, js中专门用于发送局部请求的对象    a.首先,需要使用new关键字去初始化一个xhr对象,别忘记少写new    var xhr = new XMLHttpRequest();    b.接着是构造请求: 一个请求包括: 请求行,请求头(各个字段),空行, 请求体(数据)    xhr.open(&apos;get&apos;,&apos;请求路径&apos;); // 默认异步, get方式,参数同过url拼接传入: ?key1=value1&amp;k2=v2    xhr.open(&apos;post&apos;,&apos;目标路径&apos;); // 参数通过后面的send方法传入    **b1** post方式请求时需要 构造一个请求头部,不然服务器不会返回数据    xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);    // 注意,服务器的响应体中 也会注明响应文件的content-type, 接受时也需要注意    c.发送请求    xhr.send(); // get方法不用传值,直接发送    xhr.send(&apos;name=huhua&amp;age=18&apos;) // post方式将目标参数同过键值对方式传入    d.进行事件监听,获取服务器响应回来的数据    // 需要判断  请求对象.请求状态和响应状态:   readyState 和  status    xhr.onreadystatechange = function() {        // 判断状态码        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            // 这里就可以处理 响应数据            document.getElementById(&apos;tips&apos;).innerHTML = xhr.responseText;        }    }</code></pre><h2 id="Ajax中传输的数据格式JSON"><a href="#Ajax中传输的数据格式JSON" class="headerlink" title="Ajax中传输的数据格式JSON"></a>Ajax中传输的数据格式JSON</h2><p>为了方便数据跨平台(各语言之间)传输,json对象就被发明了…<br><strong>JSON本质上就只是一个按规定格式写的字符串</strong></p><pre><code>json对象: 一种数据格式, 键为string(必须用双引号), 值为string,number,boolean类型 &apos;{&quot;key1&quot;: &quot;hello&quot;, &quot;key2&quot;: &quot;world&quot;, &quot;key3&quot;: 1, &quot;key4&quot;: true}&apos;;&apos;[{&quot;key1&quot;: &quot;hello&quot;, &quot;key2&quot;: &quot;world&quot;, &quot;key3&quot;: 1, &quot;key4&quot;: true}, {&quot;number&quot;:222}]&apos;;</code></pre><ul><li><p>json的转化</p><pre><code>json在各个语言都有对应的api进行转化,这里就讲一下js和php中的转化方法json对象(字符串包裹是对象或者数组)         通过 JSON.parse()  json转为js对象和数组        通过 stringify()   js转json字符串php中: json_encode() json编码为php对象       json_decode() php对象解码为json对象</code></pre></li></ul><h2 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h2><pre><code>XML也是一种标记语言,同json一样也是用于数据传输的...(体积较大)XML的结构:    &lt;root&gt;        &lt;item&gt;            &lt;id&gt;1&lt;/id&gt;             &lt;name&gt;华仔&lt;/name&gt;             &lt;age&gt;22&lt;/age&gt;         &lt;/item&gt;     &lt;/root&gt;由根节点,以及双标签组成, 标签名自己随意写,符合规范即可...XML和html中document相似, 也可以调用DOM方法, 比如元素的获取等等...</code></pre><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul><li><p>同源策略</p><pre><code>浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。基本上所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。 那么不同源就是跨域:    这里有两个url  http://www.example.com/index.html 和 https://www.example.com/demo.html/    以上两个url就是不同源的,他们的遵守的协议不一样; 如果协议, 域名, 端口中只要有一个不相同就为不同源;    所以, 不同源就是跨域...</code></pre></li><li><p>跨域问题地解决方案</p><pre><code>当我们需要在一个域名下请求另外一个域名的资源时,此时Ajax请求不能使用,该怎么办呢?1.jsonp    jsonp的原理就是利用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，    并且以get的方式将前端回调处理函数名称(callback=functionName)告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式(function(data))传递回去,然后script标签将返回的响应内容当作js代码执行。// 浏览器客户端实行步骤    1. 定义一个函数func用来处理接受到响应地json数据    2. 动态地创建script标签, 添加src属性,添加到body或者head标签中    3. 给这个src属性赋值, 值为api接口地址并拼接上回调函数callback=func    4. 在函数func内部处理接受到的参数args...注意: JS中还有其他三个标签可以进行跨域请求img 、iframe、link(stylesheet)但他们都有缺陷    a. img  //支持跨域但是无法实现获取服务端返回的数据    b. &lt;iframe src=&quot;https://www.baidu.com&quot;&gt;&lt;/iframe&gt; //支持跨域，可以接收服务端数据，但是过程复杂    c. &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://www.baidu.com&quot;&gt; //会在CSS处理阶段报错2.CORS    Cross-Origin Resource Sharing(跨域资源共享)是一种允许当前域（origin）的资源（比如html/js/web service）被其他域（origin）的脚本请求访问的机制。    当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头:origin,    后端在接受到请求后确定响应后会在Response Headers 中加入一个属性Access-Control-Allow-Origin: 这里是发起请求地地址, *表示所有人都能访问3.服务器跨域    在前后端分离的项目中可以借助服务器实现跨域，具体做法是：        a.前端向本地服务器发送请求，本地服务器代替前端再向api服务器接口发送请求进行服务器间通信，        b.本地服务器其实就是个中转站的角色，再将响应的数据返回给前端4.postmessage跨域    HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），    该方法可以通过绑定window的message事件来监听发送跨文档消息传输内容。    使用postMessage实现跨域的话原理就类似于jsonp，动态插入iframe标签，再从iframe里面拿回数据</code></pre></li></ul><h2 id="通过模板动态添加网页元素"><a href="#通过模板动态添加网页元素" class="headerlink" title="通过模板动态添加网页元素"></a>通过模板动态添加网页元素</h2><p>当我们从后端接口拿到数据后,需要动态的将元素添加到网页中; 一般有几种方式可以做到</p><pre><code>a. 找到数据填充的标签, 创建这个标签, 然后数据用 字符串拼接 的方式组合在一起,最后appendchild到父元素身上b. 通过 引入模板的方式 来实现元素的添加; 这种方式更为快速,方便举个粒子: obj是一个对象    a.字符串拼接法     var pList = document.querySelectorAll(&apos;p&apos;);    pList[0].innerHTML = &quot;QQ号:  &quot; +  obj.result.qq;    pList[1].innerHTML = &quot;得分:  &quot; +  obj.result.score;    pList[2].innerHTML = &quot;吉凶论断:  &quot; +  obj.result.luck;    pList[3].innerHTML = &quot;论断详情:  &quot; +  obj.result.content;    pList[4].innerHTML = &quot;性格分析:  &quot; +  obj.result.character;    pList[5].innerHTML = &quot;性格详情:  &quot; +  obj.result.characterdetail;    b.模板法添加元素    &lt;!-- 1.引入模板 --&gt;    &lt;script src=&quot;../../js/template-web.js&quot;&gt;&lt;/script&gt;    &lt;!-- 2.使用script标签创建模板, a.指定模板的 type 不能位JavaScript文件类型; b.定义一个id确定模板位置--&gt;    &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;        &lt;!-- 遍历这个data对象(单个对象) --&gt;        {{ each obj value key }}            &lt;p&gt;{{key}} : {{value}}&lt;/p&gt;        {{ /each }}    &lt;/script&gt;    // 3.调用模板的api: template函数    var html = template(&apos;tpl&apos;, {obj: obj.result}); // 返回一个html结构    document.getElementById(&apos;box&apos;).innerHTML = html; // 将内容添加到box的盒子</code></pre><h2 id="Ajax的封装"><a href="#Ajax的封装" class="headerlink" title="Ajax的封装"></a>Ajax的封装</h2><ul><li><p>原生js封装</p><pre><code>Ajax请求封装:     1.声明一个函数    2.相同部分放入函数体    3.调用函数    4.不同部分当作参数: 请求类型type 和 url    5.对请求方式大小写的处理    6.请求参数data    7.传入回调函数callback, 处理响应体    8.自动转换响应体数据的类型datatype, json,xml,或者普通json字符串(不做处理)    9.将参数作为对象    10.避免变量名污染, 定义一个对象,将参数放在一个对象中// 如果不想在回调函数内操作响应数据,可以使用一个全局变量去储存 Ajax接受到的响应体的值 xhr.responseTextdocument.getElementById(&apos;btn&apos;).onclick = function () {    // 参数: 请求方法, url, url参数, 回调处理函数function(res){}, 响应内容处理格式datatype    var params = {        type: &apos;get&apos;,        url: &apos;req.php&apos;,        data: &apos;name=helloworld&apos;,        callback: function (res) {            // 这里的函数是对Ajax响应体的处理函数            console.log(res);        },        datatype: &apos;json&apos;,    };    request.ajax(params);};var request = {}; // 定义一个对象request.ajax =  function(params) {    // 响应类型大小写转换    var type = params.type.toLocaleLowerCase();    // 判断请求类型,发送对应请求    if (type == &apos;get&apos;) {        // get请求的 url拼接        params.url += &quot;?&quot; + params.data;    }    // 创建请求    var xhr = new XMLHttpRequest();    xhr.open(type, params.url);    // 如果是发送post请求    if (type == &apos;post&apos;) {        xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);        xhr.send(params.data);    }else {        xhr.send();    }    // 响应监听    xhr.onreadystatechange = function () {        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            var xhr_res = xhr.responseText;        }else {            return &apos;访问失败&apos;;        }        // 处理响应数据, 判断用户需要哪种数据        var res;        if (params.datatype) {            params.datatype = params.datatype.toLocaleLowerCase();             if (params.datatype == &apos;json&apos;) {                res = JSON.parse(xhr_res);            }            if (params.datatype == &apos;xml&apos;) {                var parser = new DOMParser();                res = parser.parseFromString(xhr_res, &apos;text/html&apos;);            }        } else {            res = xhr_res; // 实际字符串        }        // 回调函数处理        params.callback(res);    }}</code></pre></li><li><p>jQuery中的封装调用</p><pre><code>// btn1点击事件$(&quot;#btn1&quot;).click(function () {    // 发送get请求    $.get({        url: &quot;./get.php&quot;,        // data: {name: &apos;get&apos;},        success: function(res) {        // 处理响应体的回调函数        // header(&apos;content-type:application/text;charset=utf-8&apos;);        // 注意!!! 后端设置的文件类型格式(text/html, json等等...)也会 限制响应体格式的输出..., 有可能拿不到res        console.log(res);    },        error: function(res) {    //  处理响应体的回调函数    //      console.log(res);    //  }        // dataType: &quot;json&quot; &quot;jsonp&quot; &quot;xml&quot;, 如果后端api返回的数据是普通字符串,就不需要传这个参数        // 如果用jQuery发jsonp请求，不用创建script，只要dataType写一个jsonp    })})// btn点击事件$(&quot;#btn2&quot;).click(function () {    // 发送post请求    $.post({        url: &quot;./post.php&quot;,        data: {name: &apos;post&apos;},        success: function(res) {            //处理响应体的回调函数            console.log(res);        },    })})// btn3点击事件$(&quot;#btn3&quot;).click(function () {    // 发送任意请求    $.ajax({        url: &quot;./ajax.php&quot;,        data: {name: &apos;bob&apos;},        type: &quot;get&quot;, // 指定请求类型        success: function(res) {            // 处理响应体的回调函数            console.log(res);        },        dataType: &quot;json&quot;,    })})</code></pre></li><li><p>form表单序列化</p><pre><code>$(&apos;.submit&apos;).click(function () {    // 先获取所有数据, 通过form表单序列化方法    // jQuery中的表单序列化：$(表单).serialize方法; 表单必须有name属性    // 获取的序列化字符串的key值 就是name属性的值    var data = $(&apos;#ajaxForm&apos;).serialize();    console.log(data);    // 发送请求核对    $.post({        url: &quot;_api/register.php&quot;,        data: {data},        // 回调函数处理响应内容        success: function (res) {            console.log(res);        }    });})</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于Ajax内容的总结,主要是总结一些基本用法和注意事项…以及封装的方法..&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性学习</title>
    <link href="http://yoursite.com/2018/12/13/CSS3%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/13/CSS3特性学习总结/</id>
    <published>2018-12-13T02:53:33.000Z</published>
    <updated>2018-12-17T13:56:08.443Z</updated>
    
    <content type="html"><![CDATA[<p>关于css3的新特性学习总结…当然c3属性的使用要考虑到浏览器的兼容性问题…<br><a id="more"></a></p><h1 id="css3新特性学习"><a href="#css3新特性学习" class="headerlink" title="css3新特性学习"></a>css3新特性学习</h1><h2 id="边框系列"><a href="#边框系列" class="headerlink" title="边框系列"></a>边框系列</h2><ul><li><p>圆角</p><pre><code>/* 圆角border-radius */div {    /* 从左上角开始 */    /* border-radius: 20px 30px 40px 50px; */    /* 左上右下, 右上左下 */    /* border-radius: 20px 40px;  */    /* 全部一样 */    border-radius: 40px;}// 当半径为50%时,就会显示一个圆</code></pre></li><li><p>阴影</p><pre><code>/* 盒子阴影box-shadow */div {    /* 阴影水平偏移距离, 垂直偏移, 模糊半径, 阴影背景色 */    box-shadow: 10px 10px 10px #ccc,20px 20px 10px green;}文字阴影text-shadow和上面一样, 也可以同时叠加多个阴影...</code></pre></li></ul><h2 id="背景系列"><a href="#背景系列" class="headerlink" title="背景系列"></a>背景系列</h2><pre><code>.box {        /* 盒子必须要有宽高,才能存放背景图片 */        width: 400px;        height: 400px;        /* 可以设置多个背景图 */        background: url(&quot;../messi.jpg&quot;) no-repeat right top,        url(&quot;../xiaoxin.jpg&quot;) no-repeat left bottom,        #ccc;        /* 可以改变背景图尺寸 */        background-size: 25% 25%;        /* 背景图存放区域: 默认padding-box, 还有content和border  */        background-origin: padding-box;    }</code></pre><h2 id="渐变系列"><a href="#渐变系列" class="headerlink" title="渐变系列"></a>渐变系列</h2><p>css3渐变(gradients)可以让你在两个或者多个指定的颜色之间显示平稳的过度。</p><ul><li><p>线性渐变（Linear Gradients)</p><pre><code>这种渐变可以向上、向下、向左、向右甚至是各个你想要的方向(角度45deg)。div {    width: 400px;    height: 100px;    /* 线性渐变: 指定渐变方向, 和至少两种颜色, 浏览器兼容 */    background: -webkit-linear-gradient(left, red, green, blue);    background: -o-linear-gradient(left, red, green, blue);    background: -moz-linear-gradient(left, red, green, blue);    background: linear-gradient(to right, red, green, blue);}// 按角度方向渐变.san {    width: 100px;    height: 100px;    background: linear-gradient(-135deg, blue 20px, red 0);}</code></pre></li><li><p>径向渐变（Radial Gradients）</p><pre><code>这种渐变即由中心出发，向四周渐变。创建一个径向渐变，我们至少定义两种颜色结点。同时也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是center，形状是ellipse，渐变的大小是fasthest-corner（表示最远的角落）。其中形状还可以是circle（圆形）、大小还可以是choset-side和closest-corner和farthest-side。语法:background: radial-gradient(center, shape size, start-color, ..., last-color);.radial {    width: 400px;    height: 300px;    /* 默认渐变, 渐变距离位置由父容器决定 */    background: radial-gradient(red, blue);    /* 圆形渐变, 默认半径是容器对角线的一半,也可以指定渲染半径 */    background: radial-gradient(100px circle, red, yellow);    /* at指定起始位置: 距离左上角的距离, 默认是中心*/    background: radial-gradient(at 50% 50%, red, yellow);    /* 指定终止位置: 父容器的近边, 近角; 远边,远角 */    background: radial-gradient(closest-side circle at 20% 20%, red, yellow);    /* 指定颜色断点,当多个颜色一起时,默认是均匀分配渐变区域的 */    background: radial-gradient(closest-side circle, yellow 20%, orange 40%, red 60%, #ccc);    /* 椭圆渐变, 渐变叠加*/    background: radial-gradient(100px 200px ellipse, transparent 40px, yellow, red 50px, transparent),    radial-gradient(30px circle, red, red 29px, transparent);    /* background-size: 40px; */}/* 水波纹效果: 通过伪类添加效果 */.shuibo {    width: 200px; height: 100px;    background: yellow;    position: relative;}.shuibo:after {    content: &apos;&apos;;    position: absolute;    height: 10px;    left:0 ;     right: 0;    bottom: -10px;    background: radial-gradient(20px 15px ellipse at top, red 10px, transparent 11px);    background-size: 20px 10px;}</code></pre></li></ul><h2 id="transform-2d转换"><a href="#transform-2d转换" class="headerlink" title="transform 2d转换"></a>transform 2d转换</h2><pre><code>/* transform 2d方法 */img {    /* 1.translate(): 相对元素自身原来位置向X,Y轴移动 */    transform: translate(100px,100px);    /* 2.ratote(): 旋转的度数, 正数就是顺时针旋转 */    /* 会覆盖上面的位移方法 */    transform: rotate(45deg);    /* 3.scale(): 基于原图宽高放大缩小 */    /* 高度或宽度设为0就隐藏了 */    transform: scale(0.5, 1);    /* transform: scale(0.5, 0); */    /* 4.skew(): 沿X,和Y轴倾斜转换 */    transform: skew(20deg, 0deg);    /* 转换的基点属性: 默认为中心 */    /* transform-origin：0 0；表示以左上角为原点    transform-origin：100% 0；表示以右上角为原点    transform-origin：0 100%；表示以左下角为原点    transform-origin：100% 100%；表示以右下角为原点 */}</code></pre><h2 id="transform-3d转换"><a href="#transform-3d转换" class="headerlink" title="transform 3d转换"></a>transform 3d转换</h2><ul><li><p>rotateXYZ</p><pre><code>.box1 {    /* 2d的rotate()方法只是在平面内顺时针旋转,相当于rotateZ() */    /* 3d的方法绕X,Y,Z轴进行空间旋转 */    transform: rotateX(30deg);      transform: rotateY(30deg);      transform: rotateZ(30deg);  }</code></pre></li></ul><h2 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h2><p>这个属性可以轻松的实现从某种效果到另一种效果的渐变过程</p><pre><code>一般情况下，该属性即transition必须规定2项内容指定要添加效果的css属性（这样才能识别做哪个方向的过渡，通常是width、height）指定效果的持续时间（默认持续时间为0，所以必须要指定）</code></pre><blockquote><p>  <strong>注意：该属性必须结合伪类:hover来使用</strong>。</p></blockquote><pre><code>.box {    /* 开始的样式 */    width: 100px;    height: 100px;    background-color: rgb(75, 214, 110);    font-size: 14px;    /* transition:指定要过渡的属性, 过渡时间 */    /* transition: width 3s, height 3s, transform 3s, font-size 3s; */    /* (all表示所有属性都过渡),/*第2个时间参数是delay,过1秒才触发 */     transition: all 3s 1s;}.box:hover {    /* 最终的样式 */    width: 500px;    height: 500px;    transform: rotate(360deg);    background-color: red;    font-size: 40px;}</code></pre><h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>创建css3动画，需要使用@keyframes规则。使用该规则即创建动画，它规定了一个css样式和动画将逐步从目前的样式更新为新的样式。</p><p><strong>使用语法:</strong></p><blockquote><p> 1.先给目标元素设置一个animation属性: </p></blockquote><p><img src="https://i.imgur.com/Y0HTfzS.png" alt=""></p><pre><code>animation-name: wobble;/*动画属性名，也就是我们前面keyframes定义的动画名*/animation-duration: 10s;/*动画周期持续时间*/animation-timing-function: ease-in-out; /*动画频率，先加速再减速, 匀速为linear*/animation-delay: 2s;/*动画延迟时间*/animation-iteration-count: 10;/*定义循环次数，infinite为无限次*/animation-direction: alternate;/*动作方式:往返*/当然, 一般都会采用连写方式,下面举例说明</code></pre><blockquote><p>2.再来规定动画的名称 @keyframes 动画名 {阶段值}</p></blockquote><pre><code>.letter {        float: left;        padding: 10px;        line-height: 200px;        font-size: 30px;        animation: showHide 2s linear infinite;    } @keyframes showHide     {        0% {opacity: 1;}        50% {opacity: 0.1;}        100% {opacity: 1;}    }</code></pre><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>img来添加border-radius属性，可以添加border属性，可以添加padding属性（注意：img是行内元素，但是也可以添加padding属性）。<br>我们还可以制作响应式图片。并且可以在图片上添加文本。以及图片滤镜。和响应式图片相册。</p><pre><code>img {        /* 图片添加边框,padding,圆角,阴影属性 */        border: thin solid red;        padding: 10px;        border-radius: 10px;        box-shadow: 5px 5px 5px greenyellow;    }img {        /* 响应式图片: 宽度随父盒子变化而变化 */        width: 100%;        height: auto;    }/* 图片过滤处理filter属性 */img {        width: 25%;        float: left;        height: auto;        max-width: 250px;    }/* 图片滤镜filter */.blur {filter: blur(4px)}    /* 模糊 */.opacity {opacity: 0.5;}     /* 透明度 */.brightness {filter: brightness(1.5)}  /* 亮度: 0变黑 大于1变亮 */.contrast {filter: contrast(2)}  /* 对比度: 0变黑 大于1变亮 */.grayscale {filter: grayscale(1)}  /* 灰度: 0-1之间  变灰*/.hue-rotate {filter: hue-rotate(180deg)}  /* 色相旋转: 0-360deg之间 */.invert {filter: invert(1)}  /* 反转输入图像: 0-1之间  曝光效果*/.sepia {filter: sepia(1)}  /* 转为深褐色: 0-1之间, 怀旧风格 */</code></pre><p>C3属性就先写到这,以后用到再继续更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于css3的新特性学习总结…当然c3属性的使用要考虑到浏览器的兼容性问题…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>jQuery常用知识总结</title>
    <link href="http://yoursite.com/2018/12/06/jQuery%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/06/jQuery语法基础/</id>
    <published>2018-12-06T02:53:33.000Z</published>
    <updated>2018-12-24T12:10:52.613Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容是对jQuery和原生JS进行了对比和归纳,主要是总结一些jQuery的常用知识点…<br><a id="more"></a></p><h1 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h1><p>jQuery是一个js库, 它将原生js的一些方法封装起来,简化了js对DOM的动态操作,还做了一些浏览器的兼容处理;另外jquery的很多方法传参后返回就是自己,因此可以进行链式操作;还可以进行隐式迭代等;下面将从几个方面(jQuery对象, 选择器, css样式操作, html节点操作(增删改),位置, 动画, 事件操作等)来对jquery进行解析.</p><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p>当我们引入jquery文件时,相当于执行jquery的代码, 返回的是一个jQuery对象(也可以用$来表示),里面包含很多封装好的方法.</p><ul><li><p>jQuery对象和DOM对象</p><p>  DOM对象: 用原生JavaScript获取的DOM对象<br>  通过document.getElementById()  返回的是元素(DOM对象)<br>  通过document.getElementsByTagName()  返回伪数组(集合)，集合中的每一个对象是DOM对象</p><p>  jQuery对象: jQuery对象用$()的方式获取的对象<br>  jQuery对象又可以叫做包装集(包装的DOM对象的集合)</p><p>  <strong>jQuery对象不能使用DOM对象的成员，DOM对象不能使用jQuery对象的成员</strong></p></li><li><p>jQuery对象和DOM对象的相互转换</p><p>  jQuery对象转换成DOM对象：   </p><pre><code>jQuery对象.get(索引值); jQuery对象[索引值]; jQuery对象是包装集(集合)，从集合中取数据可以使用索引的方式</code></pre><p>  DOM对象转换成jQuery对象：   </p><pre><code>$(DOM对象) 只有这一种方法;</code></pre></li><li><p>入口函数</p><p>  关于jQuery的入口函数：</p><pre><code>// 第一种写法$(document).ready(function() {    });// 第二种写法$(function() {});</code></pre><p>  jQuery入口函数与window.onload的对比:</p><p>  JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。<br>  jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</p></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>jQuery中选择器的作用是用来快速匹配到要操作的元素,使用$(selector)获取jQuery对象, 而原生js是通过document.getElementById(‘box’)等这些方法获取到DOM对象.</p><ul><li><p>基本选择器</p><pre><code>ID选择器     $(&apos;#id&apos;);    获取指定ID的元素类选择器     $(&apos;.class&apos;);    获取同一类class的元素标签选择器     $(&apos;div&apos;);    获取同一类标签的所有元素并集选择器     $(&apos;div,p,li&apos;);    使用逗号分隔，只要符合条件之一就可。交集选择器     $(&apos;div.redClass&apos;);    获取class为redClass的div元素</code></pre></li><li><p>层级选择器</p><pre><code>子代选择器    $(&apos;ul &gt; li&apos;);    获取儿子层级的元素，注意，并不会获取孙子层级的元素后代选择器    $(&apos;ul li&apos;);     代表后代选择器，获取ul下的所有li元素，包括孙子等</code></pre></li><li><p>过滤选择器</p><pre><code>:eq（index）    $(&apos;li:eq(2)&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为2的元素，索引号index从0开始。:odd    $(&apos;li:odd&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为奇数的元素:even    $(&apos;li:even&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为偶数的元素 :enabled :disabled :checked :selected 获取到表单对象属性还有很多不常用的,用到时可以查文档...</code></pre></li><li><p>jQuery筛选选择器(这些都是jQuery对象的方法)  </p><pre><code>通常我们可以用一个$xxx变量将定位地元素先存起来,然后再调用其方法取定位到目标元素...返回地也是jQuery对象.children(selector)     $(&apos;ul&apos;).children(&apos;li&apos;)    相当于$(&apos;ul&gt;li&apos;)，子类选择器find(selector)        $(&apos;ul&apos;).find(&apos;li&apos;);    相当于$(&apos;ul li&apos;),后代选择器siblings(selector)    $(&apos;#first&apos;).siblings(&apos;li&apos;);    查找兄弟节点，不包括自己本身。parent()      $(&apos;#first&apos;).parent();      查找父亲eq(index)      $(&apos;li&apos;).eq(2);    相当于$(&apos;li:eq(2)&apos;),index从0开始next()          $(&apos;li&apos;).next()    找下一个兄弟prev()          $(&apos;li&apos;).prev()    找上一次兄弟....其他可以查阅文档</code></pre></li></ul><h2 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h2><p>属性操作一般是用来获取表单元素和其他元素地内容,以及修改删除等等…<br>原生js中的DOM对象操作属性:</p><p>自定义属性操作: setAttribute(‘attr_name’) getAttribute等…还有点语法操作行内属性</p><ul><li><p>attr的用法</p><pre><code>1. 获取, 设置属性值&lt;!-- 不传参获取不到 --&gt;$(&quot;img&quot;).attr(&quot;src&quot;); //获取文档中所有图像的src属性值。$(&quot;img&quot;).attr({ src: &quot;test.jpg&quot;, alt: &quot;Test Image&quot; }); //为所有图像设置src和alt属性值$(&quot;img&quot;).attr(&quot;title&quot;, function() { return this.src }); //把src属性的值设置为title属性的值2. 删除属性$(&quot;img&quot;).removeAttr(&quot;src&quot;);</code></pre></li></ul><ul><li><p>prop的用法</p><pre><code>对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。1.获取, 设置$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;); // 获取属性, 返回值为true or false$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop({checked: true}); // 全设置为true// 传入回调函数  // 通过函数来设置所有页面上的复选框被选中。$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, function( i, val ) {        return !val;    });2.删除属性$(&quot;input[type=&apos;checkbox&apos;]&quot;).removeProp(&apos;disabled&apos;); // 删除禁用属性</code></pre></li><li><p>addClass的用法(类名) </p><pre><code>给元素添加类名属性, 添加多个接的加空格1.添加$(&apos;.sec&apos;).addClass(&apos;hello world&apos;); // 添加了2个类名// 传入回调函数$(&apos;ul li&apos;).addClass(function() {    return &apos;index&apos; + $(this).index();  // 给所有li添加index+自己下标的类名});console.log($(&apos;ul li.index3&apos;).index()); // 返回自己在父元素中的索引2.删除$(&apos;ul li&apos;).removeClass(); // 不传参删除所有,传参删除选定类名同样可以传入一个回调函数, return你处理后的结果3.切换toggleClass$(&apos;#btn&apos;).on(&apos;click&apos;, function () {    $(&apos;.sec&apos;).toggleClass(&apos;red&apos;);  // 点击一次按钮,便切换类名})&lt;!-- 还可以传入一个布尔参数 --&gt;var count = 1;$(&apos;#btn&apos;).on(&apos;click&apos;, function () {    console.log(count);    $(&apos;.sec&apos;).toggleClass(&apos;red&apos;, count++ % 5 == 0); // 点击5次li变红})</code></pre></li><li><p>html,text,val的用法</p><pre><code>这些都是获取标签元素文本内容和设置内容的方法...1.html()方法  对应原生js中的innerHTML方法var $ht = $(&apos;.sec&apos;).html(); // 不传参返回标签网页内容console.log($ht);设置内容: 传入一个标签,会添加到网页,但会覆盖之前的内容$(&apos;.sec&apos;).html(&quot;&lt;b&gt;hello jquery&lt;/b&gt;&quot;);也可以传入回调函数...2.text()方法  对应原生js中的innerText和textContentconsole.log($(&apos;.sec&apos;).text());  // 返回文本$(&apos;.sec&apos;).text(&apos;hello text&apos;)   // 设置文本,会把子元素全部覆盖掉$(&apos;.sec a&apos;).text(&apos;hello text&apos;)// 回调函数var a = &apos;hello&apos;$(&quot;.sec&quot;).text(function(n){    return &quot;这个 li 元素的 index 是：&quot; + n;}(a));3.val()方法  对应js 中的表单元素的value属性的值的操作console.log($(&apos;input&apos;).eq(1).val()); // 获取值// 传入参数就是设置值// 也可以传回调函数$(&apos;input:text.items&apos;).val(function() {    return this.value + &apos; &apos; + this.className;});</code></pre></li></ul><h2 id="jQuery操作文档节点"><a href="#jQuery操作文档节点" class="headerlink" title="jQuery操作文档节点"></a>jQuery操作文档节点</h2><p>jQuery也可以做创建,添加,删除文档节点的操作…</p><ul><li><p>创建节点</p><pre><code>var $p = $(&apos;&lt;p&gt;Hello&lt;/p&gt;&apos;); // $(传入一个html格式字符串), 此时内存中便创建了一个节点对象,js中使用createElement(&apos;标签名&apos;)$(&apos;body&apos;).append($p);</code></pre></li><li><p>节点的增删改</p><pre><code>1.增加A.append(B) === B.appendTo(A)    在被选元素的结尾插入内容prepend prependTo    在被选元素的开头插入内容before                在被选元素之后插入内容after                在被选元素之前插入内容insertAfter() // 把所有匹配的元素插入到另一个、指定的元素元素集合的后面。 注意: appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，返回值是所有被追加的内容，sh是前者!!!而不仅仅是先前所选中的元素。所以，要选择先前选中的元素，需要使用end()方法2.替换A.replaceWith(html字符串) // 将所有匹配的元素A替换成指定的HTML或DOM元素$(html字符串).replaceAll(jQuery对象) // 与上面反过来3.清空节点与删除节点$(&apos;div&apos;).empty(); // 清空div的所有内容（使用较多，会清除子元素上绑定的内容，源码）,但会自身保留$(&apos;div&apos;).html(&apos;&apos;);// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。$(&apos;div&apos;).remove(); // 相比于empty，自身也删除（自杀）4.克隆节点// 按钮克隆$(&apos;#btn&apos;).on(&apos;click&apos;, function(){    // 布尔值（true 或者 false）参数表示事件处理函数是否会被复制    $(this).clone(true).insertAfter(this);    // $(this).clone(true).before(this); 这个方法不行!!})</code></pre></li></ul><h2 id="jQuery操作CSS样式"><a href="#jQuery操作CSS样式" class="headerlink" title="jQuery操作CSS样式"></a>jQuery操作CSS样式</h2><p>通过css()方法jQuery对象可以获取,设置或者修改样式，操作的是style属性。</p><ul><li><p>css()方法</p><pre><code>1.获取样式$(&apos;div&apos;).css(&apos;background-color&apos;)  // 获取背景色2.设置或修改$(&apos;div&apos;).css({    &apos;background&apos;:&apos;gray&apos;,    &apos;width&apos;:&apos;400px&apos;,    &apos;height&apos;:&apos;200px&apos;});注意:    设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值    获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</code></pre></li><li><p>jQuery中元素的几个位置,尺寸方法</p><pre><code>1.width()方法和height()方法// 获取内容宽高.console.log($(&apos;div&apos;).width()); //200console.log($(&apos;div&apos;).height()); //200//设置内容宽高.$(&apos;div&apos;).width(300);$(&apos;div&apos;).height(300);2.innerWidth()和innerHeight();    获取内容宽高+paddingconsole.log($(&apos;div&apos;).innerWidth());console.log($(&apos;div&apos;).innerHeight());//设置还是会把padding计算进来,修改内容的宽高.$(&apos;div&apos;).innerWidth(300);$(&apos;div&apos;).innerHeight(300);3.outerWidth(); outerHeight();    获取内容宽高+padding+border;console.log($(&apos;div&apos;).outerWidth());console.log($(&apos;div&apos;).outerHeight());//设置还是会把 padding和 border计算进来,修改内容的宽高.$(&apos;div&apos;).outerWidth(300);$(&apos;div&apos;).outerHeight(300);4.outerWidth(true); outerHeight(true); 获取内容宽高+padding+border+margin;console.log($(&apos;div&apos;).outerWidth(true));console.log($(&apos;div&apos;).outerHeight(true));5.获取页面可视区的宽高获取可视区宽度 $(window).width();获取可视区高度 $(window).height();6.offset()方法与position()方法offset()方法获取元素距离document(即当前网页窗口)的位置，var $offset = $(&apos;#son&apos;).offset();console.log($offset); // 返回一个对象, {top:200,left:200};注意: 它是可以设置的,传入一个对象参数; 如果元素没有定位, 设置offset,那么就会自动给他一个relative定位.position方法获取的是元素距离有定位的父元素(offsetParent)的位置。var $position = $(&apos;#son&apos;).position();console.log($position); // 返回一个对象, {top:100,left:100};注意: position方法不能设置7.scrollTop与scrollLeft: 设置或者获取垂直滚动条的位置//获取页面被卷曲的高度, 常用于返回顶部, window的onscroll事件$(window).scrollTop();// 获取页面被卷曲的宽度$(window).scrollLeft();</code></pre></li></ul><h2 id="jQuery操作元素动画效果"><a href="#jQuery操作元素动画效果" class="headerlink" title="jQuery操作元素动画效果"></a>jQuery操作元素动画效果</h2><p>jQuery中封装了几个基本的自定义动画的功能。</p><ul><li><p>显示隐藏show/hide</p><pre><code>这个相当于操作 display属性hide和block, 并由高度和宽度的变化1.显示  show(参数1,参数3, 参数2); // 参数3是默认缓动, 可以传入&apos;linear&apos;就是匀速//参数1: 执行动画的时长  可以是毫秒数 也可以是代表时长的字符串  slow  fast  normal  如果字符串单词写错了相当于写了一个normal//参数2: 动画执行完毕后的回调函数.$(&apos;#div1&apos;).show(1000, function () {    alert(&apos;动画执行完毕了.&apos;);});2.隐藏 hide()  同上3.toggle()  切换显示隐藏效果</code></pre></li><li><p>slideDown()/slideUp()/slideToggle()</p><pre><code>这个动画相当于调整元素的高度height, 让元素有一个缓慢滑下和向上滑的效果,用法同上</code></pre></li><li><p>fadeIn()/fadeOut();fadeToggle()/fadeTo</p><pre><code>这组动画相当于调整元素的透明度, 0~1之间</code></pre></li><li><p>自定义动画animate</p><pre><code>$(selector).animate({params},[speed],[easing],[callback]);// {params}：要执行动画的CSS属性，带数字（必选）, 属性书写为驼峰// speed：执行动画时长（可选）// easing:执行效果，默认为swing（缓动）  可以是linear（匀速）// callback：动画执行完后立即执行的回调函数（可选）$(&quot;#go&quot;).click(function(){    $(&quot;#block&quot;).animate({         width: &quot;90%&quot;,        height: &quot;100%&quot;,         fontSize: &quot;10em&quot;,         borderWidth: 10    }, 1000 );});</code></pre></li><li><p>动画队列,停止stop,延迟delay</p><pre><code>当给一个元素加动画时,我们多次触发动画效果,它会执行完所有的动画才会停止,而我们有时候需要停止动画stop([clearQueue],[jumpToEnd])方法clearQueue:如果设置成true，则清空队列。可以立即结束动画。jumpToEnd:如果设置成true，则完成队列。可以立即完成动画,跳转到最终值常用stop(true, false)来实现一些之前结束之前的动画,进行下一个动画的场景delay(时间)设置一个延时来推迟执行队列中之后的项目。$(&apos;#foo&apos;).slideUp(300).delay(800).fadeIn(400); // 在.slideUp() 和 .fadeIn()之间延时800毫秒</code></pre></li></ul><h2 id="jQuery事件操作"><a href="#jQuery事件操作" class="headerlink" title="jQuery事件操作"></a>jQuery事件操作</h2><p>这里主要讲一下事件注册,触发,解绑以及事件对象…</p><ul><li><p>on注册事件</p><pre><code>1. on注册简单事件// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on(&apos;click&apos;, function() {    alert(&apos;hello world);}); 2. on注册事件委托// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on(&apos;click&apos;,&apos;span&apos;, function() {    alert(&apos;span的父元素下的后来创建的span元素都有可以触发这个函数&apos;);})</code></pre></li><li><p>解绑事件 off(事件名)</p><pre><code>$(&apos;#btn2&apos;).on(&apos;click&apos;, function () {//给div解绑事件//$(&apos;div&apos;).off();//解绑所有的事件.     $(&apos;div&apos;).off(&apos;click&apos;);//解绑指定的事件.});</code></pre></li><li><p>触发事件trigger</p><pre><code>当事件满足某一条件或者有时候需要去出发定义自定义事件,可以使用.trigger(事件名)//2.点击按钮,满足条件触发div的单击事件.var i = 0;$(&apos;#btn1&apos;).on(&apos;click&apos;, function () {i++;//当i等于3的时候,要调用一下div的单击事件.if(i == 3){    //a.调用div的click事件.    //$(&apos;#one&apos;).click();    //b.使用触发器.    $(&apos;#one&apos;).trigger(&apos;click&apos;); //条件触发}});</code></pre></li><li><p>jQuery事件对象</p><pre><code>jQuery 事件对象是对原生js事件对象的一个封装，并做了兼容性的处理$(&apos;#one&apos;).on(&apos;click&apos;, function (e) {    console.log(e); // e就是事件对象    //三个常用的坐标. 和原生js中的一样.    console.log(e.screenX + &quot;-&quot; + e.screenY); //屏幕左上角 距离触发事件的那一点的距离    console.log(e.clientX + &quot;-&quot; + e.clientY); //页面可视区左上角距离触发事件的那一点之间的距离.    console.log(e.pageX + &quot;-&quot; + e.pageY);//页面左上角 距离触发事件那一点之间的距离.}还有几个常用的属性    event.keyCode    按下的键盘代码    event.data    存储绑定事件时传递的附加数      event.stopPropagation()    阻止事件冒泡行为    event.preventDefault()    阻止浏览器默认行为, 如跳转    return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</code></pre></li></ul><h2 id="jQuery注意事项"><a href="#jQuery注意事项" class="headerlink" title="jQuery注意事项"></a>jQuery注意事项</h2><ul><li><p>链式编程中end()方法的使用</p><pre><code>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</code></pre></li><li><p>显示迭代方法,如each,reduce,filter等等,</p><pre><code>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。举个例子:    $(function () {        //找到所有的li标签,分别设置透明度,透明度是递增到1.        var $lis = $(&apos;#ulList&gt;li&apos;);        //jQuery中的each()方法        $lis.each(function (index,ele) {            //console.log(index);//索引,下标            //console.log(ele);//遍历出来的对象,是dom对象.            //ele.style.opacity = (index+1)/10; //dom对象调用dom属性或者方法        $(ele).css(&apos;opacity&apos;,(index+1)/10); //jQuery对象调用jQuery属性或者方法        });    });</code></pre></li><li><p>多库共存</p><pre><code>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.当我需要引入多个jQuery文件时, 就需要规避变量名$冲突的影响1. 比如:如果要做浏览器兼容处理就要引入1.x版本, 那如果要使用最近更新的新方法,就要使用3.x版本的.现在引入2个jQuery文件, 那如何调用者两个文件中的方法呢?var _$ = $.noConflict(); //把$的控制权给释放了. 这个方法有返回值,返回值可以看成是释放$的替代.console.log($.fn.jquery); //1.12.4  // 可以使用3.0.0上面的1.12.4版,不会被覆盖console.log(jQuery.fn.jquery); //3.0.0console.log(_$.fn.jquery);//3.0.0(function ($) {//我们可以把代码放入一个自调用函数中,这里就可以继续使用$代替_$来工作了!!!    console.log($.fn.jquery);//3.0.0}(_$));2. 如果引入了3个包含$的文件, 依次释放即可    var _$30 = $.noConflict();    var _$10 = $.noConflict    console.log(_$30.fn.jquery);    console.log(_$10.fn.jquery);    console.log($);</code></pre></li><li><p>jQuery插件添加</p><pre><code>1. 静态方法,直接在jQuery($)对象身上加    直接给$添加方法. 静态方法    (function ($) {             $.add = function (a, b) {            return a + b;        }    }(jQuery));    console.log($.add(10, 20)); // 302. 实例方法, 则是给jQuery的原型添加方法    (function($) {        $.fn.method = function(参数1,参数2...){            函数体: 要实现的功能;        }      }(window.jQuery))调用的话, 直接调用并传入对应的参数就可以了.....</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇内容是对jQuery和原生JS进行了对比和归纳,主要是总结一些jQuery的常用知识点…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>css中一些常用技巧的总结</title>
    <link href="http://yoursite.com/2018/12/02/css%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/02/css中的一些技巧总结/</id>
    <published>2018-12-02T02:53:33.000Z</published>
    <updated>2018-12-15T01:02:33.511Z</updated>
    
    <content type="html"><![CDATA[<p>关于平时个人用到的一些css常用技巧的记录,持续更新ing….<br><a id="more"></a></p><h1 id="css常用技巧总结"><a href="#css常用技巧总结" class="headerlink" title="css常用技巧总结"></a>css常用技巧总结</h1><h2 id="伪类元素实现标题两侧中间加横线"><a href="#伪类元素实现标题两侧中间加横线" class="headerlink" title="伪类元素实现标题两侧中间加横线"></a>伪类元素实现标题两侧中间加横线</h2><pre><code>h3 {    /* margin: 0 auto; */    font-size: 40px;    position: relative;}.line::before,.line::after {    position: absolute;    content: &quot;&quot;;    top: 50%;    background-color: red;    width: 10%; // 父盒子的宽度    /* width: 10px; */    height: 10px;}.line::before {    left: 40%;}.line::after {    right: 40%;}&lt;!-- 百分比的数值都是基于父盒子的基础上变化的 --&gt;</code></pre><h2 id="CSS实现单行、多行文本溢出显示省略号…"><a href="#CSS实现单行、多行文本溢出显示省略号…" class="headerlink" title="CSS实现单行、多行文本溢出显示省略号…"></a>CSS实现单行、多行文本溢出显示省略号…</h2><pre><code>单行:    overflow: hidden;    text-overflow:ellipsis;    white-space: nowrap;多行:    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 3;  // 行数</code></pre><h2 id="无依赖定位"><a href="#无依赖定位" class="headerlink" title="无依赖定位"></a>无依赖定位</h2><pre><code>给一个元素设置绝对定位时，定位的元素仍会保持在html结构位置，不占据空间;其实就是脱离了标准流,层级变高了;然后可以使用margin相对于自身原始位置定位该元素以实现各种功能.还可以使用relative相对于自己原始位置进行定位.logo {        position: absolute;         width: 20px;        height: 20px;        background: url(../image/.png);        margin: 10px 0 0 10px; // 两个方向来调控位置    }</code></pre><h2 id="伪元素实现在元素内设置部分样式"><a href="#伪元素实现在元素内设置部分样式" class="headerlink" title="伪元素实现在元素内设置部分样式"></a>伪元素实现在元素内设置部分样式</h2><pre><code>.logo::after {  content: &apos;&apos;;  &lt;!-- 居中 --&gt;  position: absolute;  left: 50%;  top: 50%;  transform: translate3d(-50%, -50%, 0);  width: 10px;  height: 10px;  border-radius: 50%;  box-shadow: 0 0 0 3px rgba(255, 0, 0, .5);  background-color: #f00;}</code></pre><h2 id="not-选择器使用"><a href="#not-选择器使用" class="headerlink" title=":not()选择器使用"></a>:not()选择器使用</h2><pre><code>nav li:not(:last-child) {    /* 更语义化一点, 最后一个li标签没有右边框作为分隔符 */    border-right: 1px solid #666;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于平时个人用到的一些css常用技巧的记录,持续更新ing….&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css常用技巧" scheme="http://yoursite.com/tags/css%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>js中对this的使用和理解</title>
    <link href="http://yoursite.com/2018/11/29/js%E4%B8%ADthis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/29/js中this的使用/</id>
    <published>2018-11-29T02:53:33.000Z</published>
    <updated>2018-11-29T13:00:23.827Z</updated>
    
    <content type="html"><![CDATA[<p>之前虽然知道this的指向是指向调用它的对象,要找this的指向,就看它所在的活动环境在哪里;但是在实际的应用中还是有i点模糊,这里做一个集中总结…<br><a id="more"></a></p><h1 id="探究this的本质"><a href="#探究this的本质" class="headerlink" title="探究this的本质"></a>探究this的本质</h1><p><strong>js中this的设计,跟内存中数据的存储有很大关系</strong></p><p>下面举两个例子:</p><pre><code>var obj = { foo:  5 };上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存堆里，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。{    foo: {        [[value]]: 5        [[writable]]: true        [[enumerable]]: true        [[configurable]]: true    }}此时，foo属性的值保存在属性描述对象的value属性里面。那么当foo的属性对应的值是一个函数时呢?var obj = { foo: function () {} };这时，引擎会开辟一块内存空间,将函数单独保存在里面，然后再将函数的地址赋值给foo属性的value属性。{    foo: {        [[value]]: 函数的地址        ...    }}由于此时函数是一个单独的值，所以它可以在不同的环境（上下文）执行。如下面的这个例子:var f = function () {};var obj = { f: f };f(); // 全局环境下执行, 相当于window.f()obj.f(); // obj 环境执行由于JavaScript允许在函数体内部，引用当前环境的其他变量。var f = function () {    console.log(x);  // 函数体里面使用了变量x。该变量由运行环境提供.};现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境....var f = function () {    console.log(this.x); // 函数体里面的this.x就是指当前运行环境的x}**看下面的示例会加深一下理解:**var f = function () {    console.log(this.x);}var x = 1;var obj = {    f: f,    x: 2,};// 全局下执行, window环境f() // 1// obj 环境执行obj.f() // 2</code></pre><h1 id="常见的使用场景"><a href="#常见的使用场景" class="headerlink" title="常见的使用场景"></a>常见的使用场景</h1><ul><li><p>全局环境</p><pre><code>全局环境使用this，它指的就是顶层对象windowfunction f() {    console.log(this === window);}f() // true; 此处其实相当于window.f(),只是省略了window</code></pre></li><li><p>构造函数</p><pre><code>构造函数中的this，指的是实例对象function Person(name) {    this.name = name;}var p = new Person(&apos;huhua&apos;); 每一个实例化出来的对象都会有一个name属性    console.log(p.name) // huhua</code></pre></li><li><p>对象的方法</p><pre><code>1.如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。// 不过这里有些地方理解起来会有点难,主要是搞清楚调用的方法是通过什么方式获取的下面举个例子:    var obj ={        foo: function () {        console.log(this);        }    };    obj.foo() // 我们都知道此时this指向的是obj 但是,我这里再做一下变化,this的指向也会发生变化    (obj.foo = obj.foo)() // this指向的是window    上面的代码相当于: (function () {                console.log(this);            })() // 相当于匿名函数的调用上面的代码可以这样理解: 在JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二;obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是上面这种情况是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境window。2.如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。举个栗子:    var a = {        p: &apos;Hello&apos;,        b: {            m: function() {                console.log(this.p);            }        }    };    a.b.m(); // undefined, 此时this指向的是a.b,不是a,所以不能调用对象a中的属性    // 所以只能把属性p放在b属性中    var a = {        b: {            m: function() {                console.log(this.p);            },            p: &apos;Hello&apos;,        }    };    var hello = a.b;    hello.m() // Hello</code></pre></li></ul><h1 id="this在使用时注意点"><a href="#this在使用时注意点" class="headerlink" title="this在使用时注意点"></a>this在使用时注意点</h1><ul><li><p>避免this的多层使用</p><pre><code>由于this的指向时动态变化的,所以在函数中要避免多层使用this指向,很容易搞混淆var obj = {    f1: function () {        console.log(this); // obj环境        var f2 = function () {            console.log(this); // 全局环境下执行, 匿名函数,指向window        }();    }}obj.f1(); // obj // window为了解决上面的问题,我们可以在外层声明一个变量来存储this的指向...var obj = {    f1: function () {        console.log(this); // obj环境        var that = this;   // 在外层声明一个变量指向this        var f2 = function () {            console.log(that);  // 内层引用外层变量that,也可以保存this的指向        }();    }}obj.f1();</code></pre></li><li><p>避免回调函数中使用this</p><pre><code>回调函数中的this往往会改变指向，最好避免使用。</code></pre></li></ul><h1 id="this的绑定方法"><a href="#this的绑定方法" class="headerlink" title="this的绑定方法"></a>this的绑定方法</h1><p>JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p><ul><li><p>call()</p><pre><code>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 func.call(对象, 参数1, 参数2...) // 适用于传入一个参数或者没有参数var n = 100;var obj = { n: 1 };function func() {    console.log(this.n);}func.call() // 100func.call(null) // 100func.call(undefined) // 100func.call(window) // 100func.call(obj) // 1func函数中的this关键字，如果指向全局对象，返回结果为100。如果使用call方法将this关键字指向obj对象，返回结果为1。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象还比如调用对象原型中的方法:    // 1.伪数组的排序(元素,下标, 长度),    var fake = {        // 指定如下属性,从0开始,长度length属性        0: 100,        1: 10,        2: 1,        3: 102,        4: 12,        5: 1220,        length: 6    }    Array.prototype.sort.call(fake, function(a, b){return a-b;}); // 直接在原数据上修改    console.log(fake); // [1,10,12,100,102,1220]</code></pre></li><li><p>apply()</p><pre><code>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...]) // 可以接受一个参数集合应用:找出数组最大值:    var a = [10, 2, 4, 15, 9];    var res = Math.max.apply(null, a);     console.log(res); // 15转化伪数组:    var fake = {        0: &apos;java&apos;,        1: &apos;javascript&apos;,        2: &apos;css&apos;,        3: &apos;html&apos;,        length: 4,    }        // 1.通过apply的传参特点    var arr = [];    arr.push.apply(arr,fake); // 直接在原数组上修改    console.log(arr); // [&apos;java&apos;,&apos;javascript&apos;,&apos;css&apos;,&apos;html&apos;]    var arr1 = [];    arr1 = arr1.concat.apply(arr1, fake); // 返回一个新数组,需要用变量接受    console.log(arr1);  // [&apos;java&apos;,&apos;javascript&apos;,&apos;css&apos;,&apos;html&apos;]还可以用来绑定回调函数...</code></pre></li><li><p>bind()</p><pre><code>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。举个栗子: 注释的请忽略    var counter = {    count: 0,    inc: function () {            // var count = 100;            this.count++;            // console.log(this.count);  // 这里打印undefined; 因为函数是在全局中调用,无法访问函数内的count        }    };    // var func = counter.inc;    var func = counter.inc.bind(counter);    func();    console.log(counter.count);  // 这里打印1,因为修改了this指向对象counter,可以访问内部属性</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前虽然知道this的指向是指向调用它的对象,要找this的指向,就看它所在的活动环境在哪里;但是在实际的应用中还是有i点模糊,这里做一个集中总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>js中闭包的理解</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/js中闭包的理解/</id>
    <published>2018-11-28T02:53:33.000Z</published>
    <updated>2018-11-27T11:45:29.484Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要深入去理解JS中的闭包…<br><a id="more"></a>  </p><h1 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么?"></a>闭包是什么?</h1><p>闭包的定义很简单：就是函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，此时函数 B 就被称为闭包。</p><pre><code>function A() {    var a = 1    function B() {        console.log(a)    }    return B;}var b = A();b()  // 此时函数外部可以访问函数内部的变量</code></pre><blockquote><p>闭包的本质就是一个函数,可以沟通函数内部和函数外部…</p></blockquote><h1 id="闭包示例"><a href="#闭包示例" class="headerlink" title="闭包示例"></a>闭包示例</h1><pre><code>示例1: function outer() {        var a = 1;        function inner() {            a++;            return a;        };        return inner;    };var res = outer()(); var res1 = outer()();var res2 = outer()();console.log(res,res1,res2); // 2, 2, 2; 三次调用都是不同的函数,每一次访问的都是内部重新声明的变量console.log(outer()); // 函数innervar func = outer();console.log(func(), func(), func()); // 2, 3, 4; 同一个函数访问了三次这个变量示例2:for (var i = 1;i&lt;=5;i++){    function outer () {        var num = i;        function closure () {            return num;        }        return closure;    }    console.log ( &apos;循环内&apos; + outer()());// 1,2,3,4,5}console.log (&apos;循环外&apos; +  outer()());// 6,</code></pre><h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><pre><code>// 1.延长变量的生命周期// 局部变量的生命周期：从执行函数开始，到函数执行完毕被回收    function outer() {        var a = 1;        function inner() {            console.log(a);        };        return inner;    };    var func = outer();    func(); // 1//闭包唯一弊端：会消耗内存资源//如何手动回收闭包内存：  变量名 = null;// 2. 设置权限// 定义一个匿名函数用person接受var person = function () {    //声明局部变量    var age = 38;    //使用闭包访问局部变量    function getAge () {        return age;    };    function setAge (value) {        if (value &gt; 0 &amp;&amp; value &lt;= 100){            age = value;        }    };    //返回一个对象，对象中存储2个闭包函数用于操作局部变量    return {        getAge:getAge,        setAge:setAge    }};var p1 = person();//得到闭包函数对象p1.setAge(-1);//修改无效p1.setAge(33);//修改有效console.log (p1.getAge());  // 33</code></pre><h1 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h1><pre><code>当我们需要创建独立的内存空间时，隔绝外部的环境,可以用到闭包(匿名函数自调用)    a.提供不同的作用域----可以避免全局变量污染    b.模块化的开发----不同的功能对应不同的作用域// 闭包实现斐波那契数列// 从定义出发, 一个函数嵌套另一个函数,内层函数访问外层函数的变量并返回自己    function outer() {        // 在外面定义一个数组用来存储        var arr = [1,1,0];        // 创建闭包函数        function inner(num) {            // num 表示斐波那契数列第几位数            if (num == 1 || num == 2){                return 1;            }            else {                for(var i = 2; i &lt; num; i++) {                    // 让数组第三位来存储斐波那契的计算位                    arr[2] = arr[1] + arr[0];                    // 将数组数据前推一位,让第三位来存储下一个计算位                    arr[0] = arr[1];                    arr[1] = arr[2];                };                return arr[2];            }        };         return inner;    };    console.log(outer()(10));  // 55    // 等价于上面    var func = outer();    console.log(func(10)); // 55</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要深入去理解JS中的闭包…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>js基础思维导图</title>
    <link href="http://yoursite.com/2018/11/27/js%E5%9F%BA%E7%A1%80%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/11/27/js基础思维导图/</id>
    <published>2018-11-27T02:53:33.000Z</published>
    <updated>2018-12-20T00:42:12.999Z</updated>
    
    <content type="html"><![CDATA[<p>一篇关于js基础的思维导图,虽然自己页总结了,感觉这个更好一点,这里是引用别人的…<a href="https://segmentfault.com/a/1190000011151972" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011151972</a><br><a id="more"></a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="https://i.imgur.com/hI7IgLn.gif" alt=""></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="https://i.imgur.com/KX3T1mT.gif" alt=""></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><img src="https://i.imgur.com/KcsykKX.gif" alt=""></p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p><img src="https://i.imgur.com/zEuI9GS.gif" alt=""></p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p><img src="https://i.imgur.com/aU4x1QQ.gif" alt=""></p><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p><img src="https://i.imgur.com/ATXVDSY.gif" alt=""></p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p><img src="https://i.imgur.com/leuQYL9.gif" alt=""></p><h2 id="正则操作"><a href="#正则操作" class="headerlink" title="正则操作"></a>正则操作</h2><p><img src="https://i.imgur.com/Exfsb7K.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇关于js基础的思维导图,虽然自己页总结了,感觉这个更好一点,这里是引用别人的…&lt;a href=&quot;https://segmentfault.com/a/1190000011151972&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000011151972&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js中隐式转换</title>
    <link href="http://yoursite.com/2018/11/26/js%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/11/26/js中的隐式转换/</id>
    <published>2018-11-26T02:53:33.000Z</published>
    <updated>2018-11-26T06:17:55.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了js中数据类型的隐式转换…<br><a id="more"></a>  </p><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>当运算符两边数据类型不一样的时候，编译器会自动将数据类型转换成一致之后再计算. </p><p>有如下几种转换情况:  </p><pre><code>1.其他数据类型转number: 算术运算符（+ - * /  %） 自增自减  关系运算符（&gt; &gt;= &lt; &lt;= == === != !==）2.其他数据类型转string：字符串连接符 +3.其他数据类型转boolean：逻辑非 ！</code></pre><p>这里以比较运算符<strong>==</strong>为例, 介绍会发生隐式转换的情况:</p><pre><code>1. 全等运算符： ===//严格匹配：不会类型转换，必须要数据类型与值完全一致console.log ( &quot;1&quot; === 1 );//fase2.相等运算符： ==// 非严格匹配：会类型转换，但是有前提条件,一起有五种情况    //2.1 x和y都是null或undefined :    /*规则：没有隐式类型转换，无条件返回true*/    console.log ( null == undefined );//true    console.log ( null == null );//true    console.log ( undefined == undefined );//true    //2.2 x或y是NaN : NaN与任何数字都不等    /*规则：没有隐式类型转换，无条件返回false*/    console.log ( NaN == NaN );//false    //2.3 x和y都是string，boolean，number    /*规则：有隐式类型转换，会将不是number类型的数据转成number */    console.log ( 1 == true );//true    (1) 1 == Number(true)    console.log ( 1 == &quot;true&quot; );//false   (1) 1 == Number(&apos;true&apos;)    console.log ( 1 == ! &quot;true&quot; );//false  (1) 1 == !Boolean(&apos;true&apos;)  (2) 1 == !true  (3) 1 == false  (4)1 == Number(false)    console.log ( 0 == ! &quot;true&quot; );//true    另外:        console.log ( Number ( undefined ) );//NaN        console.log ( Number ( null ) );//0    //2.4 x或y是复杂数据类型 : 会先获取复杂数据类型的原始值之后再左比较    /*复杂数据类型的原始值： 先调用valueOf方法，然后调用toString方法            * valueOf:一般默认返回自身        数组的toString：默认会调用join方法拼接每个元素并且返回拼接后的字符串    */    console.log ( [].toString () );//空字符串    console.log ( {}.toString () );//[object Object]    console.log ( [ 1, 2, 3 ].valueOf().toString());//‘1，2，3’    console.log ( [ 1, 2, 3 ] == &quot;1,2,3&quot; );//  (1)[1,2,3].toString() == &apos;1,2,3&apos;  (2)&apos;1,2,3&apos; == &apos;1,2,3&apos;    console.log({} == &apos;[object Object]&apos;);//true    //2.5 x和y都是复杂数据类型 : 只比较地址，如果地址一致则返回true，否则返回false    var arr1 = [10,20,30];    var arr2 = [10,20,30];    var arr3 = arr1;//将arr1的地址拷贝给arr3    console.log ( arr1 == arr2 );//虽然arr1与arr2中的数据是一样，但是它们两个不同的地址    console.log ( arr3 == arr1 );//true  两者地址是一样    console.log ( [] == [] );//false    console.log ( {} == {} );//false</code></pre><p>几个隐式转换的实例:</p><pre><code>// e:x和y都是复杂数据类型，比较地址console.log ( [] ==  [] );//false// [] 与右边逻辑非表达式结果比较//(1) [] == !Boolean([])   (2) [] == !true  (3)[] == false  (4) [].toString() == false  (5)&apos;&apos; == false   (6)Number(&apos;0&apos;) == Number(false)console.log ( [] == ! [] );//trueconsole.log ( {} ==  {} );//false// {} 与右边逻辑非表达式结果比较//(1){} == !{} (2){} == !true  (3){} == false  (4){}.toString() == false  (5)&apos;[object Object]&apos; == false  (6)Number(&apos;[object Object]&apos;) == falseconsole.log ( {} == ! {} );//false// 八种情况转boolean得到false: 0 -0 NaN undefined null &apos;&apos; false document.all()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了js中数据类型的隐式转换…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="隐式转化" scheme="http://yoursite.com/tags/%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于js中原型的理解</title>
    <link href="http://yoursite.com/2018/11/24/js%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/24/js中原型的理解/</id>
    <published>2018-11-24T11:39:26.000Z</published>
    <updated>2018-11-29T05:09:59.490Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要是记录一下对js中对于原型的理解…<br><a id="more"></a></p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>原型涉及到构造函数, 原型对象, 实例化对象三者之间的关系…</p><hr><ul><li><p>构造函数</p><pre><code>function Person (name,age) {    //(1)创建一个空对象： {}    //(2)将this指向这个空对象 : this = {}    //(3)执行构造函数赋值代码（完成对象的赋值）    this.name = name;    this.age = age;    this.sayHi = function () {        console.log(this.name + &apos;hello world&apos;);    };    //(4)返回这个对象};var man = new Person(&apos;huahua&apos;,18); 1.何为构造函数?    构造函数：首先，它是函数，并且任何的函数都可以作为构造函数存在，它的本质是初始化对象。    构造函数都是和new关键词一起使用的。 new就是在创建对象，从声明开始一共做了4件事(如上)，构造函数就是在为初始化的对象添加属性和方法(成员)2.构造函数的特点：    a:构造函数的首字母必须大写，用来区分于普通函数    b:内部使用的this对象，来指向即将要生成的实例对象    c:使用New来生成实例对象</code></pre></li><li><p>实例对象</p><pre><code>1.上面的 man 就是通过Person这个构造函数实例化出来一个对象,我们称为 **实例化对象**;何为对象的实例化呢? 2.在我看来就是给一个空对象添加了一些属性和方法,使其具有了一些特征和行为...也就是上面new关键字干的事;跟面向对象中的一些概念比较类似...面向对象编程: 面向对象就是对现实中的事物进行抽象化...然后再给其设置特征属性和行为使之具体化; 面向对象就是对面向过程进行封装后的结果...3.实例对象中存在一个__proto__属性; 这个属性指向了构造函数的原型prototype...  注意: 实例对象访问成员的规则：先看自己有没有这个成员，如果有则访问，没有则访问原型的  </code></pre></li><li><p>原型对象</p><pre><code>上面已经聊过构造函数和实例化对象了,那么原型对象又是什么呢?    当我们在声明一个函数时, 系统会帮我们创建一个与该函数对应的属性prototype,我们称它为原型对象;    以上面的Person为例,这个prototype是该函数的一个属性,我们可以调用Person.prototype来修改其成员或者进行重写;    原型对象中有一个构造器指针constructor属性来指向对应的构造函数,他的作用是可以让实例对象知道自己是哪一个构造函数生成的;    如 man.constructor 即man.__proto__.constructor指向了 Person. </code></pre></li><li><p>下面用一张图来表示他们之间的关系…</p><p>  <img src="https://i.imgur.com/zltNIlG.jpg" alt=""></p><p>  原型对象中可以存储很多成员属性和方法,多个实例对象之间就能共享这些属性和方法; 类似实现了面向对象中 <strong>继承</strong> 的效果…</p><p>  <strong>面向对象的三大特性:</strong>  </p><pre><code>封装：将功能代码封装到对象中，只暴露外部接口(API),使用者无需关心内部实现继承：一个对象拥有另一个对象所有的成员变量(属性和方法)多态: 一个对象在不同情况下的多种状态; 一个对象经过不同操作后会有不同的行为....     (js从语法的角度上来说没有多态，因为js是基于对象的语言)js实现继承的方式:    1. 我们可以遍历父对象,将父对象的属性动态添加到子对象中 (适用于一个子对象的继承)        for (var key in father){            son[key]  = father[key];         };    2. 替换原型：将父对象作为子对象构造函数的原型(但是会丢失之前的原型对象的成员)         // 子对象用构造函数来实例化         function Son(name, age) {             this.name = name;             this,age = age;         }         Son.prototype.father = {             parent: &apos;laosong&apos;,             age: 47,         } // Son 原型对象中的成员         var son = new Son(&apos;xiaowang&apos;, 24)         var father = {             name: &apos;laowang&apos;,             age: 48,         }         Son.prototype = father; // 相当于Son的原型被重新赋值,替换了,laosong不在了    3. 综合上面两种情况: 将父对象的成员动态添加到子对象的原型中, 这样就不会丢失了        for (var key in father){            Son.prototype[key]  = father[key];         };        /**混合式继承封装        @param method:子对象的构造函数         @param father:要继承的父对象         */        function extendMehtd ( method,father ) {            for (var key in father){                method.prototype[key] = father[key];            }        };    4. 构造函数实现继承        // 通过更改this的指向来实现        function Person(name, age) {            this.name = name || &apos;hello&apos;;            this.age = age || 200;        };        function Stu(sex, name, age) {            this.sex = sex;            // 调用Person构造函数，修改Person中的this指向为当前Student这个构造函数中new创建的对象            // 继承Person中默认的初始化属性            Person.call(this, name, age);        };        var s = new Stu(&apos;male&apos;);        console.log(s); // age: 200,name: &quot;hello&quot;,sex: &quot;male&quot;</code></pre></li></ul><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><blockquote><p><strong>js中, 每一个实例对象都存在一个__proto__属性指向了自己的原型prototype; 但是原型本身也是一个对象,</strong><br><strong>也有自己的__proto__属性,指向自己的原型，以此类推就形成一个链式结构，称之为原型链…</strong></p><p>对象访问原型链中成员规则：<strong>就近原则</strong><br><strong>先看对象自己有没有，有则访问，没有则看原型有没有，有则访问，没有则看原型的原型有没有，以此类推…直到原型链的终点（null）;</strong><br>如果还没有 ：  <strong>如果是访问属性：则返回undefined   如果访问的是方法：则会报错   xxxx is not a function</strong></p></blockquote><ul><li><p>图解原型链</p><p>  以数组对象为例:</p><p>  <img src="https://i.imgur.com/R2wyeQf.png" alt=""></p></li><li><p>DOM中的原型链</p><p>  <img src="https://i.imgur.com/p9p92gl.png" alt=""></p></li></ul><h2 id="图解完整原型链"><a href="#图解完整原型链" class="headerlink" title="图解完整原型链"></a>图解完整原型链</h2><p><img src="https://i.imgur.com/xmwylPu.png" alt="JS中原型链完整图"></p><p>以上便是JS中完整的原型链图解了…</p><h2 id="关于对象的一些知识点补充"><a href="#关于对象的一些知识点补充" class="headerlink" title="关于对象的一些知识点补充"></a>关于对象的一些知识点补充</h2><pre><code>1.静态成员和实例成员    静态成员: 函数对象持有的成员(属性,方法)    实例成员: 构造函数实例化出来的对象持有的成员2.instanceof 关键字    语法: 对象 instanceof 构造函数    作用: 用来检测右边函数的原型 是否 在左边对象的原型链中(true/false)    如: Object instanceof Object // true3.Object.prototype(对象原型)    --所有对象的原型链中都会指向它;所以所有的对象都可以访问Object.prototype原型中的成员    常用几个成员:        1.hasOwnProperty(): 检查对象是否包含某个成员;            条件: 自己的成员        2.isPrototypeOf(): 检查(左边)一个对象是不是(右边)另一个对象的原型        3.propertyIsEnumerable(): 检查对象是否可以枚举某个属性            条件: （1）是自己的成员  （2）可以被for-in循环遍历 （自己的和原型的）    4.Function.prototype(函数对象Function的原型)    --所有的函数对象原型都会指向Function构造函数的原型,所有的函数对象都可以访问Function.prototype中的成员    常用的一些成员:        1. name:获取函数名 (比较鸡肋)        2.caller:获取调用本函数的引用;通过console.log(fn.caller)可以知道自己在哪个地方被人调用(全局调用函数,这里的caller指向null)        3.length：获取函数形参的数量; fun.length 可以知道函数设置的形参个数        4.arguments:获取函数所有的实参;             可以理解为函数内部一个隐藏的形参,作用是获取函数所有的实参，与形参一一对应...            arguments对象的两个常用属性:                1.callee:指向函数自身, 应用于匿名函数的递归调用...                  arguments.callee === fn //true                2. length: 实参的个数                  arguments是一个伪数组...        5.给内置的构造函数原型添加自定义成员            当内置构造函数自带的方法不够用，无法实现需求时,我们就需要给添加自定义方法;直接添加可能会出现多个人员操作出现相同的方法名,导致被覆盖掉了            所以需要采用安全的方法添加来避免覆盖...            使用替换原型继承(自定义构造函数，将原型指向内置对象)                // 通过构造函数的方式来添加;                function NewArr(name) {                    this.name = name;                };                NewArr.prototype = []; // 修改为一个空数组对象;此时NewArr的原型拥有数组对象所有的方法                NewArr.prototype.hello = {                    name: &apos;hello world&apos;,                };                NewArr.prototype.min = function () {                    var min = Infinity;                    for(var i=0; i&lt; this.length; i++) {                        if (this[i] &lt; min) {                            min = this[i];                        }                    };                    return min;                };                // 创建一个新对象                var arr1 = new NewArr(&apos;huhua&apos;);                var arr3 = new NewArr();                arr3.push(1,2,3,-1);                console.log(arr3.min());                console.log(arr1);                console.log(arr1.__proto__);                console.log(NewArr);                console.log(NewArr.prototype);                console.log(NewArr.__proto__.constructor);                var arr2 = [12,241,21];                console.log(arr2.min());  // 不能访问                Array.prototype：对象类型赋值的时候拷贝的是地址，修改了NewArr的原型之后，Array.prototype也会修改                []：  由于空数组的原型会指向Array.prototype，根据原型链中成员访问规则，NewArr实例对象可以访问数组成员的成员                      并且，修改MyArr的原型对象，本质上是修改这个空数组，不会对Array.protpotype造成影响</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要是记录一下对js中对于原型的理解…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>js程序设计读书笔记之BOM与DOM操作</title>
    <link href="http://yoursite.com/2018/11/20/js%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BBOM%E4%B8%8EDOM%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/11/20/js读书笔记之BOM与DOM操作/</id>
    <published>2018-11-20T01:19:13.000Z</published>
    <updated>2018-11-26T05:33:49.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录js中一些BOM与DOM的操作方法…<br><a id="more"></a></p><h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><p>关于JS操作文档内容,可以总结为网页元素的增删改查</p><h2 id="网页节点操作"><a href="#网页节点操作" class="headerlink" title="网页节点操作"></a>网页节点操作</h2><ul><li>查</li></ul><hr><p>所谓的查找元素, 可以理解为从文档中获取元素…  </p><ul><li>常用的网页元素获取方式  </li></ul><p><img src="https://i.imgur.com/uogEo0u.png" alt=""></p><ul><li>获取元素文本/元素内容   </li></ul><p><img src="https://i.imgur.com/veJihts.png" alt=""></p><ul><li>DOM节点</li></ul><p><img src="https://i.imgur.com/w1kYkxg.png" alt=""></p><ul><li>节点和元素的获取</li></ul><p><img src="https://i.imgur.com/K1UYjDV.png" alt="">  </p><ul><li><p>属性的获取  </p><blockquote><p>1.点语法</p></blockquote><p>  1-1 获取行内标准属性(不能获取行外属性和自定义属性)<br>  1-2动态添加属性和修改其值   </p></li></ul><blockquote><p>2.attribute语法 (<strong>应用场景1:tab栏切换效果</strong>)  </p></blockquote><pre><code>获取属性方法: 元素.getAttribute(&apos;属性名&apos;)  设置属性方法: 元素.setAttribute(&apos;属性名&apos;, 属性值)  2-1 可以获取行内标准属性和行内自定义属性(**常用**), 不可以获取行外和点语法动态添加的属性...</code></pre><ul><li>增</li></ul><hr><p>增加元素: 要思考增加哪些元素? 新创建的元素, 已存在的, 带子元素的父元素(已存在的元素只是移动,原来的位置消失)</p><pre><code>// 创建元素: document.createElement(&apos;标签名&apos;) var p = document.createElement(&apos;p&apos;) //传入标签名p.innerText = &apos;hello world&apos;;   // 传入相应文本box.appendChild(p);   //添加到想加入的父元素, 尾部插入// 插入元素 insertBefore(new, 父元素的子元素节点) 插入到父元素 ul2.insertBefore(ul1, li7); //还可以通过innerHTML赋值的方式来设置元素的内容,这个方法可以解析标签//innerText是获取文本,也可以设置文本; 它不能解析标签...</code></pre><ul><li>改</li></ul><hr><p>修改, 即替换子元素  </p><pre><code>// 插入元素 replaceChild(new, 父元素的子元素节点) 插入到父元素   ul2.replaceChild(ul1, li7); </code></pre><ul><li>删</li></ul><hr><p>即删除父元素下的子元素</p><pre><code>/ 移除子元素 removeChild(子元素)    // 只能自己移除自己的子元素    ul2.removeChild(li7);</code></pre><ul><li>注意</li></ul><hr><p>以上的增,删,改都是基于父元素的基础上来做操作!!!   </p><p><strong>一般父元素都是一个伪数组,我们在操作其子元素时,特别时for循环遍历使用时,别忘了数组的长度是会动态变化的,所以要注意循环增量的处理; 像比较常见的删除,循环加入到另一个元素中等等…</strong></p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM定义了一套操作浏览器窗口的API</p><h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><p>Bom对象主要由五大对象组成：</p><pre><code>window:浏览器核心对象location：包含当前页面的URL信息history：history对象主要用于记录你当前窗口的历史记录navigator：包含当前浏览器的信息，例如用的什么浏览器，操作系统版本等screen：获取用户电脑的屏幕分辨率(这个一般不用)</code></pre><ul><li><p>window对象 </p><pre><code>指的是当前浏览器窗口，它是JS中的顶级对象(所有全局变量都是它的属性)他有一个特殊的属性name; 无论怎么赋值,都是一个字符串...  1.常用的方法    open():打开一个窗口 params:URL,默认_blank,特征大小,true/false, 返回值:新打开的window对象...    close(关闭对象):关闭一个窗口, window.open(&quot; &quot;,&quot;_self&quot;).close();防拦截2.window对象的三个事件    1.window.onload:界面上所有的内容加载完毕之后才触发这个事件    2.window.onbeforeunload:界面在关闭之前会触发这个事件//常用来存储重要的数据    3.window.onunload:界面在关闭的那一瞬间会触发这个事件</code></pre></li><li><p>location对象  </p><pre><code>包含当前页面的URL信息1.打开新网页：location.assign(&apos;你要打开的新网页的url&apos;)  2.替换当前网页：location.replace(&apos;要替换的网页url&apos;)  3.刷新当前网页: location.reload() //刷新</code></pre></li><li><p>history对象</p><pre><code>history对象主要用于记录你当前窗口的历史记录主要作用就是前进和后退网页（相当于浏览器的左上角前进后退按钮功能）history.forward():前进history.back():后退</code></pre></li><li><p>navigator对象</p><pre><code>navigator对象：包含当前浏览器的信息工作中应用场景：用户信息统计（统计我这个网站平台的用户群体分布，什么浏览器，windows什么版本等）//使用场景：判断用户当前使用哪种浏览器if(navigator.userAgent.indexOf(&apos;Chrome&apos;) != -1){console.log ( &quot;谷歌浏览器&quot; );}else if(navigator.userAgent.indexOf(&apos;Firefox&apos;) != -1){console.log ( &quot;火狐浏览器&quot; );}else{console.log ( &quot;IE浏览器&quot; );//也有可能是其他小众浏览器，可以忽略不计}</code></pre></li></ul><h1 id="动画部分"><a href="#动画部分" class="headerlink" title="动画部分"></a>动画部分</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul><li><p>setInterval</p><pre><code>1.一旦创建立即计时，必须要手动停止，否则会无限的每隔一段时间执行代码2.创建定时器：setInterval(函数,时间间隔)    1.返回这个定时器的id    2.时间间隔的单位是毫秒    3.每隔一段时间就会执行函数中的代码3.移除定时器：clearInterval(定时器id)4.常用案例      电商网页上的秒杀时间, 时钟, 电子表等...动画的实现也是依靠定时器来完成的...</code></pre></li><li><p>setTimeout(函数,时间间隔)  </p><pre><code>与setInterval唯一的区别就是这个定时器只会执行一次，之后会自动移除</code></pre></li></ul><h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><pre><code>1.结构上: 一个盒子包含着一个ul标签,嵌套多个浮动的li标签(每个里标签中放一张图片);还包括两个切换键, 多个页码显示键...2.实现思路: 基于需求出发, 盒子中只显示当前图片, 鼠标移入切换键显示;点击切换键会往左或往右切换图片,在实现以上手动轮播功能后加入定时器实现自动轮播...3.代码实现: 从交互事件出发, 分析需求实现的步骤...足以实现功能分析过程:    第一步:鼠标移入盒子,切换键显示,移出则消失:            父盒子.onmouseover/onmouseout    第二步:设置一个全局变量index来给每个图片添加编号,             给切换键绑定事件,点击下一张则编号+1,上一张则编号-1                next.onclick; 则index++                pre.onclick; 则index--        这里完成上下页切换时要注意几点:                因为ul是由若干个图片浮动成一行显示的;所以超出的部分给父盒子设置一个overflow:hidden来消除;                每次点击切换键时,ul会移动一张图片的宽度;每张图片都有编号,编号*图片宽度即为位移宽度;                盒子的宽度为真实宽度;**需要用offsetWidth来获取**; 位移方式我们用定时器来做;                最后,ul的移动还需要设置边界检测...注意第一页和最后一页的处理;                同时还要完成页码的高亮显示(排他思想实现...添加自定义属性值,然后与图片编号对比)    第三步:         手动无限轮播:             这里主要是处理第一张图片和最后一张:                下一页:手动设置ul的位置为第一张;重置index的值...                上一页:手动设置ul的位置为最后一张图片的位置;重置index的值为最后一张的索引...                同时,因为位置的变化时突变的;无法实现动画滑动的效果;这里需要做一个视觉欺骗的效果;                给ul最后再添加一张图片来实现滑动效果...    第四步:        实现点击页码跳转到对应的图片,点击后动画移动对应的位移:-index*图片宽度    第五步:        自动无限轮播实现:            相当于每隔一段时间,自动触发点击下一页的功能            这里可以将轮播部分代码封装成一个函数,放在定时器中,每隔一段时间执行此函数,鼠标移入停止轮播;            即清除定时器;移出后启动定时器...</code></pre><h2 id="缓动动画"><a href="#缓动动画" class="headerlink" title="缓动动画"></a>缓动动画</h2><p>缓动动画可以理解为元素某些属性的渐变效果,实现元素属性值非匀速的变化,使元素在视觉上给人一种缓慢变化的感觉</p><ul><li><p>缓动动画的核心思想</p><pre><code>1. 开启定时器2. 获取需要改变的属性值3. 每次的变化值(我习惯叫做 步长step) = (目标值 - 当前值)/10 //核心公式4. 判断变化方向(正/父)// 正:步长向上取整; 负:步长向下取整5. 改变元素的属性值(重新赋值) // 注意有些元素的单位  要做+ &apos;px&apos;处理6. 终点检测// 当然以上步骤只是一个大概的步骤, 下面再来补充...</code></pre></li><li><p>缓动动画注意点</p><pre><code>1.缓动动画要求我们动态地改变元素的属性值,要做到多个元素复用,必须要封装...2.函数参数处理:     2-1元素的属性和值用对象来储存    2-2属性值的获取: 使用window.getComputerStyle()来获取//需要做兼容IE8                    // 注意对象的点语法取值 和 字符串语法取值[&apos;str&apos;]    2-3属性分类处理: 如果定位层级zIndex,背景色这类瞬变的属性, 在遍历时进行判断后,直接赋值                   如果是透明度opacity这类0~1直接变化的属性, 需要单独进行放大缩小处理//parseFloat                   如果是宽高,垂直水平方向距离这类按一般步骤处理即可3.保证多个属性都达到目标值:    开关思想来实现; 在遍历参数加上一个开关,每次循环遍历一遍后进行判断,只要有一个属性没到目标值,就继续遍历,    直到所有属性都达到目标值4.回调函数callback    在动画结束后,我们可以在运行一个函数,来实现动画结束后的其他特效, 只需要往函数传入回调函数名即可    </code></pre></li><li><p>缓动动画示例代码</p></li></ul><pre><code>// 获取元素var box = document.getElementById(&apos;box&apos;);var btn = document.getElementById(&apos;btn&apos;);// btn绑定点击事件btn.onclick = function () {    // 同一盒子的不同属性用对象来存储    var ele_attrs = {        // 键值对: 键为元素的属性名, 值为移动的目标位置         top: 500,        left: 500,        width: 300,        height: 300,        zIndex: 2, //层级属性        opacity: 0.5, //透明度    };    // 回调函数的参数    var ele_attrs1 = {        backgroundColor: &apos;yellow&apos;,    }    // 这里传一个函数的引用即可    var callback1 = function() {        // alert(&apos;hello world&apos;);        animation_move(box, ele_attrs1)    }    animation_move(box, ele_attrs, callback1);};// 这里给动画函数再传一个函数参数: 用来执行此次动画结束后继续执行下一回调函数function animation_move(ele, attrs, callback) {    // 用定时器来完成缓动动画,先清除之前的定时器    clearInterval(ele.tid);    ele.tid = setInterval(function () {        // 定时器里用到的值都是attrs里面的, 我们要遍历传入的attrs对象        var flag = true;        for (var key in attrs) {            // 这里要对层级属性进行单独处理; 背景色也是..,            if (key == &apos;zIndex&apos; || key == &apos;backgroundColor&apos;) {                // 如果存在,则直接赋值...                ele.style[key] = attrs[key];            }             else if (key == &apos;opacity&apos;) {                // 透明度(0~1的小数)的数值要放大处理                var target = attrs[key]*100;                var cur = parseFloat(get_style(ele, key))*100;                 var step = (target - cur)/10;                step = cur &lt; target ? Math.ceil(step) : Math.floor(step);                cur += step;                // 赋值给对象,更新其属性值                ele.style[key] = cur/100;                if (cur != target) {                    flag = false;                }            }            else {               // 此时的目标位置相当于key对应的值, 我们取出来                var target = attrs[key]; // 对对象中的属性进行动画操作                var cur = parseInt(get_style(ele, key)); //带单位需转化                var step = (target - cur)/10;//存在小数                step = cur &lt; target ? Math.ceil(step) : Math.floor(step);                cur += step;                // 赋值给对象,更新其属性值                ele.style[key] = cur + &apos;px&apos;; //这里只能采用对象字符串的方法来赋值/取值                if (cur != target) {                    // 如果有一个元素没到达目标位置,让循环继续走, 直到每一个属性都走完                    flag = false;                }             }        };        if (flag) {            clearInterval(ele.tid);            // 这里要对函数进行判断            if (typeof callback == &apos;function&apos;) {                callback();            }        }    }, 50);};function get_style(ele, attr) {    //兼容性处理,能力检测,这里要使用window.getComputerStyle()    if (window.getComputedStyle) {        return window.getComputedStyle(ele, null)[attr];//对象的取值法    }else {        // IE8的方法        return ele.currentStyle[attr];    };};</code></pre><ul><li><p>旋转木马思路</p><pre><code>旋转木马实现: 将盒子中所有li元素的属性用数组存储,每次点击切换键,只需要交换li元素的属性, 然后动态的取改变每个li元素的属性值...主要代码:// 点击事件绑定arrRight.onclick = function () {    // 点击切换下一个li标签, 数组中的元素位置轮换,然后每个样式的属性都进行动态的变化    // 第一个样式放到最后一个位置    li_style.push(li_style.shift());    // 位置互换后,开始动态变化    for(var i=0; i&lt;ul1.children.length; i++) {        animation_move(ul1.children[i], li_style[i]);    };};arrLeft.onclick = function () {    // 点击切换下一个li标签, 数组中的元素位置轮换,然后每个样式的属性都进行动态的变化    // 最后一个样式放到第一个位置    li_style.unshift(li_style.pop());    // 位置互换后,开始动态变化    for(var i=0; i&lt;ul1.children.length; i++) {        animation_move(ul1.children[i], li_style[i]);    };};    </code></pre></li></ul><h2 id="元素的几个常用的坐标属性"><a href="#元素的几个常用的坐标属性" class="headerlink" title="元素的几个常用的坐标属性"></a>元素的几个常用的坐标属性</h2><p><strong>这里JS中各种宽高属性值的一些介绍</strong><br><a href="https://juejin.im/entry/582eb783d203090067037b70" title="JavaScript 中的各种宽高属性" target="_blank" rel="noopener">https://juejin.im/entry/582eb783d203090067037b70</a></p><ul><li><p>offset属性</p><pre><code>1.offsetWidth与offsetHeight：获取的是元素的实际宽高 = width + border + padding2.offsetParent:获取最近的定位父元素 （自己定位参照的父元素）3.offsetLeft:获取自己左外边框与offsetParent的左内边框的距离  offsetTop:获取自己上外边框与offsetParent的上内边框的距离</code></pre></li><li><p>scroll属性</p><pre><code>1.scrollWidth和scrollHeight：元素内容真实的宽高(包括padding)2.scrollLeft和scrollTop：元素在滚动时超出内容区域的部分3.滚动事件:onscroll:元素的滚动条事件一般来说,我们经常会对浏览器整个页面进行滚动操作window.onscroll...如固定导航或者搜索框; 这里要注意元素脱标后的影响, 需要给下面的盒子加margintop值页面获取的方式(存在兼容性):      谷歌/火狐 ： window.pageXOffset （左） window. pageYOffset（上）    IE浏览器： document.documentElement.scrollLeft/Top    某些情况下:document.body.scrollLeft/Top代码:    function getPageScroll(){        return {        scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0,        scrollLeft :  window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0        };    }</code></pre></li><li><p>client属性</p><pre><code>clientWidth/clientHeight：获取可视区域的宽高(可视内容+padding)clientTop/clientLeft:不常用，其实就是左边框border-left和上边框border-top属性的获取:    getClientSize = function (  ) {        return {        clientWidth : window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,        clientHeight : window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0,        }    }监听浏览器窗口变化的事件: window.onresize()//常用于判断终端设备界面大小, 响应式布局中常用到</code></pre></li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><img src="https://i.imgur.com/C2vXX6l.png" alt="">  </p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件对象event:当某一个事件被触发时,此时浏览器会记录触发时的某些信息， 例如你是在哪个位置点击的,浏览器把这些所有的信息放到一个变量中存储，这个变量的数据类型是对象，所以称之为事件对象.</p><ul><li><p>获取事件对象</p><pre><code>document.getElementById(&apos;box&apos;).onclick = function ( e ) {//IE8及之前用window.event获取，可以用逻辑或的短路运算解决浏览器兼容性问题e = e || window.event;console.log (e);}</code></pre></li><li><p>事件对象中的三大坐标</p><pre><code>//事件对象里面的常用的三个坐标var box = document.getElementById(&quot;box&quot;);box.onclick = function (e) {e = e || window.event;//电脑屏幕的左上角console.log(&quot;e.screenX:&quot;+e.screenX+&quot;---e.screenY:&quot;+ e.screenY);//浏览器可视区域console.log(&quot;e.clientX:&quot;+e.clientX+&quot;---e.clientY:&quot;+ e.clientY);//页面的原点位置//浏览器兼容问题：IE8及之前不支持console.log(&quot;e.pageX:&quot;+e.pageX+&quot;---e.pageY:&quot;+ e.pageY);console.log ( getPagePoint ( e ).pageX, getPagePoint (e).pageY );}//pageX和pageY的兼容//pageX/Y坐标系相对于页面左上角，实际上就是界面滚定出去的距离 + 可视区域的距离function getPagePoint ( e ) {    e = e || window.event;//事件对象兼容    return {    pageX : e.pageX || getScroll().scrollLeft + e.clientX,    pageY : e.pageY || getScroll().scrollTop + e.clientY,    }}</code></pre></li><li><p>盒子拖拽注意点<br>以事件对象的pagex为基础出发,找到盒子移动的left和鼠标点击位置之间的关系…<br>另外,这是针对定位元素<br><img src="https://i.imgur.com/k305E5z.jpg" alt="">        </p></li></ul><p>另外,如果盒子带外边距,定位的元素会将外边距也算进去,所以在最后计算定位的left和top时,若要让鼠标的位置在内容区,需要减去margin值…<br>还有就是鼠标松开事件,要清除文档的鼠标移动事件…</p><ul><li><p>获取事件触发点相对于元素的位置</p><pre><code>在控制元素的某些移动效果时,针对定位的元素,我们一般都是去修改其定位的属性值;  如left,top来实现元素位置的动态变化,那么常用的几个坐标值会经常用到;    1.事件对象的坐标:        pageX, pageY 触发点相对页面的原点的值        clientX,clientY 触发点相对于浏览器可视区域的点的值    2.元素自身的一些属性值        三大属性值: offset,  scroll , client        两个方向: box.style.left, box.style.top //带单位的,以上都是不带单位的,所以最后赋值时要加px...</code></pre></li><li><p>事件冒泡</p><pre><code>1.事件冒泡：如果一个元素的事件被触发，该元素所有的父元素的同名事件会被依次触发冒泡的顺序: 元素 -&gt; 父元素 -&gt;body -&gt;html -&gt; document -&gt;window -&gt; null2.冒泡的优点:    应用场景: 当一个父元素的所有子元素(如ul&gt;li*5)都要注册同名事件时,只需要给父元素注册即可...    这里可以使用事件的一个属性来完成        **注意前提时获取事件对象e**         e.target : 事件触发源  (真正触发父元素事件的那个子元素) // IE8: e.srcElement            e.currentTarget : 与this一样的，不同点：currentTarget有浏览器兼容性，this没有         this:谁调用这个方法this代表谁3.冒泡的缺点    可能导致子元素与父元素出现事件冲突,影响需求;     如何规避:        // 注意先获取事件对象e        阻止事件冒泡:在子元素触发事件后,调用事件对象的e.stopPrapagation()方法...4.注册/删除多个同名事件    // 注册    addEventListener(&apos;事件类型&apos;,函数名, false/true)    // 事件类型不需要加on, 第三个参数默认为false:冒泡方式;true:事件捕捉    // 删除        removeEventListener(type, 函数名)** 这两个方法需要做兼容性处理&apos;&apos;&apos;/** @description 元素多个同名事件监听    * @param ele事件对象,即元素    * @param type,事件类型 (str)    * @param func,事件处理函数    * @return func的结果*/   function addEvent(ele, type, func) {    // 能力检测    if (ele.addEventListener) {    //执行函数    ele.addEventListener(type, func);        }    else if (ele.attachEvent) {    // IE8, 方法需要加on    ele.attachEvent(&apos;on&apos;+type, func);    }    else {    // 其他    ele[&apos;on&apos;+type] = func;    }};/** @description 元素多个同名事件移除    * @param ele事件对象,即元素    * @param type,事件类型    * @param func,事件处理函数    * @return func的结果    */function removeEvent(ele, type, func) {       // 能力检测    if (ele.removeEventListener) {    //执行函数    ele.addEventListener(type, func);    }    else if (ele.detachEvent) {    // IE8, 方法需要加on    ele.detachEvent(&apos;on&apos;+type, func);        }    else {    // 其他    ele[&apos;on&apos;+type] = null;    }};    </code></pre></li><li><p>事件捕捉</p><pre><code>1.事件捕获：如果一个元素的事件被触发，先从最顶级元素往下依次触发，直到目标元素window-&gt;document-&gt;html-&gt;body-&gt;父元素-&gt;元素2.只有一种方式注册事件才是捕获：addEventListener方式注册并且第三个参数为true3.1.事件三个阶段    1：捕获阶段    2：目标阶段    3：冒泡阶段 3.2.获取事件的阶段：  e.eventPhase3.3事件类型: e.type</code></pre></li><li><p>键盘事件</p><pre><code>1.键盘事件    键盘按下： onkeydown    键盘松开：onkeyup    键盘按下：onkeypress  2.获取键盘按键    e.keyCode  || e.char Code  ||  e.which    注意: 默认获取的是ASCII码 ： 键盘上每一个按键对应一个数字，这个数字就是ASCII码    另外:ASCII码转字符串:  String.fromCharCode ( ascii码 )  3.onkeydown和onkeypress（常用）的区别    onkeydown: (1)不区分大小写，大写   （2）不过滤特殊按键 （f1-f12 ctrk）    onkeypress: （1）区分大小写    2）过滤特殊按键4.如果是对本次操作进行取值 / 或者是循环注册多个事件; 一定要注意**this关键字**的使用!!!!!!!!</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录js中一些BOM与DOM的操作方法…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="BOM和DOM" scheme="http://yoursite.com/tags/BOM%E5%92%8CDOM/"/>
    
  </entry>
  
  <entry>
    <title>日常踩坑总结</title>
    <link href="http://yoursite.com/2018/11/15/%E5%89%8D%E7%AB%AF%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/15/前端踩坑总结/</id>
    <published>2018-11-15T00:31:30.000Z</published>
    <updated>2018-12-21T10:55:03.141Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要记录自己在前端三大基础HTML, CSS, JS学习过程中总结的一些注意事项,思维方向和自己习惯犯的一些错误及误区;<br>本文将会持续更新…等到积累一定数量的错误再几种做一下归纳分类…<br><a id="more"></a></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li>注意事项</li></ul><hr><pre><code>1.独立的组件或者内容尽量使用单独的DIV盒子来包裹;2.最外层父盒子类名 常使用container和wrap来设置;</code></pre><ul><li>踩过的坑</li></ul><hr><pre><code>1.在写网页结构时,有规律排列的标签可以采用ul&gt;li&gt;其他标签; 也可以使用dl&gt;dt&gt;dd&gt;其他的方式来实现; 如果考虑简洁性: 也可以直接用div&gt;其他标签(span||a...);</code></pre><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li>注意事项</li></ul><hr><pre><code>1.关于浮动    父元素未设置高度时,子元素浮动,不要忘记给父盒子清除浮动的影响;2.关于定位    定位的使用比较灵活,当标准流和浮动不容易实现其功能时,可以考虑用定位的方式来做;  3.关于布局    在写布局之前,先观察需求模板,抽离出公共部分将css写成一个可复用的组件,</code></pre><ul><li>踩过的坑</li></ul><hr><pre><code>1.居中方式    a. 居中元素定宽高适用        absolute + 负margin(自身尺寸的一半)        absolute + margin auto + (l t r b: 0)    b. 居中元素不定宽高        absolute(各50%) + transform: translate(各-50%)        lineheight: 父盒子高度        writing-mode: 竖直        flex, grid</code></pre><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li>注意事项</li></ul><hr><pre><code>1.预解析的作用: 主要能够将变量名和函数名提升当前作用域的最顶端,赋值和调用还是在原地;2.变量是用来存储数据的, 及变量指向数据所在的内存区域,不同的数据类型的存储方式不一样;    如基本类型存在栈中,变量的存储方式属于值引用;变量名的重新赋值,会销毁旧值...    复杂类型(对象)存在堆中, 变量的存储方式属于地址引用, 只是在栈中存储了数据的地址...3.函数的上下文调用模式    this的指向: 谁调用,指向谁...        三种情况下的this指向:             a. 指向window            b. 指向调用的对象            c. new构造函数 指向空对象    作用：可以动态修改函数中的this指向    call() apply() bind()异同点    相同之处：都可以修改函数中this指向, 第一个参数是一个对象    不同点：传参方式不同    call()语法： 函数名.call(this修改后的指向，arg1,arg2…………)    apply()语法：函数名.apply(this修改之后的指向,伪数组或者数组)    bind()语法：函数名.bind(this修改后的指向,arg1,arg2....)    bind()语法并不会立即执行函数，而是返回一个修改指向后的新函数,常用于回调函数</code></pre><ul><li>踩过的坑</li></ul><hr><pre><code>1.关于函数的应用    当遇到重复执行的代码块时, 注意使用函数封装起来: 函数封装要养成好的习惯:    a. 函数的注释(声明 函数的作用, 函数的参数, 以及返回值)    b. 函数名(起名尽量语义化)    c. 函数的参数(函数传参: 本质上是一个实参给形参赋值的过程, 一定要来清楚自己传的实参的数据类型(基本类型/复杂类型))    d. 函数体: 对传入的参数进行数据处理, 但是也可以接受函数外的全局变量参与数据处理,但是最好不用,这样函数的封装便失去意义啦;               可以在函数体声明局部变量来参与计算或者判断, 函数运行完会自动清除...      e. 函数的返回值:            return关键字: 返回函数体处理的结果,同时结束函数的生命;            注意: 很多时候,我们一个函数中会对参数的值做一些特殊情况的处理,返回特定的结果 || 返回空值!!!    f. 函数作为参数传递(传函数的引用: 函数名); 同样函数也可以作为返回值(后续再来补充此条内容...)2. DOM中的下拉框    a.下拉框select属于表单元素, 取文本值使用value属性...    b.select变为多选, 添加行内属性mutiple即可    c.下拉框中option的取值        select.value: 会取到被选中的option的value值，但是如果option没有value属性，取到的是文本，但是只要有value属性绝对取得是value，即便是空    d.下拉框中的option赋值:        会让某个option的value相等的被选中，如果没有value，会让某个option的文本相等的被选中，如果都没有，就没有被选中</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要记录自己在前端三大基础HTML, CSS, JS学习过程中总结的一些注意事项,思维方向和自己习惯犯的一些错误及误区;&lt;br&gt;本文将会持续更新…等到积累一定数量的错误再几种做一下归纳分类…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="html, css, js" scheme="http://yoursite.com/tags/html-css-js/"/>
    
  </entry>
  
  <entry>
    <title>js程序设计读书笔记之ECMAScript</title>
    <link href="http://yoursite.com/2018/11/10/js%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BECMAScript/"/>
    <id>http://yoursite.com/2018/11/10/js程序设计读书笔记之ECMAScript/</id>
    <published>2018-11-10T12:49:01.000Z</published>
    <updated>2018-11-11T02:59:49.494Z</updated>
    
    <content type="html"><![CDATA[<p>本片文章是关于js基础语法中的一些总结…<br><a id="more"></a>  </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript中数据类型分为基础数据类型和复杂数据类型</p><h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><blockquote><p>Number, String, Boolean, Undefined, Null, 平时使用的最多的是前三者…<br>下面注意几点:<br>当变量只有声明,没有赋值时(undefined); NaN:not a number,是一个不是数字的数值类型;</p></blockquote><p>基础数据类型之间可以通过内置的方法来进行转换,如Number(),String()…等等,还有一些通过运算符进行隐式转换方式,这里也不列举了,实在记不住可以查找一下手册…</p><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><blockquote><p>对象(object)类型,对象其实就是一组数据和功能的集合,比如array,object…等等</p></blockquote><p>数据类型的检测方法: typeof; instanceof; object.prototype.toString.call;这三种方式,返回值测试一下就知道了…</p><h2 id="js中的操作符"><a href="#js中的操作符" class="headerlink" title="js中的操作符"></a>js中的操作符</h2><p>与其他语言一样,js也有加减乘除取模等等这些操作符…</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>就是我们常用的加减乘除取模:<strong>+ - * / %</strong>; 这里主要说一下加号+, 当数值和字符串用加号作用时,会变成连接符, +prompt():这里有一个隐式转换..</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>就是我们平常所说的与或非;<strong> &amp;&amp;; ||; !</strong>  </p><h4 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h4><ul><li>赋值运算: var a=1; 将一个值赋值给变量a, 变量就是用来存储数据的,使用己得先使用var声明.</li><li>相等操作: == 值相等; === 全等</li><li>自增自减: i++先参与运算再自增1, ++i先自增1再参与运算,减法同理</li><li>逗号操作: 最后结果取最后一个表达式的结果</li><li>三元表达式: 相当于一个判断, 表达式 ? true:false</li></ul><blockquote><p>使用这些操作符时注意符号的优先级:<br>一般时逻辑优先, 然后*/%+-等, 适当使用括号可以提升优先级…</p></blockquote><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>判断条件,选择执行</p><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><blockquote><p>这里也不多说了, 三种使用情况,<br>1.单个判断if(条件){执行的语句}<br>2.if-else<br>3.if-else if- else if - else</p></blockquote><h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h4><pre><code>switch (表达式) {// 表达式的值与value要全等...case value_1:    表达式结果为value_1时,运行此句代码;    break;//跳出</code></pre><blockquote><p>表达式也可以是一个布尔值,只要value满足条件就可以执行…</p></blockquote><hr><p><strong>如果是判断一个范围,使用if; 如果是匹配值,则考虑switch</strong></p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句有while循环,do-while,以及for循环; 我们平时用的最多的还是for循环..这里主要说一下for循环吧…</p><pre><code>for (var i=0; i&lt;10; i++) {    alert(&apos;hello world&apos;);}执行顺序:    1.语句1,声明循环变量i,(只会执行一次)    2.语句2,通过语句2进行判断    3.若条件成立,则执行循环体;    4.再修改语句3的循环增量    5.再返回第二步,重新执行    6.直到语句2不成立,此时整个循环结束...</code></pre><blockquote><p>使用循环时, 先分析出事物重复的规律…必要时可以采用穷举法来模拟一下, 循环最主要的还是需要总结出规律; 然后确定好 <strong>循环终止条件</strong>; 最后在确定好<strong>循环的增量</strong>, 比如有时候是i++; 有时候是i+=一个数, 这个是具体规律而定…  </p></blockquote><p>循环的嵌套:</p><pre><code>外层循环跑一次,内层循环跑完循环的总次数:  外层次数 * 内层次数嵌套循环要找 内层循环条件 与 外层循环条件 之间的联系和规律,根据相关规律,来确定循环条件. 分析一下内,外层循环是分别是用来控制什么的...</code></pre><p>关于break和continue: break是完全跳出循环, continue是退出后继续从循环体顶部继续执行…<br><strong>循环中使用的标记法</strong> 在循环执行前设置一个条件, 在循环体中修改条件,来实现达到某一条件便退出循环…</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数的声明</p><p>  `语法结构: function function_name(形参…) {</p><pre><code>       函数体;};` </code></pre></li><li><p>函数传参<br>  实参 和 形参<br>  参数的传递属于值传递(引用了实参的值),是直接把值复制过去使用<br>  函数内修改形参对实参没有影响….</p><p>  形参与实参的数目问题:</p><pre><code>对于有传参需求的函数,只要有实参传递,函数运行不会报错,不传参数运行则会报错...</code></pre></li><li><p>函数的实例化<br>  1 将实现功能的代码写出来…<br>  2 将实现功能的代码包起来…<br>  3 将变化的数据,设置为参数…<br>  4 调用函数…<br>  5 接受函数的返回值 return xxx;</p></li><li><p>检测函数的类型<br>  1 typeof 函数名 // function<br>  2 函数名 instanceof Function // true<br>  3 object.prototype.tostring.call(函数名) // [object function]</p></li><li><p>匿名函数–没有名字的函数<br>  function (形参) {  </p><pre><code>函数体;  </code></pre><p>  };<br>  匿名函数的调用: (function (name) {</p><pre><code>console.log(name + &apos;hello world);</code></pre><p>  })(huhua);</p><p>  通过变量名来调用:  </p><pre><code>var func = function() {      xxxxxxxxxxx;  };  func(); // 调用即可  </code></pre><p>  通过!,+,-调用; 欺骗解析器,让解析器以为符号后面是一个函数表达式  </p><pre><code>!function (xxx) {             xxxx;  }(xxx);  </code></pre><p>  作用: 1.如果这个函数只用一次,可以使用匿名函数  </p><pre><code>2. 避免全局变量的污染  3. 匿名函数可以当作闭包来返回...</code></pre></li><li><p>arguments<br>  函数内部可以打印<br>  是一个伪数组, 有数组额长度,下标,但是没有数组的方法<br>  用来存放 函数参数的伪数组…  </p><p>  // js 函数重名会覆盖,没有重载机制<br>  // 重载: 可以通过调用者传入的参数的个数,数据类型,顺序不同来  </p><p>  // 用来模拟重载<br>  // 通过遍历arguments中的所有参数, 来进行相关操作.  </p></li><li><p>作用域<br>  即变量起作用的区域…  </p><p>  全局作用域: script标签中, 函数以外的区域都是全局作用域<br>  局部作用域: 函数内部…  </p><p>  JS中只有函数function才能分隔作用域========================  </p><p>  全局变量: 声明!!!在全局作用域的变量, 当程序结束时,会被内存回收<br>  局部变量: 声明!!!在局部作用域的变量, 当函数结束时,会被内存回收  </p><p>  规则声明:   </p><pre><code>var n1 = 10;  var n2 = 10;  </code></pre><p>  不规则声明:   </p><pre><code>var n1 = n2 = 10;  n2会提升为全局变量...  </code></pre></li><li><p>作用域链规则</p><p>  域解析: 先将当前作用域里的所有变量提升到作用域最前面,赋值语句留在原地…  </p><p>  1.当前作用域中,如果一个变量有声明,不管声明在前面还是后面,只会在<br>  这个作用域中寻找  </p><p>  2.在当前作用域中,如果一个变量没有声明,就近寻找, 如果没有则会报错</p><p>  3.在当前作用域中,如果修改一个变量,在当前作用域有声明,那么直接修改  </p><pre><code>如果没有声明,就往上一级找,直到找到全局变量  如果还没有,就提升自己为全局变量</code></pre></li></ul><h2 id="变量的类型问题"><a href="#变量的类型问题" class="headerlink" title="变量的类型问题"></a>变量的类型问题</h2><h4 id="基本数据类型-保存在栈内存中"><a href="#基本数据类型-保存在栈内存中" class="headerlink" title="基本数据类型(保存在栈内存中):"></a>基本数据类型(保存在栈内存中):</h4><p>如Undefined、Null、Boolean、Number 和 String  </p><ul><li>基本类型在内存中是独立的,相当于python中的不可变类型,不同的变量赋值同一个值系统都会新开辟一块内存空间去存储它,我们不能去修改它的属性,只能新开辟内存. 可以使用typeof来判断…</li></ul><p>这里的字符串还有很多种方法…</p><h6 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h6><pre><code>// concat 拼接字符串var str = &apos;hello&apos;;console.log(str.concat(&apos; world&apos;));// replace 替换console.log(str.replace(&apos;llo&apos;, &apos;he&apos;));// 转换大小写console.log(str.toLocaleUpperCase());// 获取对应下标的字符console.log(str.charAt(3));// 获取对应下标的ascii码console.log(str.charCodeAt(2));// 获取下标console.log(str.indexOf(&apos;l&apos;));// split 分割// 根据分隔符来转换层数组var str1 = &apos;hello world js css html&apos;;console.log(str1.split(&quot; &quot;));</code></pre><h4 id="引用类型-保存在堆内存中"><a href="#引用类型-保存在堆内存中" class="headerlink" title="引用类型(保存在堆内存中):"></a>引用类型(保存在堆内存中):</h4><ul><li><p>对引用类型的理解就是系统开辟一块内存空间用来存放一个对象,即:Object;  然后变量指向这个对象的指针(即标识),相当于python中的可变类型;我们可以在这个对象的基础上去修改它身上的属性,不用去新开辟内存. 可以使用 instanceof 来判断…</p><pre><code>引用类型详细分类:        对象类型(Object): var person = {name: huhua, age: 24, birthday: 27}; 可以通过person.name去访问对象的属性, 也可以给对象身上绑定一些方法        数组类型(Array): var arr = [&apos;hello&apos;, 1, &apos;文字&apos;];        时间类型(Date): var day = new Date(Date.parse(默认调用)), 传入时间格式的字符串                        var day1 = new Date(Date.UTC(2005, 4, 5, 17, 55, 55))                时间格式: 6/15/2018;  September 10,2018;        正则类型(RegExp): var exp = /正则的匹配项/g,i,m(全局,不分大小写,多行)        函数类型(Function): Function name(形参) { 函数体};                函数名是变量,可以作为参数来传递                函数作为值来传递                 也可以将函数作为另一个函数的结果来返回;                函数内部属性: arguments:主要用途是保存函数参数,有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数                             this:  引用的是函数据以执行的环境对象,谁调用它就指向谁</code></pre></li></ul><h2 id="数组类型详解"><a href="#数组类型详解" class="headerlink" title="数组类型详解"></a>数组类型详解</h2><h4 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h4><p>1.数组的声明方式<br>    1-1 构造函数的方式去声明<br>    arr = new Array();<br>    然后根据索引赋值</p><pre><code>注意:    Array(10) 当括号中只有一个数时,表示数组的长度1-2字面量声明 var arr = [];</code></pre><p>2.缩小数组长度,长度会被删除,而且不能恢复</p><p>3.数组的长度时动态变化的,length 自增1; 数组长度 = 下标数 + 1;<br>    比如:使用arr[i] = i时, i为数组的下标,长度会发生变化…<br>    使用 arr[arr.length] 来添加元素到数组中!!!!</p><p>4.数组的遍历<br>    for 循环遍历;<br>    for of; <code>for (var value of arr) {        document.write(value);    }</code> ;</p><h4 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h4><pre><code>1 检测数组检测数组的方法；instanceof操作符的问题是当开发环境引入多个框架存在多个全局环境的时候，会出现不同的Array构造函数，进而出现不同的结果。Array.isArray()这个方法很好的解决了这个问题。arrName instanceof Arrayvar array=[1,2,3];console.log(array instanceof Array) //trueArray.isArray(arrName)console.log(Array.isArray(array)) //true2 转换方法toString()：返回以逗号分隔拼接而成的字符串valueOf()：返回对象toLocaleString()：区别很小，如果是数组调用这个方法，那么数组的每一项都会调用这个方法alert(value)==alert(value.toString())var array=[1,2,3];var arrayToString=array.toString();var arrayValueOf=array.valueOf();var arrayToLocalString=array.toLocaleString();console.log(arrayToString);// 1,2,3console.log(arrayValueOf);//[1, 2, 3]console.log(arrayToLocalString);//1,2,33 栈方法 (LIFO:last in first out)ES数组类似于数据结构的方法栈是一种限制插入和删除项的数据结构push()：接收任意数量的参数添加至数组尾部，返回数组长度值pop():从数组末尾移除最后一项，减少数组的length值，返回该数组被删除的最后一项4 队列方法 (FIFO:first in first out)结合push()和shift()方法可以实现像队列一样使用数组使用unshift()和pop()可以从相反的方向模拟队列shift()移除并返回该数组的第一项；unshift()从数组前端添加任意个参数，并返回新数组的长度5 操作方法concat()复制原数组连接新数组形成新副本；var arr1=[&apos;q&apos;,&apos;w&apos;,&apos;e&apos;];var arr2=[&apos;h&apos;,&apos;u&apos;,&apos;o&apos;];document.write(arr1.concat(arr2)); //q,w,e,h,u,oslice() 有一个参数时，复制参数为起始位置到末尾的副本；有两个参数时，复制两个数字中间部分的数组项；如果参数是负数，复制用数组的长度加上负数值得到的两个参数之间的数组项；var arr3=[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];console.log(arr3.slice(1));//e,l,l,oconsole.log(arr3.slice(-4));//e,l,l,oarr3.slice(-4)===arr3.slice(1);//truesplice() 三个参数:分别对应起始位置，删除项的个数，替换项;通过对这三个参数的合理运用可以实现删除、插入、替换等操作。//从第一项开始删除两项var splice_arr1=[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];   console.log(splice_arr1.splice(1,2))//返回的是被删除的项组成的数组[&quot;e&quot;, &quot;l&quot;]   //从第二项后插入三项old   var splice_arr2=[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];   var removed=splice_arr2.splice(2,0,&quot;K&quot;,&quot;K&quot;);   console.log(splice_arr2);//[&quot;h&quot;, &quot;e&quot;, &quot;K&quot;, &quot;K&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]                 console.log(removed)//返回的是一个空数组   //替换   var removed=splice_arr3.splice(2,2,&quot;P&quot;,&quot;P&quot;);console.log(splice_arr3);//[&quot;h&quot;, &quot;e&quot;, &quot;P&quot;, &quot;P&quot;, &quot;o&quot;]console.log(removed)//返回的是被替换的值[&quot;l&quot;, &quot;l&quot;]6 位置方法返回索引值indexOf() 从前往后找lastIndexOf() 从后往前找// indexOf()  从前往后找// lastIndexOf()  从后往前找var index_arr=[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];var indexOf_arr=index_arr.indexOf(&apos;l&apos;);console.log(&apos;原数组:&apos;,index_arr)//原数组不变console.log(&apos;返回值:&apos;,indexOf_arr)//返回值是第一个查到位置的索引值2var index_arr2=[&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;];var indexOf_arr2=index_arr2.lastIndexOf(&apos;l&apos;);console.log(&apos;原数组:&apos;,index_arr2)//原数组不变console.log(&apos;返回值:&apos;,indexOf_arr2)//返回值是第一个查到位置的索引值37 迭代方法接收两个参数，一个是函数，另一个是运行该函数的作用域对象。第一个参数函数接收三个参数 数组项的值 item，值的位置 idnex ，数组本身 array7-1 every() //都是返回true则返回truevar numbers=[1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4];var everyArr=numbers.every(function(it, index ,arr){    if(it&gt;9){        return true;    }})console.log(everyArr);///false7-2 some()//有一个返回true，则返回truevar someArr=numbers.some(function(it, index ,arr){        return (it &gt; 9) ;})console.log(someArr);///true7-3 forEach()//没有返回值var numbers=[1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4];var forEachArr=numbers.forEach(function(it, index ,arr){    var it=it*100;    console.log(it)}) //无返回值7-4 filter()//返回该函数会返回true的项组成的数组，用于过滤var numbers=[1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4];var filterArr=numbers.filter(function(it, index ,arr){    if(it&gt;10){        return it;    }})console.log(filterArr);//[65, 33, 21, 23]//返回返回值组成的新数组7-5 map()//返回每个函数的返回值var numbers=[1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4];var mapArray=numbers.map(function(it, index ,arr){    var it=it*100;    return it;})console.log(mapArray)//[100, 200, 300, 400, 500, 600, 700, 800, 900, 0, 900, 800, 700, 6500, 500, 400, 3300, 2100, 100, 100, 2300, 300, 400]//返回返回值组成的新数组7-6 reduce()var numbers=[1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4];var allArray=numbers.reduce(function(prev,cur,index,arr){    return (prev+cur);})console.log(allArray);//229reduceRight()var numbers=[1,2,3,4,5,6,7,8,9,0,9,8,7,65,5,4,33,21,1,1,23,3,4];var allArrayRight=numbers.reduceRight(function(prev,cur,index,arr){    return (prev+cur);})console.log(allArrayRight);//229</code></pre><h2 id="对象的理解"><a href="#对象的理解" class="headerlink" title="对象的理解"></a>对象的理解</h2><pre><code>1.声明对象      构造函数的方式; 字面量声明, 内置函数初始化, 工厂模式...原型模式    声明完成后赋值上属性和方法...     对象的属性和方法都是绑定在对象身上的...2.this       作用: 哪个对象调用, this就会指向这个对象    在本身对象内使用(在自己的活动作域中)3.工厂模式创建对象      将对象创建的方式 封装 成一个方法    在函数中 var 一个 new object();    通过对象. 来绑定属性和方法....    return 出来...4.使用 new 关键字创建对象----构造函数的方式      创建函数, 使用this来绑定属性和方法      使用new创建对象所做的事情...      4-1 声明一个空对象      4-2 让 this 指向这个空对象, 可以绑定属性和方法      4-3 把参数赋值给这个对象      4-4 返回创建好的对象...      var hh = new get_stu(&apos;花花);    hh.say();    var qq = new get_stu(&apos;球球);    qq.say();    function get_stu(name) {        this.name = name;        this.say = function () {            console.log(&apos;你好啊&apos; + this.name);        }; // 每次创建一个对象都会创建一个function实例...没有实现共享的功能    };5.修改对象的属性      1. 点方法      person.name = &apos;修改值&apos;;    2. key值操作    person[&apos;name&apos;] = &apos;修改值&apos;;6.遍历对象      for (var k in object) {        console.log(k + &apos;:&apos; + stu[k]);    }    Object.keys() 返回一个由数组 由键名组成...7.对象身上绑定一个对象      var a = {        b: {            name: &apos;huhua&apos;,            age: 24,            bark: function() {                xxxxxxxxx;            },        },    };8.JSON对象// 键值对都带有双引号    json_obj = {        &quot;name&quot;: &quot;huhua&quot;,        &quot;age&quot;: 24,    }</code></pre><h2 id="关于构造函数-原型-实例之间的关系的浅理解"><a href="#关于构造函数-原型-实例之间的关系的浅理解" class="headerlink" title="关于构造函数, 原型, 实例之间的关系的浅理解"></a>关于构造函数, 原型, 实例之间的关系的浅理解</h2><pre><code>1.每个构造函数都有一个原型对象:     构造函数本身是一个对象, 有一个prototype属性(原型对象)     Function.prototype    这个属性也是一个对象...包含很多属性, 有一个指针属性constructor;2.原型对象都包含一个指向构造函数的指针:    Function.prototype.constructor === Function    原型对象有一个指针指向构造函数本身...3.实例都包含一个指向原型对象的内部指针。    Object.__proto__ === Object.prototype    对象实例,函数实例...都会包含一个__proto__指针指向原型对象原型链:     原理： 我们每次读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性，从对象的这个当前实例开始，如果找到这个属性就停止。     否则继续搜索它的原型对象，如果搜索到了属性就停止。仍然搜索不到，就搜索这个原型对象的上一级的原型对象，    直到Object.prototype,这个是所有对象的根原型对象，它的上一级是null。原型的问题:    对于共享的引用类型来说，改变其中一个，就会改变所有实例的这个属性。弊端:    我们不能通过对象实例重写原型中的属性。 只能是覆盖 屏蔽，因为原型链搜索会因此停止。</code></pre><h2 id="闭包浅理解"><a href="#闭包浅理解" class="headerlink" title="闭包浅理解"></a>闭包浅理解</h2><pre><code>在js中,函数内部调用其他函数,就创建了闭包...往往会使用函数中再套一个匿名函数来做这件事... function createFunctions(){             var result = new Array();        for (var i=0; i &lt; 10; i++){             result[i] = function(num){                             // 此处返回一个闭包,函数的作用域会在内存中一直保存到闭包不存在...                return function(){                                     return num;                                 };                         }(i);  // 此处闭包可以实现每个函数保存不同的num,变量暂时不会被回收...                              如果大量使用,则会消耗内存...占用系统资源,严重可造成内存溢出...            }         return result;     };    console.log(createFunctions());    console.log(createFunctions()[4]());</code></pre><p>所以使用闭包的使用既有好处,也有坏处, 适当使用就好….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本片文章是关于js基础语法中的一些总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>css一些基础性的总结</title>
    <link href="http://yoursite.com/2018/10/28/%E5%85%B3%E4%BA%8Ecss%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/10/28/关于css的一些总结/</id>
    <published>2018-10-28T06:35:00.000Z</published>
    <updated>2018-12-18T02:29:50.624Z</updated>
    
    <content type="html"><![CDATA[<p>关于css阶段性的学习总结…<br><a id="more"></a></p><h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><p>css选择器是用于对网页中的元素进行样式的控制，比如文字，背景，图片等等…  </p><ul><li>选择器的分类<br>用的比较多的是标签，类，id，像*，！important这些比较少用</li><li>复合选择器<br>后代选择器，交集选择器(li.name,提高元素控制精确度，少用)，并集选择器(,)，伪类选择器(a:hover/li:nth-child等…),子代选择器(li&gt;a)</li><li>注意: 在使用选择器作用某一个元素时，选择器不要太冗长，一般1-3个，对用属性相同的元素类名可以复用，还要注意复合选择器的权重和优先级。</li></ul><h2 id="css的三大特性"><a href="#css的三大特性" class="headerlink" title="css的三大特性"></a>css的三大特性</h2><p>继承，层叠，优先级 </p><ul><li>层叠性<br>  多个选择器(权重相同情况下)作用到同一标签，发生属性冲突，后来者居上</li><li>继承性<br>  存在嵌套关系的元素，子元素会继承父元素的部分属性<br>  特殊性（a标签的颜色，h标签的大小）</li><li>优先级<br>  继承 &lt; 通配符 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内式 &lt; ！important</li></ul><h2 id="css中的元素的显示模式"><a href="#css中的元素的显示模式" class="headerlink" title="css中的元素的显示模式"></a>css中的元素的显示模式</h2><ul><li>行内元素<br>一行显示多个，不能设置宽高；如标签span a ins strong del…..</li><li>块级元素<br> 单独占据一行，可以设置宽高；如标签div h p ul li…..</li><li>行内块元素<br> 具有以上两者的特点，一行显示多个，可以设置宽高；如标签img input……</li><li>模式之间的转化<br>可以通过display: inline block inline-block进行模式转化</li></ul><h2 id="css中常用的样式属性"><a href="#css中常用的样式属性" class="headerlink" title="css中常用的样式属性"></a>css中常用的样式属性</h2><ul><li>字体<br>大小，字体库，颜色，style，行高lh（文字居中的关键，也可调节多行文字的间距）</li><li>背景<br>bgc(可以写颜色名,rgb,rgba,注意transparent的使用)<br>尽量使用连写方式，bg：url 是否平铺 位置(可以是xy坐标，可以是方位) 颜色<br>注意：bga：fixed；下拉滚动条，背景不动  </li><li>插入图片和背景图片的区别<ol><li>插入图片 我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin</li><li>背景图片我们一般用于小图标背景 或者 超大背景图片  背景图片 只能通过  background-position</li><li>图片去除间隙方法：转为块级；vertical-align<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2>盒子的组成：内容，边框border，内边距padding（内容与边框的距离），外边距margin（盒子之间的距离）<br>margin，padding，border都有四边，属性连写顺序顺时针方向top right bottom left,页面布局中经常用到，学会合理的使用！！！</li></ol></li></ul><p><strong>对于盒子的理解：</strong><br>网页中的标签元素其实都可以看作一个盒子，我们可以把盒子看作是一个存放内容（图片，文本，链接…）的容器，这个容器有它的高宽，内容，还有和内容的间距，以及容器之间的间距。最常用的盒子：div标签</p><p><strong>盒子的真实宽高</strong> = content-width/height + padding + border   </p><blockquote><pre><code>盒子水平居中,这个在项目中经常用到，margin:0 auto 1.块级block  2.盒子有宽度width</code></pre></blockquote><p><strong>盒子常用属性和注意点：</strong>  </p><blockquote><pre><code>1.常用属性：宽高，边框，内边距，外边距，圆角，背景，overflow等等....2.注意点：2.1 padding和margin对行内元素不起作用2.2 避免垂直塌陷(上下盒子排布会取较大的margin)；包含塌陷(嵌套关系的盒子，子盒子设置mt会带偏父盒子，给父元素添加overflow或者mt)2.3 元素隐藏display:none，位置不保留2.4 文字在盒子中溢出显示    white-space:nowrap    text-overflow: ellipsis    overflow:hidden2.5 如何盒子水平方向内容经常变化，宽度不写死，用内边距撑开2.6 盒子的高度一般情况下也不宜写死，由内容来撑开</code></pre></blockquote><h2 id="关于浮动"><a href="#关于浮动" class="headerlink" title="关于浮动"></a>关于浮动</h2><p>浮动：给元素添加float属性，会使元素脱离标准流，浮动起来。。。  </p><p><strong>浮动的特点</strong>  </p><blockquote><p>  1-浮动的元素，实现了模式的转换（拥有了行内块的特点）<br>  2-浮动的元素，顺序与结构代码有关，依次排列。<br>  3-浮动的元素，脱离了标准流，层级比标准流高，会浮在标准元素之上,标准          流会去占据浮动元素的位置。<br>  4-浮动元素是顶部对齐。<br>  5-浮动的父元素会把子元素带跑<br>  6-浮动的子元素依旧会在父元素范围内<br>  7-如果浮动的元素前面有标准流，那么浮动元素只能在标准流之后浮动</p></blockquote><p><strong>浮动的影响和解决</strong><br>在项目中，我们使用嵌套盒子时，一般不会给父盒子设高度，当父盒子是标准流时，若子盒子又浮动起来，脱离了标准流，父盒子就会丧失高度，其他标准流的元素就会来占据他的位置，造成布局混乱。<br>解决措施：给父盒子清除浮动：高度法，单双伪元素法，添加overflow属性<br>        这里写一个单伪元素法,5个属性！！！<br>        .clearfix:after {<br>            content：”.”;<br>            display: block;<br>            clear: both;<br>            visibility: hidden;<br>            height: 0;<br>        }</p><h2 id="关于定位"><a href="#关于定位" class="headerlink" title="关于定位"></a>关于定位</h2><ul><li>相对定位<br>不会转换显示模式，没有脱离标准流，还会保留原来的位置，但是显示的层级会变高，一般用于配合绝对定位。  </li><li>固定定位<br>实现了模式转化，具有行内块的特点；脱离了标准流，不会占据标准流的位置；<br>位移参照物为body。</li><li>绝对定位<br>实现了模式转化，具有行内块的特点；脱离了标准流，不会占据标准流的位置；<br>位移参照物为最近的具有定位属性的父盒子。  </li><li>显示层级<br>定位 &gt;  浮动  &gt;  标准流</li></ul><h2 id="关于css-div布局"><a href="#关于css-div布局" class="headerlink" title="关于css+div布局"></a>关于css+div布局</h2><p>静态页面布局的一般步骤：  </p><ul><li>1.将网页先拆分纵向分布的大盒子  </li><li>2.再对大盒子进行逐级拆分  </li><li>3.选择合适的方式(<strong>标准流，浮动，定位</strong>)，先分析目标盒子的特征，比如是一行显示多个，还是多行显示，或者是混搭。  </li></ul><p>常用技巧：</p><ol><li>类似头部导航栏一行显示多个，可以采用ul&gt;li标签+浮动来做  </li><li>个别独立的小模块可以用一个盒子写好，直接定位过去。</li><li>图文组合在一个盒子中的，文字换行存在间距的用行高撑开比较好</li><li>logo的写法，a+背景图片</li><li>底部footer栏，dl+dt&gt;span + dd&gt;a,然后浮动</li><li>底部about栏，直接用标准流写比较好 a+|的形式</li><li>精灵图 修改背景图的bgp即可</li><li>版心布局</li><li>滑动门的原理，不定宽度，父子元素使用同一个背景图片，距离padding撑开。</li><li>暂时先写这么多。。。未完待续。。。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于css阶段性的学习总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>html相关知识点</title>
    <link href="http://yoursite.com/2018/10/17/html%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/10/17/html相关知识点/</id>
    <published>2018-10-17T07:53:15.000Z</published>
    <updated>2018-11-10T12:50:03.208Z</updated>
    
    <content type="html"><![CDATA[<p>关于html的一些总结。<br><a id="more"></a></p><h2 id="固定结构代码"><a href="#固定结构代码" class="headerlink" title="固定结构代码"></a>固定结构代码</h2><ul><li>快速生成：！+ enter</li><li>结构：根节点html（设置语言），头节点head（包含meta，link,style等标签元素）<br>，网页主体body。</li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>分类：单标签，双标签</li><li>关系：嵌套，并列</li></ul><h2 id="相关标签"><a href="#相关标签" class="headerlink" title="相关标签"></a>相关标签</h2><ul><li>h系列标签，标题，h1一般只有一个，用于主页中最重要的一个logo。</li><li>段落p，独自成行</li><li>水平线hr，换行br</li><li>布局标签div，块元素，独自成行，span，行内元素，一行显示多个</li><li>文本格式化：粗斜下划线删除线，strong，em，ins，del</li><li>图片：img，属性：src图片路径，alt，加载失败描述，title，鼠标悬浮，width，height控制大小</li><li>链接：a，属性：href=”跳转文件所在路径”(#表示空连接)，target=“_blank”保留本页面并跳转到另一页面，self不保留当前页面，当a链接较多时，可以使用base标签放在head标签中，<base target="_blank"></li><li>转义：&gt; &lt; &nbsp; 大于小于空格，其他可以查w3c手册</li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li>锚点定位，a标签中 href=”#某一标签的id属性值” </li><li>跨页面定位，href=”页面路径#id的属性值”</li></ul><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul><li>无序ul，下一级为li，li中可以嵌套其他标签</li><li>有序ol</li><li>自定义，dl，dt，dd</li><li>快速创建时可使用ul&gt;li*5；可同时创建多个</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>表格的结构：标题caption&gt;h3,表头thead&gt;tr&gt;th,表格数据tbody&gt;tr&gt;td;同样，表格的td单元格中可以放其他标签元素，像链接，图片，表单控件等等。</li><li>单元格中还可以再创建表格来存放其他元素</li><li>table：属性：border，cellspacing，cellpadding，width，height，align等。</li></ul><h2 id="常用表单控件"><a href="#常用表单控件" class="headerlink" title="常用表单控件"></a>常用表单控件</h2><ul><li>表单需要放在form标签内。<br><img src="https://i.imgur.com/QfgRjns.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于html的一些总结。&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>聊聊一段自学经历的感受</title>
    <link href="http://yoursite.com/2018/10/14/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/10/14/个人学习总结-一/</id>
    <published>2018-10-14T01:33:23.000Z</published>
    <updated>2018-11-10T12:50:19.138Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇博客的目的在于对之前几个月的python学习做一个阶段性的总结，当然在这几个月自学过程中确实踩了不少坑，不过令人欣慰的是，也收获到在编程道路上的一些学习经验和教训。<br><a id="more"></a></p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>在接触python这门语言之前，自己工作内容中涉及到的编程主要是plc编程，主要应用于自动化行业，用来控制机器人，非标设备，生产线的正常运转。但与互联网行业中软件编程是完全不同的概念。  </p><p>所以在最开始的学习阶段，我采用主要学习方式还是跟当初在学校时学习模式一样，一边看着视频教程，一边在笔记本上写笔记，花在敲代码的时间比较少。(这种学习方法也为后面埋下很多坑)，当时就是一直按照这种学习节奏，一般最开始学习新东西的时候积极性特别高，所以每天的下班的时间和周末的休息时间都用来学习，就这样断断续续的从三月份学到了六月份，把python的基础内容学完了。然后就跟领导提了辞职，说了一下自己的想法，领导人也挺不错的，马上就同意放人了。  </p><p>python相关岗位有web开发，爬虫，数据分析，自动化运维等方向，我当时觉得爬虫挺好玩的，通过运行自己写的程序能够把别人网站的数据爬下来，所以就打算往这个方向发展。之后就在GitHub上找了一些项目，想着自己把它实现一遍，然后写在简历上方便以后找工作。但是在后面写项目的时候，啥都写不出来，脑子一片空白，不知从哪里下手，当时我就意识到一定是自己得到学习方法出了问题。因为周围的同学要么是做java开发的，要么是前端开发，在python方面都没有经验，我也没人去交流，当时就想无头苍蝇一样，没有方向，后来还是一位好朋友的哥哥介绍了一位python方面比较精通的前辈给我认识，在跟他聊天的过程中，确实感觉到自己跟他差距很大，谈吐之间就体现出一个程序员的专业素养，从逻辑思维，对问题的认识深度，以及业务流程，职业发展方向的大局观上等各方面都可以反应出来。之后那个人帮我指出身上存在的一些问题。</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>之后我也对自身存在的一些问题做了一些总结。  </p><ul><li>1.学习模式上<br>写笔记学习的方式，效率真的太低，写10行笔记还不如在编辑器上敲上一行代码。个人认为比较有效的学习方法就是：先构建知识体系，框架，然后填充具体内容；在理解的内容的基础上一定要多注重实践，多敲代码才是正道。现在回想一下当初学习的时候，笔记写了100多张a4纸，感觉真的SB。</li><li>2.思维的转变<br>之前写代码不知道从何下手，没有头绪，发现自己的思维方式没有转变过来。要用编程思维去看待一个问题，以往工作模式很多都只是停留在事物，问题的表面，现在我们需要要用计算机的思维去看待一个问题。就是先将问题进行分解成小步骤，然后抽象成自己熟悉的模式，最后再设计这些步骤去解决问题。</li><li>3.思想的转变<br>之前很多代码都是跟着书上的内容敲出来的，结果前一秒把书一关，后一秒就不知道怎么敲了；作为一个程序员，一定要有自己独立的思考方式，要培养自己的逻辑思维能力，独立的去完成代码功能的实现。遇到需求或问题首先要学会自己主动去思考，解决问题，实在搞不定可以咨询别人，完全依赖书本或他人是完全万万行不通的。因为以后工作中是没人可以依靠的，可能工作以后遇到不懂问题我们依靠最多回事百度和Google。</li><li>4.做事要有明确的目标和方向  </li><li>5.定期对自己做一个自我反思。要清楚自己的定位。</li></ul><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><ul><li>既然选择了做技术，就一定学会自主，持续，高效的去学习新知识，互联网行业技术更新迭代的速度很快，不学习很快就被淘汰了。</li><li>多关注行业技术发展，优秀博文，与大牛交流。。。</li><li>加油！！！！！！   </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇博客的目的在于对之前几个月的python学习做一个阶段性的总结，当然在这几个月自学过程中确实踩了不少坑，不过令人欣慰的是，也收获到在编程道路上的一些学习经验和教训。&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统命令</title>
    <link href="http://yoursite.com/2018/10/10/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/10/Linux系统命令/</id>
    <published>2018-10-10T03:21:45.000Z</published>
    <updated>2018-10-10T03:59:37.789Z</updated>
    
    <content type="html"><![CDATA[<p>关于Linux系统的常用命令记录。<br><a id="more"></a></p><h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><ul><li>mkdir：创建目录，参数-p　　当需要创建父目录时创建父目录　　-v　　每次创建一个目录返回一个信息</li><li>ls：查看目录，参数-l　　长格式显示具体属性　　-d　　只查看目录本身　　-a　　显示隐藏文件和目录　　-F　　显示结果加上对应结束符　　-r　　降序排序　　-t　　按修改时间排序　　-h　　显示占用的空间大小　　-i　　显示索引节点inode节点号　　–time-style　　格式化时间(–time-style=long-iso)</li><li>cd：切换目录</li><li>pwd：显示当前目录的绝对路径，参数-L　　显示系统变量PWD的值，为逻辑路径，默认使用该参数　　-P　　显示物理路径，链接文件会显示其指向的文件路径</li><li>mv：移动文件或目录到指定位置，移动目录时结尾不要加/</li><li>tree：以树形图形式显示目录结构，参数-a　　显示目录的所有内容　　-d　　只显示目录　　-L　　显示目录层级，可以接数字指定　　-f　　显示每个文件的完整路径　　-i　　不显示横线　　-F　　显示结果加上相应结束符</li></ul><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><ul><li>cat：查看文件内容，参数-n　　显示行号，特别用法：cat  文件1 文件2 &gt; 文件3   将文件内容上下合并并重定向到新文件中</li><li>touch：创建文件和更新时间戳，参数-a　　只更新访问时间　　-m　　只更新修改时间</li><li>vim：文本编辑器，由vi扩展而来，一般用于开发，有四种工作模式且每种模式有各自的命令集。</li><li>echo：输出指定字符串，参数-n　与下一个echo的输出在同一行显示　　-e　　支持转义字符(\t,\n等)</li><li>cp：复制文件或目录，参数-r　　递归复制　　-p　　保持文件或目录的属性　　-f　　强制复制　　-d　　如果源文件是链接文件则拷贝链接文件而不是其指向的目标文件　　-a　　相当于-rpd　</li><li>rm：删除文件或目录，参数-f　　强制删除　　-r　　递归删除，用于删除目录</li><li>grep：过滤结果，Linux三剑客之一，参数-i　　不区分大小写　　-v　　排除　　-E　　过滤多个关键词　　–color　　匹配结果显示颜色　　-n　　显示行号　　-o　　只显示匹配的内容　　-B　　显示匹配行及其之前的n行　　-A　　显示匹配行及其之后的n行　　-C　　显示匹配行及其前后各n行</li><li>head：获取文件头部指定多少行的内容，参数-n　　指定需要获取的总行数，可以简写为-2,-3等，默认获取前十行</li><li>tail：获取文件尾部指定多少行的内容，参数-n　　指定需要获取的总行数，可以简写，默认获取最后十行</li><li>sed：过滤结果，Linux三剑客之一，参数-n　　取消默认输出　　-i　　修改文件　　-e　　允许多项编辑　　-r　　使用扩展的正则表达式，功能参数p　　打印(^打印首行，$打印尾行)　　s　　替换　　g　　全局</li><li>awk：过滤结果，Linux三剑客之一，参数-F　　指定分隔符(指定多个分隔符需要将多个分隔符写在方括号中在方括号后跟上+号，如指定两个分隔符空格和冒号  [ :]+)，内置变量NR　　用于显示数据行的编号，可用于过滤文件，统计目录内的文件数等</li><li>cut：分割数据，参数-d　　指定分隔符　　-f　　指定获取分割结果的哪些位置的字段　　-c　　指定获取哪些位置的字符</li><li>stat：查看文件详细属性，参数-c　　以指定的格式输出(%a：获取文件的权限并以八进制数字显示，%A：获取文件的权限并以可读的方式显示)</li><li>nl：查看文件时显示行号</li><li>less：分页显示文件内容，参数-N　　显示行号</li><li>more：分页显示内容，无法向前翻页</li><li>chattr：设置文件或目录的属性，参数-i　　设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容</li><li>tr：删除，替换，压缩标准输入中的字符，参数-d　　删除指定字符　　-c　　一般与-d参数配合使用删除指定字符外的所有字符　　-s　　指定字符如果重复出现则只显示一个　</li><li>rename：文件重命名</li><li>rev：将字符串的第一个字符和最后一个字符位置互换</li><li>tac：将文件内容按行上下位置互换</li><li>split：用于切割文件内容，命令格式split 被切割的文件 新文件的文件名前缀，参数-l 　　指定文件切割的行数　　 -a 　　指定新文件后缀长度 　　-b 　　指定文件切割的大小(单位K、M。。。) 　　-d 　　使用数字后缀</li><li>paste：用于将两个文件的内容合并，命令格式paste 文件1 文件2，将文件左右合并，参数-d 　　指定文件内容之间的分隔符 -　　s　　 一行内容以一列的形式显示</li><li>dos2unix：将Windows文件格式转换为unix文件格式</li><li>diff：比较文件或目录的不同，结果中a为add c为change d为delete</li></ul><h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><ul><li>ifconfig：查看服务器网卡信息，参数-a　　显示所有网卡信息</li><li>ifdown：禁用指定网卡</li><li>ifup：启用指定网卡</li><li>ip：一般用于查看网卡和路由信息，用法ip  addr查看网卡信息　　ip  route查看路由信息</li><li>netstat：查看端口状态，参数-a　　显示所有开启的端口　　-n　　以数字形式显示　　-t　　只显示TCP连接　　-p　　显示进程名　　-l　　只显示监听状态的端口</li><li>ping：检测与指定IP间是否连通，参数-t　　Ping 指定的IP直到中断　　-n　　指定ping包个数　　-a　　将IP解析为主机名　　-l　　指定ping包大小，最大值是65,527字节　　-w　　ping的超时时间</li><li>mtr：路由追踪，参数-s　　指定数据包大小　　-n　　不做域名解析　　-a　　指定发送数据包的IP(服务器有多个IP时使用)　　-i　　指定ping的时间间隔，单位秒　</li><li>telnet：检测远程主机端口连通性，用法telnet　　IP　　端口</li><li>nmap：检测远程主机端口开放情况，用法namp　　ip</li><li>route：查询与设置路由信息，参数-n　　以数字形式显示　　-f　　清空路由　　add　　添加路由信息　　del　　删除路由信息　　-net　　目标网络　　-host　　目标主机　　netmask　　目标网络的子网掩码　　dev　　指定路由生效的网卡　　default　　默认路由　　gw　　设置网关　　　reject　　屏蔽的路由</li></ul><h2 id="用户与用户组相关命令"><a href="#用户与用户组相关命令" class="headerlink" title="用户与用户组相关命令"></a>用户与用户组相关命令</h2><ul><li>useradd：新建用户账号，参数-c　　添加注释信息　　-U　　指定用户组　　-u　　指定UID　　-d　　指定家目录　　-e　　指定账号失效时间　　-g　　指定GID　　-G　　指定附加组　　-M　　不创建家目录　　-s　　指定shell环境</li><li>userdel：删除账号，参数-r　　删除该账号下所有文件和信息</li><li>usermod：修改账号属性，参数-l　　修改用户名　　-L　　锁定账号　　-U　　解锁账号</li><li>chage：修改密码有效期，参数-l　　列出密码有效期信息　　-E　　指定密码失效时间　　-I　　密码失效后多久锁定账号　　-m　　密码最短多久需要修改　　-M　　密码最长多久需要修改　　-m　　用户家目录不存在就创建</li><li>passwd：设置修改密码，参数–stdin　　从标准输入获取密码　　-d　　清除用户密码　　-l　　锁定账号　　-u　　解锁账号　　-S　　查看账号状态</li><li>id：查看用户ID</li><li>su：切换用户，用法su  -  用户名，不加用户名默认切换到root,参数-　 切换系统环境变量到当前用户下　　-c　　以指定用户身份执行单条命令</li><li>chmod：修改文件或目录的权限设置，参数-R　　权限设置对目录下所有文件和子目录生效</li><li>chown：修改文件或目录的属主</li><li>chgrp：修改文件或目录的属组</li><li>groupadd：增加用户组，参数-g　　指定GID</li><li>groupdel：删除用户组</li></ul><h2 id="打包压缩相关命令"><a href="#打包压缩相关命令" class="headerlink" title="打包压缩相关命令"></a>打包压缩相关命令</h2><ul><li>tar：打包命令，参数–exclude　　打包时排除指定文件　　-c　　创建归档文件　　-x　　解开归档文件　　-C　　指定释放目录　　-f　　使用归档文件　　-z　　使用gzip压缩和解压　　-j　　使用bzip2压缩和解压　　-v　　显示打包和解包的过程　　-t　　查看归档文件中包含哪些文件</li></ul><h2 id="搜索操作相关命令"><a href="#搜索操作相关命令" class="headerlink" title="搜索操作相关命令"></a>搜索操作相关命令</h2><ul><li>find：查询命令，命令格式find  查找的目标路径  参数  -exec  命令  {}\;，参数-type　　按类型查找，f文件,d目录,c字符,l符号链接,sSocket文件,b块设备　　-mtime　　按修改时间查找+n表示多少天之前修改的，n表示第几天修改的，-n表示多少天内修改的　　-！　　取反(需写在取反条件之前，如-！ -name ‘test.txt’)　　-name　　按名字查找　　-size　　文件大小(+nM|K　　大于nM，n　　等于nM,-n　　小于nM)　　-a　　表示左右条件同时满足　　-o　　表示左右条件满足一个即可　　-exec　　用于对查询结果做进一步处理 　　-delete　　删除，详细参数说明<a href="http://man.linuxde.net/find" target="_blank" rel="noopener">http://man.linuxde.net/find</a></li><li>which：查询扩展命令的绝对路径</li></ul><h2 id="命令帮助相关命令"><a href="#命令帮助相关命令" class="headerlink" title="命令帮助相关命令"></a>命令帮助相关命令</h2><ul><li>man：查询扩展命令的帮助信息</li><li>help：查询内置命令的帮助信息　</li></ul><h2 id="服务器信息相关命令"><a href="#服务器信息相关命令" class="headerlink" title="服务器信息相关命令"></a>服务器信息相关命令</h2><ul><li>top：查看系统实时运行状态信息，参数-H　　显示线程信息　　-p　　显示指定进程号的进程信息　　-u　　显示指定用户的进程信息　　-i　　指定刷新时间间隔，功能选项k　　杀死指定进程号的进程　　q　　退出</li><li>strace：跟踪显示进程的系统调用信息，参数-p　　显示指定进程的系统调用信息</li><li>uname：显示系统信息，参数-a　　显示所有信息　　-m　　显示操作系统位数　　-n　　显示主机名　　-r　　显示内核版本　　-s　　显示操作系统名称　　-p　　显示处理器位数</li><li>whoami：查看当前用户用户名</li><li>who：查看所有登陆用户的登陆信息</li><li>hostname：查看和临时设置主机名</li><li>runlevel：查看系统运行级别</li><li>dmesg：查看系统故障信息</li><li>env：查看系统环境变量</li><li>history：显示命令行历史记录，参数-c　　清空历史记录　　-d　　删除指定编号的命令行历史</li><li>hwclock：查看设置硬件时间，参数-w　　与系统时间同步　　-r　　显示当前硬件时间</li><li>date：查看设置系统时间，参数-s　　设置系统时间　　+时间日期格式　　以指定格式显示时间，date命令详细说明</li><li>ulimit：查看和修改系统限制，参数-a　　显示系统所有限制信息　　-n　　查看或设置系统最大可用文件描述符(ulimit  -n  65535)　　</li><li>dumpe2fs：查看文件系统信息</li><li>df：查看磁盘空间以及inode节点使用信息，参数-h　　可读的格式显示大小　　-i　　显示inode信息</li><li>du：查看目录或文件占用的空间大小，参数-s　　只显示指定目录占用空间的大小总和　　-h　　以可读的方式显示大小</li><li>lsof：列出被进程调用的文件的信息，一般用于查看某个端口是否已启用，参数-i　　列出符号条件的进程(4即ipv4，6即ipv6，协议，:端口，@IP)，详细参数说明<a href="http://man.linuxde.net/lsof" target="_blank" rel="noopener">http://man.linuxde.net/lsof</a></li><li>last:显示用户最近登陆信息</li><li>lastlog：显示所有用户最近一次登陆信息</li></ul><h2 id="安全相关命令"><a href="#安全相关命令" class="headerlink" title="安全相关命令"></a>安全相关命令</h2><ul><li>sudo：使普通用户可以使用超出权限的命令，用法sudo  cmd,比如sudo  /etc/init.d/network restart，参数-l　　查看当前用户被授权执行的命令　　-v　　追踪最新的时间戳　　-u　　指定用户身份执行命令　　-k　　删除时间戳</li><li>visudo： 配置sudo权限的编辑命令，参数-c　　检查配置文件语法是否正确</li><li>getenforce：查看selinux运行级别</li><li>setenforce：设置selinux运行级别</li></ul><h2 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h2><ul><li>ps：查看当前服务器运行中的进程，参数-e　　显示系统所有进程　　-f　　以完整格式显示　　-a　　显示当前终端下的所有进程　　-u　　以用户为主的格式显示　　-x　　显示当前用户在所有终端下的进程</li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li>xargs：用于从标准输入获取内容，并将该内容作为后面命令的参数，主要用于将前面命令产生的多行结果合并为一行再让其后的命令进行处理，参数-n　　表示分组数，没有该参数默认在一行显示　　-i　　将标准输入的内容与{}关联起来</li><li>seq：生成数字序列，命令格式seq  参数  起始数字  步长  结束数字，参数-s　　指定分隔符，默认是换行符</li><li>sort：排序命令，参数-r　　降序排序　　-n　　按数值排序　　-k　　指定按第几列的数据排序　　-u　　排除所有重复行　　-t　　指定每列的分隔符</li><li>uniq：报告或排除重复数据，参数-c　　统计数据行重复次数　　-d　　只显示重复的数据行　　-u　　显示只出现一次的数据行</li><li>alias：查询和设置命令别名，命令格式alias  别名=‘命令’，直接执行alias可查询所有已设置的别名</li><li>unalias：取消别名，命令格式unalias  别名</li><li>rz：上传文件，该命令由包lrzsz提供</li><li>sz：下载文件，该命令由包lrzsz提供</li><li>init：修改系统运行级别</li><li>shutdown：关闭与重启系统，参数-h　　关机　　-r　　重启</li><li>halt：关机</li><li>reboot：重启</li><li>chkconfig：查看与设置开机启动服务，参数–list　　显示指定服务所有级别下的自启动设置，不加服务名显示所有服务　　–add　　将指定服务添加到自启动管理　　–del　　将指定服务从自启动管理中删除　　–level　　指定服务在哪些运行级别自启动，比如chkconfig  –level  35 mysqld on,该命令行不加–level参数表示mysqld服务在所有运行级别自启动</li><li>source：用于执行shell程序，shell程序中新建和修改的变量会影响当前shell环境，可以用.代替source</li><li>sh：用于执行shell程序，新建子shell环境并执行shell程序，shell程序中新建和修改的变量不影响当前shell环境</li><li>export：修改环境变量</li><li>mount：挂载设备，参数-t　　设备类型(iso9660：光盘或镜像，vfat：fat32设备，ntfs：ntfs设备，nfs：unix网络共享，cifs：Windows网络共享)　　-o　　挂载方式(loop：将文件作为磁盘分区，ro：只读，rw：读写，iocharset：指定访问文件系统所用字符集,例如iocharset=utf8，remount：重新挂载)</li><li>umount：取消挂载</li><li>ntpdate：网络时间同步，参数-u　　越过防火墙与时间同步服务器进行时间同步(ntp.api.bz，上海的时间同步服务器)</li><li>basename：获取路径中最后一个路径分隔符后的内容</li><li>dirname：获取路径中最后一个路径分隔符前的内容</li><li>file：查看文件类型</li><li>ln：创建链接文件，参数-s　　创建软链接</li><li>readlink：获取符号链接所指向的源文件文件名</li><li>md5sum：生成和校验md5值，参数-c　　从指定文件获取md5值并校验　　–status　　校验成功是不输出任何信息　　-w　　当校验不正确时输出警告信息</li><li>wc：参数-l 　　查看行数 　　-L 　　查看最长一行的字符数</li><li>tee：内容输出到屏幕同时重定向到指定文件中，参数-a 　　追加</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Linux系统的常用命令记录。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的一些优化</title>
    <link href="http://yoursite.com/2018/09/16/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/09/16/MySQL的一些优化/</id>
    <published>2018-09-16T10:46:55.000Z</published>
    <updated>2018-09-16T11:40:22.495Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL单表记录数过大时，增删改查性能都会急剧下降，我们可以采取一些措施来优化其性能。<br><a id="more"></a>  </p><h2 id="单表优化"><a href="#单表优化" class="headerlink" title="单表优化"></a>单表优化</h2><p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量.</p><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><ul><li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li><li>VARCHAR的长度只分配真正需要的空间</li><li>使用枚举或整数代替字符串类型</li><li>尽量使用TIMESTAMP而非DATETIME，</li><li>单表不要有太多字段，建议在20以内</li><li>避免使用NULL字段，很难查询优化且占用额外索引空间</li><li>用整型来存IP<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4></li></ul><p>创建索引<br>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><blockquote><pre><code>CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</code></pre></blockquote><blockquote><pre><code>修改表结构(添加索引)ALTER table tableName ADD INDEX indexName(columnName)</code></pre></blockquote><blockquote><pre><code>创建表的时候直接指定CREATE TABLE mytable(       ID INT NOT NULL,        username VARCHAR(16) NOT NULL,       INDEX [indexName] (username(length))      );  删除索引的语法DROP INDEX [indexName] ON mytable; </code></pre></blockquote><ul><li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li><li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫</li><li>值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段</li><li>字符字段只建前缀索引</li><li>字符字段最好不要做主键</li><li>不用外键，由程序保证约束</li><li>尽量不用UNIQUE，由程序保证约束</li><li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li></ul><h4 id="查询SQL"><a href="#查询SQL" class="headerlink" title="查询SQL"></a>查询SQL</h4><ul><li>可通过开启慢查询日志来找出较慢的SQL</li><li>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li><li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li><li>不用SELECT *</li><li>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</li><li>不用函数和触发器，在应用程序实xian</li><li>避免%xxx式查询</li><li>少用JOIN</li><li>使用同类型进行比较，比如用’123’和’123’比，123和123比</li><li>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</li><li>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</li></ul><h4 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h4><p>目前广泛使用的是MyISAM和InnoDB两种引擎：</p><p>MyISAM</p><p>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</p><ul><li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li><li>不支持事务</li><li>不支持外键</li><li>不支持崩溃后的安全恢复</li><li>在表有读取查询的同时，支持往表中插入新纪录</li><li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li><li>支持延迟更新索引，极大提升写入性能</li><li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li></ul><p>InnoDB</p><p>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</p><ul><li>支持行锁，采用MVCC来支持高并发</li><li>支持事务</li><li>支持外键</li><li>支持崩溃后的安全恢复</li><li>不支持全文索引</li></ul><p>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离.  </p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存可以发生在这些层次：</p><ul><li>MySQL内部：在系统调优参数介绍了相关设置</li><li>数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object</li><li>应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对<br>是数据传输对象Data Transfer Object</li><li>Web层：针对web页面做缓存</li><li>浏览器客户端：用户端的缓存</li></ul><p>可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：</p><p>直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。<br>回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</p><h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h2><p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码</p><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p><p><img src="https://i.imgur.com/4UenpUK.jpg" alt=""></p><p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上</p><p><img src="https://i.imgur.com/cRydn4u.png" alt=""></p><p>分区的好处是：</p><ul><li>可以让单表存储更多的数据</li><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li>分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备</li><li>使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li>可以备份和恢复单个分区</li></ul><p>分区的限制和缺点：</p><ul><li>一个表最多只能有1024个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>NULL值会使分区过滤无效</li><li>所有分区必须使用相同的存储引擎</li></ul><p>分区的类型：</p><ul><li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li></ul><p>分区适合的场景有：</p><p>最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</p><p><img src="https://i.imgur.com/49ATKFU.png" alt=""></p><p>查询时加上时间范围条件效率会非常高。</p><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联</p><p>比如原始的用户表是：</p><p><img src="https://i.imgur.com/tANr4Cp.jpg" alt=""></p><p>垂直拆分后是：</p><p><img src="https://i.imgur.com/DxH5uvc.jpg" alt=""></p><p>垂直拆分的优点是：</p><ul><li>可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)</li><li>可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起</li><li>数据维护简单</li></ul><p>缺点是：</p><ul><li>主键出现冗余，需要管理冗余列</li><li>会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力</li><li>依然存在单表数据量过大的问题（需要水平拆分）</li><li>事务处理复杂</li></ul><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表。  </p><p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决</p><p>前面垂直拆分的用户表如果进行水平拆分，结果是：  </p><p><img src="https://i.imgur.com/Uw3IfpV.jpg" alt=""></p><p>实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表。</p><p>水平拆分的优点是:</p><ul><li>不存在单库大数据和高并发的性能瓶颈</li><li>应用端改造较少</li><li>提高了系统的稳定性和负载能力</li></ul><p>缺点是：</p><ul><li>分片事务一致性难以解决</li><li>跨节点Join性能差，逻辑复杂</li><li>数据多次扩展难度跟维护量极大</li></ul><h4 id="分片原则"><a href="#分片原则" class="headerlink" title="分片原则"></a>分片原则</h4><ul><li>能不分就不分，参考单表优化</li><li>分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量</li><li>分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容</li><li>尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题</li><li>查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。</li><li>通过数据冗余和表分区赖降低跨库Join的可能</li></ul><p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p><p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p><p><strong>客户端架构</strong></p><p>通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现</p><p>这是一个客户端架构的例子：</p><p><img src="https://i.imgur.com/Agf5sLW.jpg" alt=""></p><p>可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现</p><p>客户端架构的优点是：</p><ul><li>应用直连数据库，降低外围系统依赖所带来的宕机风险</li><li>集成成本低，无需额外运维的组件</li></ul><p>缺点是：</p><ul><li>限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心</li><li>将分片逻辑的压力放在应用服务器上，造成额外风险</li></ul><p><strong>代理架构</strong></p><p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件</p><p>这是一个代理架构的例子：</p><p><img src="https://i.imgur.com/3qo732p.jpg" alt=""></p><p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理</p><p>代理架构的优点是：</p><ul><li>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强</li><li>对于应用服务器透明且没有增加任何额外负载</li></ul><p>缺点是：</p><ul><li>需部署和运维独立的代理中间件，成本高</li><li>应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险</li></ul><p>各方案比较：  </p><p><img src="https://i.imgur.com/lF4mQje.jpg" alt=""></p><p>如此多的方案，如何进行选择？可以按以下思路来考虑：</p><ul><li>确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构</li><li>具体功能是否满足，比如需要跨节点ORDER BY，那么支持该功能的优先考虑</li><li>不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持</li><li>最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择</li><li>选择口碑较好的，比如github星数、使用者数量质量和使用者反馈</li><li>开源的优先，往往项目有特殊需求可能需要改动源代码</li></ul><p>按照上述思路，推荐以下选择：</p><ul><li>客户端架构：ShardingJDBC</li><li>代理架构：MyCat或者Atlas</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL单表记录数过大时，增删改查性能都会急剧下降，我们可以采取一些措施来优化其性能。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy抓取装修图片</title>
    <link href="http://yoursite.com/2018/07/26/Scrapy%E6%8A%93%E5%8F%96%E8%A3%85%E4%BF%AE%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/07/26/Scrapy抓取装修图片/</id>
    <published>2018-07-26T12:35:00.000Z</published>
    <updated>2018-09-01T16:08:34.191Z</updated>
    
    <content type="html"><![CDATA[<p>scrapy框架也学了几天了，这次来试一下抓取360的家居装修图，加强对框架的理解和掌握。<br><a id="more"></a>  </p><h1 id="抓取分析"><a href="#抓取分析" class="headerlink" title="抓取分析"></a>抓取分析</h1><h2 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h2><p>目标站点定位： <a href="http://image.so.com/" target="_blank" rel="noopener">http://image.so.com/</a><br>打开浏览器后，我们在发现图片是通过发送Ajax请求加载的，所以我们直接找到对应的请求接口，然后访问，获取里面的json数据，数据中包含的图片的链接地址和其他信息，另外，我们拿到图片链接后，再去请求，便可以下载图片到本地。基本思路就是这样了。下面开始做吧。<br><img src="https://i.imgur.com/ZsIbFIH.png" alt=""></p><h1 id="url分析"><a href="#url分析" class="headerlink" title="url分析"></a>url分析</h1><p>寻找url规律：<br><img src="https://i.imgur.com/uA6x16d.png" alt=""></p><p>sn为偏移量，每页会显示30张图片，其他参数不变，那么我们可以构造一个参数字典，然后通过urlencode方法转成URL的格式，这样就构造出了需要访问的url。</p><h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>首先，创建项目，并生成一个Spider。</p><h2 id="编写items文件，确定抓取目标"><a href="#编写items文件，确定抓取目标" class="headerlink" title="编写items文件，确定抓取目标"></a>编写items文件，确定抓取目标</h2><p><img src="https://i.imgur.com/qvDOYkY.png" alt=""><br>这里，我们打算将图片信息放到mongodb和mysql中，先在这里定义集合和表名称，等会方便插入数据。  </p><h2 id="编写spider文件，生成数据和请求。"><a href="#编写spider文件，生成数据和请求。" class="headerlink" title="编写spider文件，生成数据和请求。"></a>编写spider文件，生成数据和请求。</h2><p><img src="https://i.imgur.com/REXVhXc.png" alt=""><br>这里，我们只要遍历json文件中的list字段就可以获取相应的信息。</p><h2 id="编写管道文件Pipeline，处理数据"><a href="#编写管道文件Pipeline，处理数据" class="headerlink" title="编写管道文件Pipeline，处理数据"></a>编写管道文件Pipeline，处理数据</h2><ul><li><p>存储到MongoDB<br><img src="https://i.imgur.com/foSb5dd.png" alt=""></p></li><li><p>存储到mysql<br>这里我们先提前在mysql中创建好相应的数据库和表，用来保存接下来的信息，这里就不多讲了。<br><img src="https://i.imgur.com/MWervfP.png" alt="">  </p></li><li><p>存储图片到本地<br>这里需要用到Scrapy专门处理图片的Pipeline，我们先定义一个当前目录下的文件存储路径 <strong>IMAGES_STORE = ‘.\images’</strong>,之后我们下载的图片会保存在这里。<br><img src="https://i.imgur.com/yJ1Fvgo.png" alt=""></p></li><li><p>setting文件配置<br>接下来我们需要配置setting.py里面的信息了。<br>数据库信息，设置最大抓取页数，请求头啥的。<br><img src="https://i.imgur.com/ZsksNAZ.png" alt=""></p></li></ul><p>管道文件<br><img src="https://i.imgur.com/xxEIa6B.png" alt=""></p><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p><img src="https://i.imgur.com/yDqIwWr.png" alt=""></p><p>这样，scrapy便开始下载图片和图片信息了，刚开始出现了几次报错，有参数的类型错误，还有初始化Mysql类属性时，命名造成了干涉等，导致后面方法报错。  </p><p>下面效果展示：<br>MONGO存储：<br><img src="https://i.imgur.com/au1ZCLy.png" alt=""></p><p>MySQL存储：<br><img src="https://i.imgur.com/NtIm5Me.png" alt=""></p><p>本地存储：<br><img src="https://i.imgur.com/AysaEQB.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scrapy框架也学了几天了，这次来试一下抓取360的家居装修图，加强对框架的理解和掌握。&lt;br&gt;
    
    </summary>
    
      <category term="scrapy" scheme="http://yoursite.com/categories/scrapy/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
  </entry>
  
</feed>
