<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AppleGuard的博客</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-25T07:54:28.705Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>huhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scrapy框架学习之入门案例</title>
    <link href="http://yoursite.com/2018/08/23/Scrapy%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/23/Scrapy框架基础学习/</id>
    <published>2018-08-23T12:50:37.000Z</published>
    <updated>2018-08-25T07:54:28.705Z</updated>
    
    <content type="html"><![CDATA[<p>Scrapy是一个用纯Python实现，为了爬取网站数据、提取结构性数据而编写的应用框架；我们只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。Scrapy 使用了Twisted多线程异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。<br><a id="more"></a>  </p><h1 id="Scrapy架构图"><a href="#Scrapy架构图" class="headerlink" title="Scrapy架构图"></a>Scrapy架构图</h1><p>——————————–<img src="https://i.imgur.com/vNUUr2S.png" alt=""></p><p>它可以分为以下几个部分：  </p><ul><li><strong>Scrapy Engine(引擎):</strong> 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。</li><li><strong>Scheduler(调度器):</strong> 它负责接受<code>引擎</code>发送过来的Request请求，并按照一定的方式进行整理排列，入队，当<code>引擎</code>需要时，交还给<code>引擎</code>。</li><li><strong>Downloader（下载器)：</strong>负责下载<code>Scrapy Engine(引擎)</code>发送的所有Requests请求，并将其获取到的Responses交还给<code>Scrapy Engine(引擎)</code>，由<code>引擎</code>交给<code>Spider</code>来处理。</li><li><strong>spiders（爬虫）：</strong>它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给<code>引擎</code>，再次进入<code>Scheduler(调度器)</code>。</li><li><strong>Item Pipeline(管道)：</strong>它负责处理<code>Spider</code>中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方.</li><li><strong>Downloader Middlewares（下载中间件）：</strong>你可以当作是一个可以自定义扩展下载功能的组件。</li><li><strong>Spider Middlewares（Spider中间件）：</strong>你可以理解为是一个可以自定扩展和操作<code>引擎</code>和<code>Spider</code>中间<code>通信</code>的功能组件（比如进入<code>Spider</code>的Responses;和从<code>Spider</code>出去的Requests）。</li></ul><h1 id="Scrapy的运作流程"><a href="#Scrapy的运作流程" class="headerlink" title="Scrapy的运作流程"></a>Scrapy的运作流程</h1><p>代码写好，程序开始运行…</p><ol><li><code>引擎</code>：Hi！<code>Spider</code>, 你要处理哪一个网站？</li><li><code>Spider</code>：老大要我处理xxxx.com。</li><li><code>引擎</code>：你把第一个需要处理的URL给我吧。</li><li><code>Spider</code>：给你，第一个URL是xxxxxxx.com。</li><li><code>引擎</code>：Hi！<code>调度器</code>，我这有request请求你帮我排序入队一下。</li><li><code>调度器</code>：好的，正在处理你等一下。</li><li><code>引擎</code>：Hi！<code>调度器</code>，把你处理好的request请求给我。</li><li><code>调度器</code>：给你，这是我处理好的request。</li><li><code>引擎</code>：Hi！下载器，你按照老大的<code>下载中间件</code>的设置帮我下载一下这个request请求</li><li><code>下载器</code>：好的！给你，这是下载好的东西。（如果失败：sorry，这个request下载失败了。然后<code>引擎</code>告诉<code>调度器</code>，这个request下载失败了，你记录一下，我们待会儿再下载）</li><li><code>引擎</code>：Hi！<code>Spider</code>，这是下载好的东西，并且已经按照老大的<code>下载中间件</code>处理过了，你自己处理一下（注意！这儿responses默认是交给<code>def parse()</code>这个函数处理的）</li><li><code>Spider</code>：（处理完毕数据之后对于需要跟进的URL），Hi！<code>引擎</code>，我这里有两个结果，这个是我需要跟进的URL，还有这个是我获取到的Item数据。</li><li><code>引擎</code>：Hi ！<code>管道</code>我这儿有个item你帮我处理一下！<code>调度器</code>！这是需要跟进URL你帮我处理下。然后从第四步开始循环，直到获取完老大需要全部信息。</li><li><code>管道`</code>调度器`：好的，现在就做！</li></ol><p><strong>注意！只有当</strong> <code>调度器</code> <strong>中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的URL，Scrapy也会重新下载。）</strong></p><h1 id="Scrapy-爬虫步骤："><a href="#Scrapy-爬虫步骤：" class="headerlink" title="Scrapy 爬虫步骤："></a>Scrapy 爬虫步骤：</h1><ul><li>新建项目 (scrapy startproject xxx)：在终端中执行命令，新建一个爬虫项目，会创建一个xxx文件夹</li><li>明确目标 （编写items.py）：明确你想要抓取的目标，定义爬取的数据结构</li><li>制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页</li><li>存储内容 （pipelines.py）：设计管道存储爬取内容</li></ul><p>下面来就来讲一个简单的案例来熟悉以下scrapy的操作：  </p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>创建一个Scrapy项目</li><li>定义提取的结构化数据(Item)</li><li>编写爬取网站的 Spider 并提取出结构化数据(Item)</li><li>编写 Item Pipelines 来存储提取到的Item(即结构化数据)</li></ul><h2 id="一-新建项目-scrapy-startproject-studyScrapy"><a href="#一-新建项目-scrapy-startproject-studyScrapy" class="headerlink" title="一. 新建项目(scrapy startproject studyScrapy)"></a>一. 新建项目(scrapy startproject studyScrapy)</h2><ul><li><p>在开始爬取之前，必须创建一个新的Scrapy项目。进入自定义的项目目录中，比如我的是<strong>F:\spider_projects</strong> 运行下列命令：</p><blockquote><pre><code>scrapy startproject studyScrapy</code></pre></blockquote></li><li><p>其中， studyScrapy 为项目名称，可以看到将会创建一个 studyScrapy 的文件夹，目录结构大致如下：<br><img src="https://i.imgur.com/blWwfGE.png" alt=""></p></li></ul><p>下面来简单介绍一下各个主要文件的作用：  </p><ul><li><p>studyScrapy/spiders/ ：存储爬虫代码的文件夹</p></li><li><p>studyScrapy/ ：该项目的Python模块，需要从这里引入；即import</p></li><li><p>studyScrapy/items.py ：定义项目的目标文件，即需要爬取的数据</p></li><li><p>studyScrapy/middlewares.py： 定义爬取时的中间件</p></li><li><p>studyScrapy/pipelines.py ：项目的管道文件，</p></li><li><p>studyScrapy/settings.py ：项目的设置文件</p></li><li><p>scrapy.cfg ：scrapy部署时的配置文件</p></li></ul><h2 id="二-创建QuotesSpider类-studyScrapy-spiders"><a href="#二-创建QuotesSpider类-studyScrapy-spiders" class="headerlink" title="二. 创建QuotesSpider类(studyScrapy/spiders)"></a>二. 创建QuotesSpider类(studyScrapy/spiders)</h2><p>我们打算抓取谚语网：<a href="http://quotes.toscrape.com" target="_blank" rel="noopener">http://quotes.toscrape.com</a> 。使用命令行生成一个Spider：  </p><blockquote><pre><code>scrapy genspider quotes quotes.toscrape.com</code></pre></blockquote><p>cd 到studyScrapy文件目录下，执行上述语句，然后我们在spiders文件下发现一个quotes.py文件。</p><p><img src="https://i.imgur.com/n2EJ8hO.png" alt=""></p><p>这个类必须继承scrapy.Spider， 这里有三个属性，和一个方法。</p><ul><li><code>name = &quot;&quot;</code>：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</li><li><code>allow_domains = []</code>是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</li><li><code>start_urls = []</code>：爬取的URL的列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</li><li><code>parse(self, response)</code>：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：<ol><li>负责解析返回的网页数据(response.body)，提取结构化数据(生成item)</li><li>生成需要下一页的URL请求；</li><li></li></ol></li></ul><h2 id="三-创建Item类"><a href="#三-创建Item类" class="headerlink" title="三. 创建Item类"></a>三. 创建Item类</h2><ol><li>打开studyScrapy目录下的items.py</li><li>Item 定义结构化数据字段，用来保存爬取到的数据，有点像Python中的dict，但是提供了一些额外的保护机制来减少错误。</li><li>创建Item需要继承scrapy.Item类，并且定义类型为scrapy.Field的字段。</li><li>接下来，创建一个QuoteItem类，定义我们要获取的内容字段，text， author， tags。</li></ol><p>此时，将items.py修改如下：</p><p><img src="https://i.imgur.com/cOhEe1R.png" alt=""></p><h2 id="四-修改parse-方法，解析Response"><a href="#四-修改parse-方法，解析Response" class="headerlink" title="四. 修改parse()方法，解析Response"></a>四. 修改parse()方法，解析Response</h2><p>parse方法中的参数response是start_urls里面的链接爬取的结果；所以我们可直接对response变量中的内容进行解析。<br>首先我们看一下网页结构，每一页都有class为quote的区块，每个区块里包含了text，author，tags，我们先找出所有quote，在提取出里面的信息。<br><img src="https://i.imgur.com/yBzpX75.png" alt=""></p><p>这里需要使用上面创建的Item，可以将它理解为一个字典，不过在声明的时候需要实例化。然后再将图中的结果解析出来赋值给Item中的每个字段，最后使用yield返回即可。</p><p><img src="https://i.imgur.com/6PrClK0.png" alt=""></p><p>这样就获取了初始页面的内容了。 这里为什么用yield而不用return呢？这里要从parse()方法的工作机制来说：</p><blockquote><pre><code>因为使用的是yield，parse函数将会被当做一个生成器使用。scrapy会逐一获取parse方法中生成的结果，并判断该结果是一个什么样的类型；如果是request则加入爬取队列，如果是item类型则使用pipeline处理，其他类型则返回错误信息。scrapy取到第一部分的request不会立马就去发送这个request，只是把这个request放到队列里，然后接着从生成器里获取；取完第一部分的request，然后再获取第二部分的item，取到item了，就会放到对应的pipeline里处理；parse()方法作为回调函数(callback)赋值给了Request，指定parse()方法来处理这些请求 scrapy.Request(url, callback=self.parse)Request对象经过调度，执行生成 scrapy.http.response()的响应对象，并送回给parse()方法，直到调度器中没有Request（递归的思路）取完之后，parse()工作结束，引擎再根据队列和pipelines中的内容去执行相应的操作；程序在取得各个页面的items前，会先处理完之前所有的request队列里的请求，然后再提取items。</code></pre></blockquote><h2 id="五-处理后续的Request"><a href="#五-处理后续的Request" class="headerlink" title="五. 处理后续的Request"></a>五. 处理后续的Request</h2><p>上面知识完成了首页的抓取，那么下一页怎么来完成了，以前我写的爬虫都是分析了url请求的规律，然后构造请求再取获取页面内容。这里我们需要从当前页面找到信息来生成下一个请求，然后再下一个请求中寻找信息构造下下一个请求。就这样循环迭代，实现整个网站的爬取。</p><p><img src="https://i.imgur.com/C0tjdXD.png" alt=""></p><p>将网页下拉到底部，查看下一页按钮，链接为/page/2/， 完整的URL就是 <a href="http://quotes.toscrape.com/page/2/" target="_blank" rel="noopener">http://quotes.toscrape.com/page/2/</a><br>我们现在就可以构造RUL请求了，这里又要用到一个新函数<strong>scrapy.Requst</strong>。它有两个参数—-url， callback。  </p><blockquote><pre><code>url: 新的请求链接callback： 回调函数，当指定了该回调函数的请求完成后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。 回调函数进行解析或者生成下一个请求，这里的回调函数就是上面的parse()函数。</code></pre></blockquote><p>这里由于parse()就是解析text，author，tags的方法，并且下一页面的结构与刚才解析的页面是一样的，所以我们可以再次使用parse来解析页面。接下来我们先利用选择器得到下一页的URL，生成新请求；在parse()方法后面追加如下代码即可：  </p><p><img src="https://i.imgur.com/BvG1S5X.png" alt=""></p><h2 id="六-运行"><a href="#六-运行" class="headerlink" title="六. 运行"></a>六. 运行</h2><p>然后，进入项目所在目录，直接运行 <strong>scrapy crawl quotes</strong>，Scrapy就开始进行抓取啦，当然我们还没设置中间件Middlewares和Piplines里面的内容，后面写其他项目会细细说明的。<br><img src="https://i.imgur.com/pI4YD37.png" alt=""></p><p>另外，可以在项目的根目录下新建main.py文件,在爬虫代码中设置好断点，用于调试 </p><blockquote><pre><code>from scrapy import cmdlinecmdline.execute(&apos;scrapy crawl quotes&apos;.split())</code></pre></blockquote><h2 id="七-保存结果-Item-Pipeline"><a href="#七-保存结果-Item-Pipeline" class="headerlink" title="七.保存结果(Item Pipeline)"></a>七.保存结果(Item Pipeline)</h2><p><strong>保存到文件</strong> </p><p>针对小项目数据，我们可以直接保存成文件格式。</p><p>scrapy保存信息的最简单的方法主要有以下几种，-o 输出指定格式的文件，命令如下：</p><ul><li><p>scrapy crawl quotes -o quotes.json # 输出json文件</p></li><li><p>scrapy crawl quotes -o quotes.csv  # 输出csv文件</p></li><li><p>scrapy crawl quotes -o quotes.xml  # 输出xml格式文件</p></li><li><p>scrapy crawl quotes -o <a href="ftp://user:passwd@ftp.xxxx.com/path/to/quotes.csv" target="_blank" rel="noopener">ftp://user:passwd@ftp.xxxx.com/path/to/quotes.csv</a>  </p></li></ul><p>同时还支持ftp， s3等远程输出。</p><p><strong>保存到数据库</strong><br>如果想输出到数据库中的话，以mongoDB为例，我们可以定义<strong>项目管道Item Pipelin</strong>e进行操作。<br>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，这些Item Pipeline组件按定义的顺序处理Item。<br>每个Item Pipeline都是实现了简单方法的Python类，比如决定此Item是丢弃而存储。以下是item pipeline的常用处理操作：</p><blockquote><pre><code>1. 清理HTML数据2. 验证爬虫数据，检查爬虫字段3. 查重并丢弃重复内容4. 将爬取结果保存到数据库中</code></pre></blockquote><p>编写item pipeline很简单，item pipiline组件是一个独立的Python类，其中process_item()方法必须实现。<br>下面是一些方法示例：<br><img src="https://i.imgur.com/AmBVtAr.png" alt=""></p><p>下面为实际的代码：<br><img src="https://i.imgur.com/ITitSws.png" alt=""><br><img src="https://i.imgur.com/ViRiqt5.png" alt=""></p><p>这样我们便完成了一个入门案例了，正式踏入Scrapy框架的学习之路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scrapy是一个用纯Python实现，为了爬取网站数据、提取结构性数据而编写的应用框架；我们只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。Scrapy 使用了Twisted多线程异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。&lt;br&gt;
    
    </summary>
    
      <category term="scrapy" scheme="http://yoursite.com/categories/scrapy/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>破解验证码识别</title>
    <link href="http://yoursite.com/2018/08/20/%E7%A0%B4%E8%A7%A3%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/20/破解验证码识别/</id>
    <published>2018-08-20T02:49:58.000Z</published>
    <updated>2018-08-22T04:21:28.874Z</updated>
    
    <content type="html"><![CDATA[<p>现在，很多网站采取各种各样的措施来反爬虫，其中之一就是使用验证码。当我们访问网页时，必须先通过验证码才能够访问页面。下面我们便来讲2种验证码的识别方式和一些思路。当然我们也可以直接使用付费的打码平台，那样可以增加识别的准确度，毕竟出了钱的嘛。哈哈！<br><a id="more"></a>  </p><h2 id="PIL库"><a href="#PIL库" class="headerlink" title="PIL库"></a>PIL库</h2><p>其实，验证码识别归根到底还是对各种各样图片的识别和操作，python中有很对图像处理的库，其中PIL就是其中之一。 所以在处理验证码识别之前，必须先了解PIL库。 下面附上其API源码地址，以及对应的学习博客。<br>源码地址：<a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/index.html" target="_blank" rel="noopener">https://pillow-cn.readthedocs.io/zh_CN/latest/reference/index.html</a><br>参考博客：<a href="https://blog.csdn.net/louishao/article/details/69879981" target="_blank" rel="noopener">https://blog.csdn.net/louishao/article/details/69879981</a><br>下面我们就开始验证码识别之路了。</p><h2 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h2><p>以中国知网为例：<br><img src="https://i.imgur.com/KfnZxWP.png" alt=""></p><p>首先，我们先拿到上图中绿线标记的验证码，下载到本地项目文件中，<br>然后，编写如下代码:<br><img src="https://i.imgur.com/Dx7xscT.png" alt=""><br>输出结果为：486V， 可是实际图片为4S6V，这是因为验证码内多余线条干扰了图片的识别，像这类情况，还需要做出额外的处理，比如转灰度，二值化等。对应的方法如下：<br><img src="https://i.imgur.com/WagZ5W3.png" alt=""></p><p>当然，实际处理中并不是这样，一般我们会先对模糊图片进行灰度处理后，再设定二值化的阈值，实际处理如下。<br><img src="https://i.imgur.com/li0queT.png" alt=""></p><p>输出结果：4S6V<br>进行识别时，先设定好二值化阈值threshold，进行适当调试，直到图片能正常识别为止。</p><h2 id="滑动验证码"><a href="#滑动验证码" class="headerlink" title="滑动验证码"></a>滑动验证码</h2><p><strong>过程分析：</strong></p><p>滑动验证码主要的验证方式是拖动滑块，拼合图像；如图象完全拼合，则验证成功，即表单提交成功，否则需要重新验证。<br>如图：<br><img src="https://i.imgur.com/pYD8C6K.png" alt=""></p><p>下面，我们就以极验的验证码为例，来讲诉一下识别方法。<br>因为极验的验证码在拖动验证码后会生成一个加密的表单提交到后台，所有为了避免麻烦我们直接用selenium模拟浏览器行为来完成验证。<br>登陆网站：极验官网</p><blockquote><pre><code>目标站点：https://account.geetest.com/login</code></pre></blockquote><p><img src="https://i.imgur.com/sVfDi03.png" alt=""></p><p>首先，我们发现登陆界面有个智能按钮，一般来说，在输入邮箱之后，点击按钮就会弹出滑动验证窗口，然后我们在拖动验证码完成图像拼接，完成验证。<br>弹出滑块验证：<br><img src="https://i.imgur.com/u1iul7H.png" alt=""><br>拖动滑块，完成验证：<br><img src="https://i.imgur.com/dKjUoEK.png" alt=""></p><p>所以，滑块验证识别需要完成以下步骤：</p><blockquote><pre><code>1. 模拟点击验证按钮2. 识别滑块的缺口位置3. 模拟拖动滑块</code></pre></blockquote><p><strong>如何实现以上步骤呢？我们先需要将任务进行分解，看似只有三大步骤，其实里面坑还有很多的，稍后会做解释。</strong>  </p><p>第一步，输入账号，获取智能按钮，使用selenium模拟点击，获取带有缺口的图片。  </p><p>第二步，获取上面缺口图片中的完整图片。这里有个地方要注意，正常情况下我们在网页源代码里是找不到完整图的，因为它被隐藏了，必须执行javascript语句才能出现完整图。<br><img src="https://i.imgur.com/v8ouv0P.png" alt=""></p><p>我们将display参数改为block，opacity参数改为1，然后进行截图，就可以拿到完整的验证码图片了。</p><p>第三步，对比两张图片的所有RGB像素点，得到缺口位置。</p><p>第四步，模拟人的拖动习惯，这里也有坑，极验的验证码增加了机器轨迹识别，匀速移动，或者随机速度移动滑块都不能通过验证，所以我们将需要拖动的总位移分成一段一段小的轨迹，先匀加速拖动后匀减速拖动。</p><p>第五步，按照规定轨迹进行拖动，完成验证。</p><p>第六步，完成账号登陆。</p><p>过程分析完了，下面我们就来写代码试一下：<br>首先，我们先将整个代码的一个逻辑思路做一个大致的概括吧。<br><img src="https://i.imgur.com/Ayg9jgg.png" alt="">  </p><p>接下来，我们便来逐一完成main函数里要实现的功能了。</p><p><strong>代码示例：</strong><br><img src="https://i.imgur.com/vCAntIv.png" alt=""><br><img src="https://i.imgur.com/p7giBb3.png" alt=""><br><img src="https://i.imgur.com/EC60eS5.png" alt=""></p><p>通过以上代码我们便拿到了完整的验证码和带有缺口的验证码。<br>缺口图片：<br><img src="https://i.imgur.com/YHzDimh.png" alt="">  </p><p>完整图片：<br><img src="https://i.imgur.com/KNLDRsB.png" alt=""></p><p>这里我在调试的时候碰到一个坑，因为chrome中，location方法不滚动，直接返回相对整个html的坐标，我的电脑是15.6寸的，显示设置上布局的缩放大小被放大到1.25倍，导致location返回的坐标与验证码的坐标有误差。修改布局为100%后就解决了。 下面便是对比图片找出缺口位置。这里我们需要遍历图片的坐标点，获取像素点的RGB数据。  </p><p><strong>代码示例</strong><br><img src="https://i.imgur.com/TQzHllN.png" alt=""></p><p>接下来就是获取滑块的移动路径和模拟拖动行为了。<br><img src="https://i.imgur.com/Rlb2brE.png" alt=""><br><img src="https://i.imgur.com/uaEc7Jg.png" alt=""></p><p>执行代码：<br><img src="https://i.imgur.com/G8pc1GS.png" alt=""> </p><p>最后终于成功了，踩了这么多坑，终于完成了滑块验证码的破解。。。现在已经实现功能，因为还可能出现其他情况，接下来我们还需要完善一下代码，其实也可封装成一个类，测试的时候我们会发现，图片会弹出小怪兽被吃了，那是因为系统识别我们是机器行为，所以不通过，这里我们需要修改加速度参数，再增加一个回调。<br><img src="https://i.imgur.com/f9DPlNE.png" alt=""></p><p>代码执行效果：<br><img src="https://i.imgur.com/br02DBK.png" alt=""></p><p>这样我们就成功破解验证码，并登陆到网页界面了。。。忙活了一上午，吃饭去了。</p><p>源码地址：<a href="https://github.com/appleguardu/spider_projects/tree/master/Captcha" target="_blank" rel="noopener">https://github.com/appleguardu/spider_projects/tree/master/Captcha</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在，很多网站采取各种各样的措施来反爬虫，其中之一就是使用验证码。当我们访问网页时，必须先通过验证码才能够访问页面。下面我们便来讲2种验证码的识别方式和一些思路。当然我们也可以直接使用付费的打码平台，那样可以增加识别的准确度，毕竟出了钱的嘛。哈哈！&lt;br&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="http://yoursite.com/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="反爬虫" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Selenium爬取淘宝商品</title>
    <link href="http://yoursite.com/2018/08/19/selenium%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%95%86%E5%93%81/"/>
    <id>http://yoursite.com/2018/08/19/selenium爬取淘宝商品/</id>
    <published>2018-08-19T05:28:28.000Z</published>
    <updated>2018-08-19T14:48:46.678Z</updated>
    
    <content type="html"><![CDATA[<p>前一天学习了selenium的相关用法，今天打算用selenium来模拟浏览器操作，抓取数据，抓取目标就定为淘宝网吧，接下来我们就开工啦！<br><a id="more"></a>  </p><h2 id="目标设定"><a href="#目标设定" class="headerlink" title="目标设定"></a>目标设定</h2><p>目标定为抓取淘宝iPhone手机销售的相关信息：其中包括商品的图片，名字，最关键的价格，购买量，商铺，地点等信息。目标定好了，接下来我们就去分析网页规律了。  </p><h2 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h2><p>首先，确定抓取入口，也就是start url为淘宝搜索页面，url的链接为：  </p><blockquote><pre><code>https://s.taobao.com/search?q=iphone</code></pre></blockquote><p>当然，这是第一页的链接。但是我们要获取的是所有页面的，先下拉到页面底部，我们发现：<br><img src="https://i.imgur.com/B2oVHX4.png" alt="">  </p><p>用黑线圈起来的是一个分页导航，其中包括前5页的链接，下一页的链接，同时还有一个任意页码跳转的链接，页面总数为100。 若要获取每一页的内容， 我们的思路是将页码从1到100的顺序进行遍历一遍。 此时我们便又两种方式来进行遍历：  </p><blockquote><pre><code>1.点击下一页，等下一页面加载出来后进行爬取2.在页面跳转框逐一输入1~100，点击确定按钮后跳转到对应页码进行爬取  </code></pre></blockquote><p>对于方法一，有一个弊端就是如果爬取过程中出现异常，程序退出了，我在点击下一页时，可能无法快速切换到后续的页面；所以，在爬取过程中还需要记录当前页码数，如果点击下一页加载失败的话，还要增加异常检查等。 方法二，我们只需输入对应页面的数值就可以跳转，比较方便。<br>当页面成功加载出来后，我们利用selenium获取页面源代码，然后进行解析，就可以获取目标信息了。  </p><h2 id="获取商品列表"><a href="#获取商品列表" class="headerlink" title="获取商品列表"></a>获取商品列表</h2><p>首先，构造出要抓取的url：  </p><blockquote><pre><code>https://s.taobao.com/search?q=iphone </code></pre></blockquote><p>q指得是搜索的关键字，改变这个参数就可以搜索不同的商品，这里我们把定义成一个变量keyword。<br>接下来我们进行代码演练了。<br><img src="https://i.imgur.com/9zhFFeT.png" alt=""><br><img src="https://i.imgur.com/2Bu9bhH.png" alt=""></p><p>输出结果：<br><img src="https://i.imgur.com/4NA5EqV.png" alt=""></p><p>这样我们便拿到了第一页商品信息的源码啦，当然这个代码还不完善，还没添加跳转功能，因为page我们设计是从第一页抓取的，当page值为2时，我们就要翻页了，那么怎么进行翻页呢？首先获取页码输入框啊，然后获取确定按钮进行操作啦。<br><img src="https://i.imgur.com/Aepl0Mc.png" alt=""><br><img src="https://i.imgur.com/94knVze.png" alt=""></p><p>我们发现，当前页面都是高亮显示的，那么我们只需要判断高亮的页码数是当前页码数就证明页面跳转成功。这里可以使用等待条件：text_to_be_present_in_element,它会等待指定的文本出现在某一节点里面时即返回成功。<br><img src="https://i.imgur.com/djIRfga.png" alt=""></p><h2 id="解析商品列表"><a href="#解析商品列表" class="headerlink" title="解析商品列表"></a>解析商品列表</h2><p>既然上面已经能拿到页面商品的源代码了，那么我们接下来就可以对源码进行解析了。<br>分析可得，每个页面有44家店铺，在源代码里我们可以发现整个商品列表使用的CSS选择器是#mainsrp-itemlist .items .item, 它匹配了整个页面的44件商品，然后我们先用items()方法将其全部提取出来，他会返回一个生成器，再使用for循环进行遍历，得到每个item对象，然后用pyquery的find方法选取我们所需要的信息即可。<br>代码如下：<br><img src="https://i.imgur.com/JDIeNPe.png" alt=""></p><p>提取结果：<br><img src="https://i.imgur.com/gxIzM05.png" alt=""></p><p>哈哈，这样我们就已经拿到第一页所有商品的数据了，接下，我们要把100页的信息都爬取下来，这里可以直接使用for循环进行遍历页码。  </p><h2 id="爬取所有商品，保存数据库"><a href="#爬取所有商品，保存数据库" class="headerlink" title="爬取所有商品，保存数据库"></a>爬取所有商品，保存数据库</h2><p>先创建数据库：<br><img src="https://i.imgur.com/cV5FihW.png" alt=""></p><p>然后for循环遍历所有页面<br><img src="https://i.imgur.com/YYEc2ko.png" alt=""></p><p>最后的结果：<br><img src="https://i.imgur.com/tjwiYUs.png" alt=""><br>MongoDB数据库：<br><img src="https://i.imgur.com/BJyyvDe.png" alt=""></p><p>然后，所有页面的iphone数据都被我们爬取下来了。。。当然，代码还可以再精简一点。。。  </p><p>源码地址:<a href="https://github.com/appleguardu/spider_projects/blob/master/taobao_iphone.py" target="_blank" rel="noopener">https://github.com/appleguardu/spider_projects/blob/master/taobao_iphone.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一天学习了selenium的相关用法，今天打算用selenium来模拟浏览器操作，抓取数据，抓取目标就定为淘宝网吧，接下来我们就开工啦！&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>爬虫的思路</title>
    <link href="http://yoursite.com/2018/08/19/%E7%88%AC%E8%99%AB%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/08/19/爬虫的思路/</id>
    <published>2018-08-19T01:56:37.000Z</published>
    <updated>2018-08-19T02:27:31.726Z</updated>
    
    <content type="html"><![CDATA[<p>万事开头难，刚开始写爬虫程序的时候，不知从何下手；通过最近一段时间练习写爬虫程序，也渐渐有了一些简单的思路，在这里做个笔记，供日后翻阅。<br><a id="more"></a>  </p><h2 id="准备好目标URL"><a href="#准备好目标URL" class="headerlink" title="准备好目标URL"></a>准备好目标URL</h2><p>一般分为一下两种情况：  </p><p>1.准备start_url</p><blockquote><pre><code>页码总数不确定，规律不明显通过代码提取下一页地址使用xpath/css/re提取url寻找url地址，部分参数在当前页面中，比如当前页码数和总页码数，使用这两个参数构建url</code></pre></blockquote><p>2.准备url_list</p><blockquote><pre><code>页码总数清楚url的地址规律明显</code></pre></blockquote><h2 id="发送请求，获取响应"><a href="#发送请求，获取响应" class="headerlink" title="发送请求，获取响应"></a>发送请求，获取响应</h2><blockquote><pre><code>添加随机user-agent，添加随机代理ip，如果对方判断我们是爬虫之后应该添加更多的headers字段，包含cookie；cookie的处理可以使用session来解决准备一堆能用的cookie，组成cookie池。如果不登录:        准备刚刚开始能够成功请求的cookie，即接收对方网站设置在response的cookie如果登录:       准备多个账号       使用程序获取每个账号的cookie       请求登录之后才能访问的网站随机选择上一步获取的cookie</code></pre></blockquote><h2 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h2><p>1.确定数据的位置:  </p><p>如果数据在当前的url地址中,提取的是列表页中的数据;直接请求列表页的url地址，不用进入详情页,提取详情页的数据<br><strong>1.确定url; 2.发送请求; 3.提取数据; 4.返回</strong></p><p>如果数据不在当前的url地址中,在其他响应中(例如Ajax请求)，寻找数据的位置<br> <strong>在network中从上而下找,使用chrome中的过滤条件，选择除了js，css, image之外的按钮,使用chrome的serach all file，搜索数字和英文</strong></p><p>如果碰到加密的Ajax请求，可使用selenium等工具获取响应源码<br><strong>分析源码，获取目标数据</strong></p><p>2.数据的提取  </p><blockquote><pre><code>1.使用re,xpath，css selector从html中提取整块的数据，先分组，之后每一组在提取2.json数据，可使用get方法进行筛选后，在进行相应的提取</code></pre></blockquote><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><blockquote><pre><code>保存在本地json ，csv，text,使用open方法或者os创建本地文件夹，将文件保存至本地。保存在数据库，关系型MySQL，提前创建好表，将数据按字段分类；非关系型，MongoDB， redis等。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;万事开头难，刚开始写爬虫程序的时候，不知从何下手；通过最近一段时间练习写爬虫程序，也渐渐有了一些简单的思路，在这里做个笔记，供日后翻阅。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>selenium的使用</title>
    <link href="http://yoursite.com/2018/08/18/selenium%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/18/selenium的使用/</id>
    <published>2018-08-18T09:10:04.000Z</published>
    <updated>2018-08-19T01:37:32.562Z</updated>
    
    <content type="html"><![CDATA[<p>对于像淘宝，京东这样的网站，虽然它也是采用Ajax获取数据，但是Ajax接口中含有许多加密参数，我们很难去直接找出其规律；所以我们需要直接使用模拟浏览器运行的方式来实现，这样就可以做到在浏览器中看到的是什么样，抓取的源码就是什么样的啦，即可见可爬，系不系很可怕。<br><a id="more"></a>  </p><h2 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h2><p>selenium是一个自动化测试工具，使用它可以驱动浏览器执行特定的动作，如点击，下拉，填充表单等操作，同时可以获取浏览器当前呈现页面的源代码，做到可见可爬。<br>下面以chrome浏览器为例，来说一下selenium的使用方式。  </p><blockquote><pre><code>首先，配置谷歌浏览器对于版本的ChromeDriver，可以找资源去下载，然后将chromedriver.exe放在python文件夹下的Scripts文件夹里。然后，安装python的selenium库，自行百度；接下来我们就可以使用selenium啦!!!</code></pre></blockquote><p><img src="https://i.imgur.com/mZll8Ht.png" alt=""></p><h2 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h2><p>首先初始化浏览器对象，接着就可调用browser对象，让其模拟浏览器操作啦！<br><img src="https://i.imgur.com/gxAlhda.png" alt=""></p><h2 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h2><p>使用get()方法访问页面<br><img src="https://i.imgur.com/CUAkEEO.png" alt=""></p><p>运行代码后，会弹出一个淘宝界面，并输出网页的源代码。<br><img src="https://i.imgur.com/5NwK8Ag.jpg" alt=""></p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><p>当我们用selenium驱动浏览器模拟操作时，需要先获取其操作节点，比如输入框，按钮的位置。  </p><p><strong>单个节点</strong><br>以淘宝搜索框为例，先从源代码里找到其位置。<br><img src="https://i.imgur.com/ed1UMjD.png" alt=""></p><blockquote><pre><code>&lt;input id=&quot;q&quot; name=&quot;q&quot; aria-label=&quot;请输入搜索文字&quot; accesskey=&quot;s&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; class=&quot;search-combobox-input&quot; aria-haspopup=&quot;true&quot; aria-combobox=&quot;list&quot; role=&quot;combobox&quot; x-webkit-grammar=&quot;builtin:translate&quot; tabindex=&quot;0&quot;&gt;</code></pre></blockquote><p>这个节点或者说是标签中有很多属性，比如id属性：q， name属性：q；那么我们可以根据css选择器或者xpath获取这个节点。  </p><blockquote><pre><code>1. find_element_by_id(&apos;q&apos;)  2. find_element_by_css_selector(&apos;#q&apos;)3. find_element_by_xpath(&apos;//*[@id=&quot;q&quot;]&apos;)以上方法都可获取搜索输入框，一般获取单个节点用以上方法就足够了，另外还可以根据name或者class_name来获取。  </code></pre></blockquote><p>selenium还有通用方法，find_element(By.ID, ‘q’),需要传入两个参数，一个时查找方式，一个是查找值。返回结果为webelement类型。</p><p><strong>多个节点</strong><br>如果我们需要查找满足条件的所有节点，就绪要用到find_elements()方法。返回结果为列表类型，列表在每个节点为webelement类型。查找方式与单个节点一致。  </p><p><strong>节点交互</strong><br>selenium可以驱动浏览器执行相应的操作，我们先找到这个节点，比如淘宝搜索框，然后调用方法：  </p><blockquote><pre><code>send_keys() 输入文字clear() 清空文字click() 点击按钮 还有很多其他的操作，可以去google查</code></pre></blockquote><p><img src="https://i.imgur.com/11otno6.png" alt="">  </p><p>代码运行效果：<br><img src="https://i.imgur.com/Q0duWFX.png" alt=""></p><h2 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h2><p>还有一些其他的操作，他们没有像上面那样是针对单个节点的，他们没有特定的对象，比如鼠标拖动，键盘按键等，这些动作就是动作链。  </p><p><img src="https://i.imgur.com/kleR7Xi.png" alt="">  </p><p>动作前：<br><img src="https://i.imgur.com/odEyGQP.png" alt=""></p><p>动作后：<br><img src="https://i.imgur.com/yApOg8G.png" alt=""></p><h2 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h2><p>对于某些操作，selenium API并没有提供；比如，下拉进度条，它可直接模拟运行JS脚本，此时可以使用<strong>execute_script()</strong>方法实现。<br><img src="https://i.imgur.com/9IILHeu.png" alt=""></p><p>执行效果：<br><img src="https://i.imgur.com/rsl9U5d.png" alt=""></p><h2 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h2><p>通过前面讲的page_source属性可以获取网页的源代码，那么我们都可以对获取的网页源码进行解析(re, BS, pyquery)。不过selenium自带相关的方法和属性来直接提取节点信息。  </p><p><strong>获取属性值</strong><br>先选中节点，再通过节点对象调用get_attribute(‘属性名’)就可获取这个属性对应的内容。<br><img src="https://i.imgur.com/A4Ts0H9.png" alt=""> </p><p><strong>获取文本值</strong><br>每个WeBElement节点都有text属性，直接调用这个属性就可以获取节点内部的文本信息，这相当于BS中的get_text()和pyquery中的text()方法。<br>加入获取的节点为p，那么p.text就是其文本内容。这里就不演示了  </p><p><strong>获取其他值</strong><br>另外，一个节点还有其他属性，方法都差不多。  </p><blockquote><pre><code>节点.id   # 获取节点id节点.location   # 获取节点在页面中的位置节点.tag_name   # 获取节点标签名称节点.size   # 获取节点宽高</code></pre></blockquote><h2 id="切换frame"><a href="#切换frame" class="headerlink" title="切换frame"></a>切换frame</h2><p>网页中有一种节点叫作 iframe， 即子frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。selenium打开页面后，默认在父级的Frame里操作，若此时页面中还有子Frame，它是不能获取到子Frame里面的节点的，所以，此时需要使用<strong>switch_to.frame()</strong>方法来切换Frame。  </p><h2 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h2><p>在selenium中， get()方法会在网页框架加载结束后执行，此时若获取page_soucre，可能并不是浏览器完全加载的页面，如果某些页面有额外的Ajax请求，我们就不一定能捕获成功。 所以，这里需要延时等待一定时间，确保节点已经加载完全。<br><strong>隐式等待</strong><br>当使用隐式等待时，如果selenium没有在DOM中找到节点，将继续等待，超出设定时间后，则会抛出找不到节点的异常。<br><img src="https://i.imgur.com/Zq8XTVv.png" alt=""></p><p><strong>显式等待</strong><br>由于页面加载有时候会受到网络的影响，所以隐式等待这种设置固定时间并不是很靠谱；这里引入显式等待。<br>显式等待指定了要查找的节点，然后指定一个最长等待时间，如果在规定时间加载出来便返回该节点；如果没有，即抛出超时异常。  </p><p>首先，需要引入WebDriverWait这个对象，调用until方法，传入等待条件excepted_conditions。<br><strong>expected_conditions模块:</strong>  </p><p>以下两个条件类验证title，验证传入的参数title是否等于或包含于driver.title </p><blockquote><pre><code>title_is title_contains</code></pre></blockquote><p>以下两个条件验证元素是否出现，传入的参数都是元组类型的locator，如(By.ID, ‘kw’) ;顾名思义，一个只要一个符合条件的元素加载出来就通过；另一个必须所有符合条件的元素都加载出来才行 </p><blockquote><pre><code>presence_of_element_located presence_of_all_elements_located</code></pre></blockquote><p>以下三个条件验证元素是否可见，前两个传入参数是元组类型的locator，第三个传入WebElement ;第一个和第三个其实质是一样的 </p><blockquote><pre><code>visibility_of_element_located invisibility_of_element_located visibility_of</code></pre></blockquote><p>以下两个条件判断某段文本是否出现在某元素中，一个判断元素的text，一个判断元素的value </p><blockquote><pre><code>text_to_be_present_in_element text_to_be_present_in_element_value</code></pre></blockquote><p>以下条件判断frame是否可切入，可传入locator元组或者直接传入定位方式：id、name、index或WebElement </p><blockquote><pre><code>frame_to_be_available_and_switch_to_it</code></pre></blockquote><p>以下条件判断是否有alert出现 </p><blockquote><pre><code>alert_is_present</code></pre></blockquote><p>以下条件判断元素是否可点击，传入locator<br>element_to_be_clickable</p><p>以下四个条件判断元素是否被选中，第一个条件传入WebElement对象，第二个传入locator元组<br>第三个传入WebElement对象以及状态，相等返回True，否则返回False<br>第四个传入locator以及状态，相等返回True，否则返回False </p><blockquote><pre><code>element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be</code></pre></blockquote><p>最后一个条件判断一个元素是否仍在DOM中，传入WebElement对象，可以判断页面是否刷新了 </p><blockquote><pre><code>staleness_of</code></pre></blockquote><p><img src="https://i.imgur.com/Xpj1Vj2.png" alt=""></p><h2 id="前进和后退"><a href="#前进和后退" class="headerlink" title="前进和后退"></a>前进和后退</h2><blockquote><pre><code>browser.back()   后退，浏览器中返回上一个页面browser.forward()   前进，下一个页面</code></pre></blockquote><h2 id="Cookies操作"><a href="#Cookies操作" class="headerlink" title="Cookies操作"></a>Cookies操作</h2><p>使用selenium还可以方便的对cookies进行操作<br><img src="https://i.imgur.com/GMq4nfL.png" alt=""></p><h2 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h2><p>在实际访问网页时，会开启一个个选项卡。在selenium中，我们也会对其进行操作。  </p><p><img src="https://i.imgur.com/ZrNbSSZ.png" alt=""></p><p>效果：<br><img src="https://i.imgur.com/P0NCssl.png" alt=""></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在使用selenium时，也会遇到异常情况；比如访问超时，节点无法找到等，所有也需要使用try。。。except来捕获各类异常。<br>下面举个例子：<br><img src="https://i.imgur.com/agPTE5p.png" alt="">  </p><p>那么到目前为止，selenium的常规用法基本上都讲了一遍了，若是想了解更多相关内容的话，可以参考以下几个链接：<br>selenium官方文档：<br><a href="http://selenium-python.readthedocs.io/installation.html#introduction" title="selenium官方文档" target="_blank" rel="noopener">http://selenium-python.readthedocs.io/installation.html#introduction</a><br>博文参考：<br><a href="https://blog.csdn.net/wenboyu/article/details/78162667" target="_blank" rel="noopener">https://blog.csdn.net/wenboyu/article/details/78162667</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于像淘宝，京东这样的网站，虽然它也是采用Ajax获取数据，但是Ajax接口中含有许多加密参数，我们很难去直接找出其规律；所以我们需要直接使用模拟浏览器运行的方式来实现，这样就可以做到在浏览器中看到的是什么样，抓取的源码就是什么样的啦，即可见可爬，系不系很可怕。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Ajax数据的爬取</title>
    <link href="http://yoursite.com/2018/08/16/Ajax%E6%95%B0%E6%8D%AE%E7%9A%84%E7%88%AC%E5%8F%96/"/>
    <id>http://yoursite.com/2018/08/16/Ajax数据的爬取/</id>
    <published>2018-08-16T02:53:33.000Z</published>
    <updated>2018-08-17T09:18:47.463Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你在写爬虫时有没有遇到这种情况：在浏览器中可以看到正常显示的页面数据，但是用requests得到的html文件里却没有这些数据。这是因为浏览器中的页面时经过JavaScript处理数据后生成的，Ajax加载就是其中一种方式，下面我们便来讲一下如何在异步加载的网页中抓取有用数据。<br><a id="more"></a>  </p><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p><strong>Ajax</strong>，就是异步的JavaScript和XML。它是利用JavaScript在保证页面不被刷新，页面链接不改变的情况下，后台与服务器进行数据交互并更新部分网页的技术。  </p><h2 id="Ajax的实现过程"><a href="#Ajax的实现过程" class="headerlink" title="Ajax的实现过程"></a>Ajax的实现过程</h2><blockquote><pre><code>第一步，创建xmlhttprequest对象，var xmlhttp =new XMLHttpRequest（);XMLHttpRequest对象用来和服务器交换数据。第二步，使用xmlhttprequest对象的open（）和send（）方法发送资源请求给服务器。第三步，使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应。第四步，onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数。</code></pre></blockquote><p>真实的数据都是通过JavaScript向服务器发送ajax请求得到的，所以要抓取这些数据，必须搞清楚这些请求是如何发送的，以及发送到了哪里，参数有哪些等等。下面我们便来分析一下。</p><h2 id="Ajax的分析方法"><a href="#Ajax的分析方法" class="headerlink" title="Ajax的分析方法"></a>Ajax的分析方法</h2><p><strong>1.分析请求</strong>  </p><p>以微博为例，当我们拖动刷新额内容时，此时网页由Ajax加载的，页面url不会发生变化，下面我们就借助chrome浏览器来分析。<br>首先，打开我巴萨新闻的官方微博链接（本人巴萨球迷。。。）  </p><p><img src="https://i.imgur.com/56DDocS.png" alt=""><br>element选项可以查看网页源代码，但这不是我们要看的。<br>点击network选项卡，刷新一下页面，发现出现很多内容，那么这些内容便是页面在加载过程中浏览器与服务器之间发送请求和接受响应内容的记录。  </p><p><img src="https://i.imgur.com/MHF0oEP.png" alt=""></p><p>这里我们找到右边条目栏中有一个getIndex的请求，点击它，查看相应信息。<br><img src="https://i.imgur.com/gJAwlqS.png" alt=""><br>我们发现Request Headers里面有一个信息围为<strong>X-Request-with：XMLHttpRequest</strong>，这就表明此请求为Ajax请求；ajax其实有特殊的请求类型，叫作<strong>xhr</strong>，稍后我们会讲到。</p><p><img src="https://i.imgur.com/RU6k1BN.png" alt=""><br>preview选项可以查看响应内容，发现响应内容为json格式。</p><p><img src="https://i.imgur.com/C1IyRw2.png" alt=""><br>response选项卡中为真实的返回数据</p><p>现在我们回到chrome浏览器最开始发送的请求<br><img src="https://i.imgur.com/XAmdgHA.png" alt=""><br>原始链接返回的response代码知识执行了一些JS。所以我们看到的微博页面的真实数据不是原始页面，而是执行了页面中的JS代码后再次向后台发送Ajax请求后，浏览器拿到数据在进一步进行渲染出来的页面。  </p><p><strong>2.筛选Ajax请求</strong>  </p><p>前面提到ajax请求类型为xhr，这里我们点击network选项卡下的XHR选项，然后刷新页面发现，下面的请求都是Ajax请求。打开一条请求，我们会看到Request URL，request Headers，response headers, response body等内容。</p><p><img src="https://i.imgur.com/VE5CfXF.png" alt=""></p><p>对Ajax请求分析完毕后，现在我们就可以模拟这些请求，来抓取数据啦啦啦！！！</p><h2 id="抓取Ajax加载的数据"><a href="#抓取Ajax加载的数据" class="headerlink" title="抓取Ajax加载的数据"></a>抓取Ajax加载的数据</h2><p><strong>1.分析请求</strong>  </p><p><img src="https://i.imgur.com/9CzVySM.png" alt=""></p><p>我们选择其中一条请求，发现这是一个GET类型额请求，</p><blockquote><pre><code>https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=1990303727&amp;containerid=1076031990303727&amp;page=2</code></pre></blockquote><p>URL包含4个参数，分别是：type，value，containerid，page。<br>然后我们分析一下规律后发现，type一直为uid，value值也不变，containerid就是107603加上value，唯一变化的参数就是page，顾名思义应该就是第几页的意思。请求分析完了。接下来看看响应内容。  </p><p><strong>2.分析响应</strong>  </p><p><img src="https://i.imgur.com/CCbittX.png" alt=""></p><p><img src="https://i.imgur.com/27cs9hW.png" alt=""></p><p>观察可知，响应内容为JSON格式，然后主要的信息全包含在cardlistInfo和cards里面。其中cards里面有一个mblog，包含的信息都是微博里面的点赞数，评论数，转发数等，还有page_Info主要包含的时博文内容这些信息。接下来我们就将这些格式化的内容提取出来。哈哈！  </p><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><p>首先构造URL，发送请求，拿到json文本内容。<br><img src="https://i.imgur.com/4gqvJj8.png" alt=""></p><p>返回内容为：<br><img src="https://i.imgur.com/w80FzyK.png" alt=""></p><p>接着就是解析json文本，提取需要的数据了，我们就提取cards里面的mblog里面的一些内容，比如正文，点赞数，评论数，转发数。<br><img src="https://i.imgur.com/JP5arE0.png" alt=""></p><p>这样我们便抓取到第二页所需的微博信息啦：<br><img src="https://i.imgur.com/uLDc29w.png" alt=""></p><p>之前是抓取的一个页面的数据，如果要抓取所有页面，只需传入page的最大值，然后使用for循环即可。  </p><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><p>我们将数据保存至mongodb中，由于是字典，我们直接进行存储即可<br>连接数据库：<br><img src="https://i.imgur.com/aUFTnAK.png" alt=""></p><p>保存：<br><img src="https://i.imgur.com/x74m1XQ.png" alt=""><br>运行结果：<br><img src="https://i.imgur.com/22jrCiD.png" alt=""></p><p>查看数据库：<br><img src="https://i.imgur.com/7enGi11.png" alt=""></p><p>这样我们便完成了Ajax加载的网页数据的抓取啦，在分析ajax请求时，我们还可以使用抓包工具Fiddler来进行分析。<br>另外，有些网站把ajax请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。这种情况下就用<strong>selenium+phantomJS</strong>，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。 这个我们会在下篇博文来讲解。 </p><p>文末附上写的另一个小demo，今日头条街拍图片：<br><a href="https://github.com/appleguardu/spider_projects/blob/master/Ajax_spider/toutiao_today.py" target="_blank" rel="noopener">https://github.com/appleguardu/spider_projects/blob/master/Ajax_spider/toutiao_today.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道你在写爬虫时有没有遇到这种情况：在浏览器中可以看到正常显示的页面数据，但是用requests得到的html文件里却没有这些数据。这是因为浏览器中的页面时经过JavaScript处理数据后生成的，Ajax加载就是其中一种方式，下面我们便来讲一下如何在异步加载的网页中抓取有用数据。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬取猫眼电影信息</title>
    <link href="http://yoursite.com/2018/08/14/%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/08/14/爬取猫眼电影信息/</id>
    <published>2018-08-14T07:52:36.000Z</published>
    <updated>2018-08-14T15:12:47.785Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容主要讲解的是一个基础爬虫实例——爬去猫眼电影排行榜前100的影片信息，通过这个实例，来理解一个爬虫的基本思路。<br><a id="more"></a>  </p><h2 id="抓取目标"><a href="#抓取目标" class="headerlink" title="抓取目标"></a>抓取目标</h2><p>确定需要爬去的信息：猫眼电影top100的影片信息，这些信息包括电影名称，上映时间，演员，图片等。</p><h2 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h2><p>我们发现榜单top100对应的url是maoyan.com/board/4 。这便是我们要抓取的目标站点。<br><img src="https://i.imgur.com/uP4n5f7.png" alt=""></p><p>首先我们看到，霸王别姬排名第一，页面中的有效信息包括电影名，主演，上映时间，地区，评分和图片等。接着我们继续翻页，观察页面url和内容的变化；<br><img src="https://i.imgur.com/1mniQsL.png" alt=""></p><p>可以看到页面的url变成了<a href="http://maoyan.com/board/4?offset=10，多了一个参数offset=10，目前页面显示内容为排行11~20的电影；我们再点击下一页，发现此时url变成了http://maoyan.com/board/4?offset=20，显示结果为排行21~30的电影，所以：" target="_blank" rel="noopener">http://maoyan.com/board/4?offset=10，多了一个参数offset=10，目前页面显示内容为排行11~20的电影；我们再点击下一页，发现此时url变成了http://maoyan.com/board/4?offset=20，显示结果为排行21~30的电影，所以：</a><br>网页显示规律为：offset表示偏移量，如果偏移量为n，那么显示电影排行为n+1到n+10，每页显示10部电影。如果要获取top100，则需要请求10次，每次抓取一个页面，提取出里面有用的信息。  </p><h2 id="抓取第一页"><a href="#抓取第一页" class="headerlink" title="抓取第一页"></a>抓取第一页</h2><p>首先我们来抓取第一页的内容。在此之前我们先创建一个主函数main(),用来执行主要操作。<br>第一步，获取网页内容。</p><p><img src="https://i.imgur.com/2AQs44l.png" alt=""></p><h2 id="解析页面"><a href="#解析页面" class="headerlink" title="解析页面"></a>解析页面</h2><p>获取到网页源代码后，就需要对页面进行解析，然后提取出我们想要的信息。我们先回到网页查看一下真实源码，在<strong>开发者模式下的Network监听组件</strong>中查看源代码。注意：不要在Elements选项卡中查看源代码，因为那里的源码可能是经过JavaScript操作，与原始请求不同，所以需要从Network下查看。<br>排行第一的源代码片段：<br><img src="https://i.imgur.com/ydbNLEA.png" alt=""> </p><p>经过分析发现，每部电影的信息都包含在一个<dd></dd>的节点中。  </p><blockquote><pre><code>排名对应节点： &lt;i class=&quot;board-index board-index-1&quot;&gt;1&lt;/i&gt;图片对应节点：&lt;img data-src=&quot;http://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c&quot; alt=&quot;霸王别姬&quot; class=&quot;board-img&quot; /&gt;电影名称：&lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1203&quot; title=&quot;霸王别姬&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:1203}&quot;&gt;霸王别姬&lt;/a&gt;&lt;/p  主演：&lt;p class=&quot;star&quot;&gt;主演：张国荣,张丰毅,巩俐&lt;/p&gt;上映时间：&lt;p class=&quot;releasetime&quot;&gt;上映时间：1993-01-01(中国香港)&lt;/p&gt;</code></pre></blockquote><p>下面我们就用正则表达式来提取上述信息，当然也可以使用Xpath和css选择器，我这里为了巩固一下正则用法，就先用re来写，虽然麻烦点。下面定义一个解析的方法。<br><img src="https://i.imgur.com/sVlFvdE.png" alt=""></p><p>这样我们就得到了第一个页面的信息，以列表list的形式返回的，每部电影信息保存在一个元组中。<br><img src="https://i.imgur.com/tAlDjx9.png" alt=""></p><p>由于数据的格式比较乱，我们需要对其进行格式的整理，这里选择遍历数据列表，把每部电影信息保存为字典dict形式。现在将方法修改一下。<br><img src="https://i.imgur.com/gZUzIXx.png" alt=""></p><p>整理后的信息如下：<br><img src="https://i.imgur.com/HYgoqD7.png" alt=""></p><h2 id="保存提取信息"><a href="#保存提取信息" class="headerlink" title="保存提取信息"></a>保存提取信息</h2><p>由于上面我们将每部电影信息都保存为了字典类型，这样更为结构化；现在我们将他们写入到文本文件中。这里通过JSON库的dumps()方法将字典进行序列化，由于输出结果有中文，需要将ensure_ascii指定为False，这样可以保证中文输出，而不是Unicode编码格式。<br><img src="https://i.imgur.com/bilBPae.png" alt=""></p><h2 id="main-方法调用"><a href="#main-方法调用" class="headerlink" title="main()方法调用"></a>main()方法调用</h2><p>最后我们定义一个main()方法用来调用前面的方法，将单页的电影信息全部写入到文件中。<br><img src="https://i.imgur.com/wUBtzNw.png" alt=""></p><p>单页文件输出结果：<br><img src="https://i.imgur.com/RzwULTw.png" alt=""></p><p>这样，我们就成功完成了第一页电影信息的爬取，但是我们目标是爬取所有电影，接下来就来试试把</p><h2 id="分页爬取"><a href="#分页爬取" class="headerlink" title="分页爬取"></a>分页爬取</h2><p>之前已经分析过了，每次翻页之后，url都会有变化，多了一个参数offset，所以我们只需要构造一下URL即可。下面将代码修改一下：<br><img src="https://i.imgur.com/M3gGvdY.png" alt=""></p><p>输出结果：<br><img src="https://i.imgur.com/9gFXrP7.png" alt=""></p><h2 id="代码最后的修改"><a href="#代码最后的修改" class="headerlink" title="代码最后的修改"></a>代码最后的修改</h2><p>现在我们已经基本上完成了所有电影信息的抓取，但是部分代码还是有缺陷，比如请求部分未作异常处理，爬取速度太快，可能会被反爬措施封锁等，所以还需要将代码优化一下。<br>代码地址：<a href="https://github.com/appleguardu/spider_projects" target="_blank" rel="noopener">https://github.com/appleguardu/spider_projects</a></p><p>好了，一个简单爬虫基本上完成！！！继续加油！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇内容主要讲解的是一个基础爬虫实例——爬去猫眼电影排行榜前100的影片信息，通过这个实例，来理解一个爬虫的基本思路。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫基本流程</title>
    <link href="http://yoursite.com/2018/08/12/python%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/12/python爬虫基本流程/</id>
    <published>2018-08-12T06:34:17.000Z</published>
    <updated>2018-08-12T06:38:00.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为爬虫"><a href="#何为爬虫" class="headerlink" title="何为爬虫"></a>何为爬虫</h2><p>爬虫：请求网站并提取数据的自动化程序<br><a id="more"></a>  </p><h2 id="爬虫的基本流程"><a href="#爬虫的基本流程" class="headerlink" title="爬虫的基本流程"></a>爬虫的基本流程</h2><p>1.. 发起请求<br>通过HTTP库(主要用到urllib和requests这两个库)向目标站点发起请求，即发送一个Request，请求可以包含headers等信息，等待服务器响应。  </p><blockquote><pre><code>Request：浏览器就发送消息给该网址所在的服务器，这个过程叫做HTTP Request。  Request介绍：1.请求方式：主要有GET、POST两种类型，另外还有HEAD、PUT、DELETE、OPTIONS等。2.请求URL：URL全称统一资源定位符，如一个网页文档、一张图片、一个视频等都可以用URL唯一来确定。3.请求头：包含请求时的头部信息，如User-Agent、Host、Cookies等信息。4.请求体：请求时额外携带的数据如表单提交时的表单数据</code></pre></blockquote><p>2.. 获取响应内容<br>如果服务器正常响应，会得到一个Response，Response的内容便是所要获取的页面内容，类型可能是HtML，Json字符串，二进制数据(图片，视频)等类型。  </p><blockquote><pre><code>Response:服务器收到浏览器发送的消息后，能够根据浏览器发送消息的内容，做相应处理，然后把消息回传给浏览器。这个过程叫做HTTP Response。浏览器收到服务器的Response信息后，会对信息进行相应处理，然后展示。 Response介绍：1.响应状态：有多种响应状态，如200代表成功、301跳转、404找不到页面、502服务器错误。2.响应头：如内容类型、内容长度、服务器信息、设置Cookie等等。3.响应体：最主要的部分，包含了请求资源的内容，如网页HTML、图片二进制数据等。 </code></pre></blockquote><p>3.. 解析获取的内容<br>获取的内容若是HTML，可以用正则表达式，网页解析库(BS,XPath等)进行解析。可能是Json，可以直接转为Json对象解析，可能是二进制数据，可以做保存或者进一步的处理。  </p><p>4.. 保存数据<br>保存形式多样，可以存为文本，也可以保存至数据库，或者保存特定格式的文件。  </p><blockquote><pre><code>1.文本：纯文本、Json、Xml等。2.关系型数据库：如MySQL、Oracle等具有结构化表结构形式存储。3.非关系型数据库：如MongoDB、Redis等Key-Value形式存储。4.二进制文件：如图片、视频、音频等等直接保存成特定格式即可。  </code></pre></blockquote><p>另外，爬虫过程还会遇到很多问题，例如JavaScript渲染的问题，网站的反爬措施，爬取速度太慢等等，这些问题会在后期更新博文的时候再做详细的讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;何为爬虫&quot;&gt;&lt;a href=&quot;#何为爬虫&quot; class=&quot;headerlink&quot; title=&quot;何为爬虫&quot;&gt;&lt;/a&gt;何为爬虫&lt;/h2&gt;&lt;p&gt;爬虫：请求网站并提取数据的自动化程序&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python之数据结构与算法</title>
    <link href="http://yoursite.com/2018/08/09/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/09/Python之数据结构与算法/</id>
    <published>2018-08-09T12:24:47.000Z</published>
    <updated>2018-08-10T10:50:35.015Z</updated>
    
    <content type="html"><![CDATA[<p>要作为一名程序员，数据结构和算法是必备基本功；这篇文章主要是介绍Python常用的数据结构和算法，记录自己在学习中的一些心得体会。<br><a id="more"></a>  </p><h2 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h2><p>算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。  <strong>算法是独立存在的一种解决问题的方法和思想。</strong><br>算法的五大特性:  </p><blockquote><pre><code>1.输入: 算法具有0个或多个输入2.输出: 算法至少有1个或多个输出3.有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成4.确定性：算法中的每一步都有确定的含义，不会出现二义性5.可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</code></pre></blockquote><h2 id="算法效率衡量"><a href="#算法效率衡量" class="headerlink" title="算法效率衡量"></a>算法效率衡量</h2><p><strong>时间复杂度与“大O记法”</strong><br>定义：  </p><p><strong>大O记法：</strong>对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p><p><strong>时间复杂度：</strong>假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)。  </p><p>估计看了概念还是一脸不知所措，哈哈，正常，我刚刚看的时候也是。<br>通俗的理解就是：对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n2和100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为n2级。<br><strong>时间复杂度的计算规则：</strong>  </p><blockquote><pre><code>1.基本操作，即只有常数项，认为其时间复杂度为O(1)2.顺序结构，时间复杂度按加法进行计算3.循环结构，时间复杂度按乘法进行计算4.分支结构，时间复杂度取最大值5.判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略</code></pre></blockquote><p>示例：<br><img src="https://i.imgur.com/3YRVUoa.png" alt=""><br><strong>常见时间复杂度</strong><br><img src="https://i.imgur.com/Sqq0QtA.png" alt=""></p><h2 id="数据结构的概念"><a href="#数据结构的概念" class="headerlink" title="数据结构的概念"></a>数据结构的概念</h2><p>在学习数据结构概念之前我们先想一个问题，假设如果现在有一个需求，要用Python中的数据类型来保存一个班的学生信息，而且要快速的通过学生姓名获取其信息。<br>实际上当我们在思考这个问题的时候，我们已经用到了数据结构。列表和字典都可以存储一个班的学生信息，但是想要在列表中获取一名同学的信息时，就要遍历这个列表，其时间复杂度为O(n)，而使用字典存储时，可将学生姓名作为字典的键，学生信息作为值，进而查询时不需要遍历便可快速获取到学生信息，其时间复杂度为O(1)。<br>那么我们为了解决问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，那么数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。<br><strong>概念</strong><br>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。</p><p>Python给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫做Python的内置数据结构，比如列表、元组、字典。而有些数据组织方式，Python系统里面没有直接定义，需要我们自己去定义实现这些数据的组织方式，这些数据组织方式称之为Python的扩展数据结构，比如栈，队列等。</p><p><strong>小结：</strong><br><strong>算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。</strong><br><strong>数据结构只是静态的描述了数据元素之间的关系。</strong><br>这里讲一下常用的数据运算：插入，删除，修改，查找，排序，这也是后面内容要经常提到的。</p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p><p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p><p>这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。<br>根据线性表的实际存储方式，分为两种实现模型：</p><blockquote><pre><code>顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。链表，将元素存放在通过链接构造起来的一系列存储块中。</code></pre></blockquote><p><strong>顺序表的基本形式</strong><br><img src="https://i.imgur.com/Nc4TasW.png" alt=""></p><p>图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Lo(e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即：</p><p>Lo(ei) = Lo(e0) + c*i</p><p>所以，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。  </p><p>另外，如果<strong>元素的大小不统一</strong>，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。</p><p><strong>顺序表的结构与实现</strong><br><img src="https://i.imgur.com/GQLMtHf.png" alt="">  </p><p>一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</p><p><strong>顺序表的两种基本实现方式</strong><br><img src="https://i.imgur.com/VrJl6Tn.png" alt="">  </p><p>图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。<br>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。</p><p>图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</p><p><strong>元素存储区替换</strong><br>一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p><p>分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。<br><strong>元素存储区扩充</strong><br>采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。我们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。  </p><p>扩充的两种策略:<br>1.每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。<br>特点：节省空间，但是扩充操作频繁，操作次数多。</p><p>2.每次扩充容量加倍，如每次扩充增加一倍存储空间。<br>特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。</p><p><strong>顺序表的操作</strong><br><strong>1.增加元素</strong><br>如图所示，为顺序表增加新元素111的三种方式<br><img src="https://i.imgur.com/58Yjdx7.png" alt=""></p><blockquote><pre><code>a. 尾端加入元素，时间复杂度为O(1)b. 非保序的加入元素（不常见），时间复杂度为O(1)c. 保序的元素加入，时间复杂度为O(n)</code></pre></blockquote><p><strong>2.删除元素</strong><br><img src="https://i.imgur.com/ccmB4na.png" alt=""></p><blockquote><pre><code>a. 删除表尾元素，时间复杂度为O(1)b. 非保序的元素删除（不常见），时间复杂度为O(1)c. 保序的元素删除，时间复杂度为O(n)</code></pre></blockquote><h2 id="Python中的顺序表"><a href="#Python中的顺序表" class="headerlink" title="Python中的顺序表"></a>Python中的顺序表</h2><p>Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。</p><p><strong>list的基本实现技术</strong><br>Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：  </p><blockquote><pre><code>1.基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。</code></pre></blockquote><blockquote><pre><code>2.允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。</code></pre></blockquote><p><img src="https://i.imgur.com/cV3MVv2.png" alt=""></p><p><img src="https://i.imgur.com/jJOvR99.png" alt=""><br>在Python的官方实现中，<strong>list就是一种采用分离式技术实现的动态顺序表。</strong>这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。</p><p>在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>由于顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，所以使用起来并不是很灵活。<br>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。  </p><p><strong>链表的定义</strong><br>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。<br><img src="https://i.imgur.com/n5v7yDM.png" alt=""></p><p><strong>单向链表</strong><br>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><img src="https://i.imgur.com/SzIvatC.png" alt="">  </p><blockquote><pre><code>1.表元素域elem用来存放具体的数据。2.链接域next用来存放下一个节点的位置（python中的标识）3.变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。</code></pre></blockquote><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p>像顺序表中list有很多方法，比如增删改查，排序，遍历等；那么在链表中也能实现这些功能，这里需要用python程序来实现。<br><strong>单链表的相关操作</strong>  </p><blockquote><pre><code>1. is_empty()        链表是否为空2. length()          链表长度3. travel()          遍历整个链表4. add(item)         链表头部添加元素5. append(item)      链表尾部添加元素6. insert(pos, item) 指定位置添加元素7. remove(item)      删除节点8. search(item)      查找节点是否存在  </code></pre></blockquote><p><strong>单链表的实现:</strong><br>链表是由很多节点组成，我们可以先把节点用一个Node类封装起来。  链表中节点之间通过将自身的next区指向下一节点的elem区来实现节点之间的链接。 例如下图中Node1与Node2之间的关系。<br><img src="https://i.imgur.com/9Gsl0JA.png" alt=""></p><p>链表实现的实例：<br><img src="https://i.imgur.com/2VVqSQs.png" alt=""><br><img src="https://i.imgur.com/etxxj3g.png" alt=""><br><img src="https://i.imgur.com/8kW2WnG.png" alt=""><br><img src="https://i.imgur.com/jtGFv51.png" alt=""><br><img src="https://i.imgur.com/YR2BUsv.png" alt=""></p><h2 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h2><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。<br>链表与顺序表的各种操作复杂度如下所示：<br><img src="https://i.imgur.com/GQYdeju.png" alt="">  </p><p>链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p><p>另外，出了单链表之外，还有单向循环链表和双向链表，这里只做一下介绍。实现的原理可以根据上面内容进行类比。  </p><p><strong>单向循环链表</strong><br>单链表的一个变形是单向循环链表，即链表中最后一个节点的next域不再为None，而是指向链表的头节点。<br><img src="https://i.imgur.com/ubeX9gK.png" alt=""></p><p>定义类时，节点的属性还是只有elem和next，链表需要指定头节点head。</p><p><strong>双向链表</strong><br>双向链表：每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。</p><p><img src="https://i.imgur.com/hJ2xsbR.png" alt=""></p><p>与单链表相比，他的节点多了一个指向前节点next的prev区属性。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈作为一种数据结构，既可以用顺序表实现，也可以用链表实现。栈的特性就像弹夹一样，子弹先进后出，栈里面的元素也是先进后出。<br><strong>栈的相关操作</strong>  </p><blockquote><pre><code>1. Stack() 创建一个新的空栈2. push(item) 添加一个新的元素item到栈顶3. pop() 弹出栈顶元素4. peek() 返回栈顶元素5. is_empty() 判断栈是否为空6. size() 返回栈的元素个数</code></pre></blockquote><p><strong>顺序表实现栈</strong><br><img src="https://i.imgur.com/iqY2vxB.png" alt=""></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><p>队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。</p><p><strong>队列的实现</strong>   </p><blockquote><pre><code>队列相关操作: 1. Queue() 创建一个空的队列2. enqueue(item) 往队列中添加一个item元素3. dequeue() 从队列头部删除一个元素4. is_empty() 判断一个队列是否为空5. size() 返回队列的大小</code></pre></blockquote><p><img src="https://i.imgur.com/ifKJNTN.png" alt=""></p><p><strong>双端队列</strong><br>双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。<br>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。<br><img src="https://i.imgur.com/IYWCdDG.png" alt=""></p><p><strong>相关操作</strong>  </p><blockquote><pre><code>1. Deque() 创建一个空的双端队列2. add_front(item) 从队头加入一个item元素3. add_rear(item) 从队尾加入一个item元素4. remove_front() 从队头删除一个item元素5. remove_rear() 从队尾删除一个item元素6. is_empty() 判断双端队列是否为空7. size() 返回队列的大小</code></pre></blockquote><p><img src="https://i.imgur.com/oAeUqKg.png" alt=""></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>排序算法（Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。  </p><p><strong>1.冒泡排序</strong><br>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>冒泡排序算法的运作如下：</p><blockquote><pre><code>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</code></pre></blockquote><p>交换过程图示(第一次)：<br><img src="https://i.imgur.com/2Lb0Vnx.png" alt=""></p><p>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示：<br><img src="https://i.imgur.com/ZYR7kGw.png" alt=""></p><p>代码示例：<br><img src="https://i.imgur.com/q2Poq9L.png" alt=""></p><p>时间复杂度：  </p><blockquote><pre><code>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）  最坏时间复杂度：O(n2)。  稳定性：稳定  </code></pre></blockquote><p>冒泡排序的演示：  </p><p><img src="https://i.imgur.com/C9iBDuU.gif" alt=""></p><p><strong>2.选择排序</strong><br>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>选择排序中前面部分为有序固定的，后面时无序的，每次从后面无序部分找到最小值往前送。<br>原理动图：<br><img src="https://i.imgur.com/ExAbEid.gif" alt=""></p><p>代码示例：<br><img src="https://i.imgur.com/HN0QK6D.png" alt=""></p><p>时间复杂度</p><blockquote><pre><code>最优时间复杂度：O(n2)最坏时间复杂度：O(n2)稳定性：不稳定（考虑升序每次选择最大的情况）</code></pre></blockquote><p><strong>3.插入排序</strong><br>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>原理示意：<br><img src="https://i.imgur.com/Vxu7QQq.gif" alt=""></p><p>代码示例：<br><img src="https://i.imgur.com/y5DKsYP.png" alt=""><br>这里可以将代码做一下优化，把内层的while循环换成for循环，去掉<code>i -= 1</code>和break。因为如果碰上最理想的情况，也就是目标序列时有序的，while循环还是需要判断，计算i -= 1，这里可以用<code>for i in range(j, 0, -1):</code></p><p>效果图：<br><img src="https://i.imgur.com/jcumXAQ.gif" alt=""></p><p><strong>4.快速排序</strong><br>快速排序（Quick sort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤为：</p><blockquote><pre><code>1.从数列中挑出一个元素，称为&quot;基准&quot;（pivot），2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</code></pre></blockquote><p><strong>代码示例</strong><br><img src="https://i.imgur.com/f9Fcr7Q.png" alt=""></p><p>时间复杂度</p><blockquote><pre><code>最优时间复杂度：O(nlogn)最坏时间复杂度：O(n2)稳定性：不稳定</code></pre></blockquote><p>另外，除了以上几种排序方法外，还有希尔排序和归并排序，这里就不一一说了。  </p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找 。  </p><p><strong>二分法查找</strong><br>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。  </p><p>代码示例：<br><img src="https://i.imgur.com/Ka39vOj.png" alt=""></p><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><p>树（tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><blockquote><pre><code>1.每个节点有零个或多个子节点；2.没有父节点的节点称为根节点；3.每一个非根节点有且只有一个父节点；4.除了根节点外，每个子节点可以分为多个不相交的子树；</code></pre></blockquote><p>树的结构示意图：</p><p><img src="https://i.imgur.com/m7YiNn8.png" alt=""></p><p><strong>二叉树的基本概念</strong><br>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）  </p><p><strong>二叉树的性质(特性)</strong>  </p><blockquote><pre><code>性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）性质2: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</code></pre></blockquote><p><strong>二叉树的遍历</strong><br>树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</p><p><strong>深度优先遍历</strong>  </p><p>对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。<br>那么深度遍历有重要的三种方法。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）。</p><blockquote><pre><code>1.先序遍历  根节点-&gt;左子树-&gt;右子树2.中序遍历  左子树-&gt;根节点-&gt;右子树3.左子树-&gt;右子树-&gt;根节点</code></pre><p><img src="https://i.imgur.com/WviXeBC.png" alt=""></p></blockquote><p>中序和后序只是把elem的顺序往下排。</p><p><strong>广度优先遍历(层次遍历)</strong>  </p><p>从树的root开始，从上到下从从左到右遍历整个树的节点<br><img src="https://i.imgur.com/IxhlZ91.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要作为一名程序员，数据结构和算法是必备基本功；这篇文章主要是介绍Python常用的数据结构和算法，记录自己在学习中的一些心得体会。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python之json基础</title>
    <link href="http://yoursite.com/2018/08/08/python%E4%B9%8Bjson%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/08/python之json数据解析/</id>
    <published>2018-08-08T05:27:17.000Z</published>
    <updated>2018-08-08T08:01:22.866Z</updated>
    
    <content type="html"><![CDATA[<p>当我们爬取异步加载的网页从上面获取的往往是json类型的文件，通常我们需要对这类数据进行处理后才能使用，下面就来说说python中对json数据的基本处理方法。<br><a id="more"></a>  </p><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）；是一种轻量级的文本数据交换格式；适用于进行数据交互的场景，比如网站前台与后台之间的数据交互。  </p><p>简单来说json就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构：  </p><blockquote><pre><code>1.对象：对象在js中表示为{ }括起来的内容，数据结构为 { key：value, key：value, ... }的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是数字、字符串、数组、对象这几种。</code></pre></blockquote><blockquote><pre><code>2.数组：数组在js中是中括号[ ]括起来的内容，数据结构为 [&quot;Python&quot;, &quot;javascript&quot;, &quot;C++&quot;, ...]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。</code></pre></blockquote><h2 id="JSON模块"><a href="#JSON模块" class="headerlink" title="JSON模块"></a>JSON模块</h2><p>Python中提供了json模块，总共有四个方法：dumps、dump、loads、load，用于字符串 和 python数据类型间进行转换。<br><strong>1.json.loads()</strong><br>对数据进行解码，把Json格式字符串 解码 转换成Python对象 。<br><img src="https://i.imgur.com/gFu4n1P.png" alt=""></p><p>实例：<br><img src="https://i.imgur.com/3zOg7fE.png" alt=""></p><p><strong>2.json.dumps()</strong><br>对数据进行编码，返回一个str对象，把一个Python对象编码转换成Json字符串。如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。<br><img src="https://i.imgur.com/foRbCB5.png" alt=""></p><p>实例：<br><img src="https://i.imgur.com/N5ids9K.png" alt=""></p><p><strong>3.json.dump()</strong><br>json.dump()用于将dict类型的数据转成str，并写入到json文件中  </p><p><img src="https://i.imgur.com/b06PiXX.png" alt=""></p><p><strong>4.json.load()</strong><br>json.load()直接从json文件中读取数据，并将str转为dict类型</p><p>实例：<br><img src="https://i.imgur.com/bBO2Wo7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们爬取异步加载的网页从上面获取的往往是json类型的文件，通常我们需要对这类数据进行处理后才能使用，下面就来说说python中对json数据的基本处理方法。&lt;br&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>leetcode02-两数相加</title>
    <link href="http://yoursite.com/2018/08/07/leetcode02-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2018/08/07/leetcode02-两数相加/</id>
    <published>2018-08-07T13:11:58.000Z</published>
    <updated>2018-08-07T15:51:30.663Z</updated>
    
    <content type="html"><![CDATA[<p>题目二：<br>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。<br><a id="more"></a><br>示例：</p><blockquote><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre></blockquote><p>分析：<br>在这之前先把链表的知识复习一下，以单链表为例，它是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><img src="https://i.imgur.com/SXv0O3O.png" alt=""></p><blockquote><pre><code>表元素域elem用来存放具体的数据。链接域next用来存放下一个节点的位置（python中的标识）变量p指向链表的头节点（首节点）的位置head，从p出发能找到表中的任意节点</code></pre></blockquote><p>链表的操作：</p><blockquote><pre><code>is_empty() 链表是否为空length() 链表长度travel() 遍历整个链表add(item) 链表头部添加元素append(item) 链表尾部添加元素insert(pos, item) 指定位置添加元素remove(item) 删除节点search(item) 查找节点是否存在</code></pre></blockquote><p>使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。<br><img src="https://i.imgur.com/b7iQwXf.png" alt=""></p><p>我们首先从最低有效位也就是列表l1和l2的表头开始相加。由于每位数字都应当处于0到9的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。<br>我们考虑到了存在的进位情况，但是还可能出现链表长度不等，即两个加数位数不等。我们将题目拆分为两个情况，以三位数加五位数为例，前三位数和前三位数我们将进位carry初始化为0，遍历列表 l1 和 l2 直至到达它们的尾端，新列表l3就等于l1+l2+carry；carry满足大于10时进1。第四位第五位则是另一种情况；具体就是：前三位数范围内，对应位进行相加操作时附加上低位的进位；第四位第五位只用将该位加上低位的进位即可（或者理解成另一个三位数的高位为0）<br>执行代码如下：<br><img src="https://i.imgur.com/PnJsCoU.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目二：&lt;br&gt;给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础学习(二)</title>
    <link href="http://yoursite.com/2018/08/07/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/08/07/JavaScript基础学习-二/</id>
    <published>2018-08-07T08:08:15.000Z</published>
    <updated>2018-08-08T07:59:30.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器在javascript中的作用:1、制作动画;2、异步操作;3、函数缓冲与节流。<br><a id="more"></a>  </p><p><strong>1.1定时器类型及语法</strong>  </p><blockquote><pre><code>定时器：setTimeout  只执行一次的定时器 clearTimeout 关闭只执行一次的定时器setInterval  反复执行的定时器clearInterval 关闭反复执行的定时器</code></pre></blockquote><p>实例1：定时器制作时钟<br><img src="https://i.imgur.com/SWmiiF5.png" alt=""><br><img src="https://i.imgur.com/LusZz6q.png" alt=""></p><p>实例二：定时器制作倒计时<br><img src="https://i.imgur.com/WhsbnOW.png" alt="">  </p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>2.1直接转换 parseInt() 与 parseFloat()</strong></p><blockquote><pre><code>alert(&apos;12&apos;+7); //弹出127alert( parseInt(&apos;12&apos;) + 7 );  //弹出19 alert( parseInt(5.6));  // 弹出5alert(&apos;5.6&apos;+2.3);  // 弹出5.62.3alert(parseFloat(&apos;5.6&apos;)+2.3);  // 弹出7.8999999999999995alert(0.1+0.2); //弹出 0.3000000000000004,改进方法如下alert((0.1*100+0.2*100)/100); //弹出0.3alert((parseFloat(&apos;5.6&apos;)*100+2.3*100)/100); //弹出7.9</code></pre></blockquote><p><strong>2.22、隐式转换 “==” 和 “-”</strong>  </p><blockquote><pre><code>if(&apos;3&apos;==3){alert(&apos;相等&apos;);} //弹出&apos;相等&apos;；‘==’会先转换成相同类型再比较</code></pre></blockquote><blockquote><pre><code>alert(&apos;10&apos;-3);  // 弹出7</code></pre></blockquote><p><strong>3.NaN 和 isNaN</strong><br>NaN: Not a Number<br>isNaN: 判断是否是非数字，是，则返回True。 </p><blockquote><pre><code>alert( parseInt(&apos;123abc&apos;) );  // 弹出123alert( parseInt(&apos;abc123&apos;) );  // 弹出NaN</code></pre></blockquote><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量作用域指的是变量的作用范围，javascript中的变量分为全局变量和局部变量。  </p><blockquote><pre><code>全局变量：在函数之外定义的变量，为整个页面公用，函数内部外部都可以访问。  局部变量：在函数内部定义的变量，只能在定义该变量的函数内部访问，外部无法访问。  </code></pre></blockquote><p><img src="https://i.imgur.com/khRSBDv.png" alt=""></p><h2 id="封闭函数"><a href="#封闭函数" class="headerlink" title="封闭函数"></a>封闭函数</h2><p>封闭函数是javascript中匿名函数的另外一种写法，创建一个一开始就执行而不用命名的函数。 </p><p><img src="https://i.imgur.com/jHRoYFq.png" alt=""></p><h2 id="变量方式定义函数"><a href="#变量方式定义函数" class="headerlink" title="变量方式定义函数"></a>变量方式定义函数</h2><p><img src="https://i.imgur.com/UrF0DwV.png" alt=""></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数嵌套函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制收回 。  </p><p><img src="https://i.imgur.com/b5pM7hE.png" alt=""><br><strong>使用封闭函数简写闭包</strong><br><img src="https://i.imgur.com/eu3enth.png" alt=""></p><p><strong>闭包的作用</strong><br>1.将一个变量长期驻扎在内存当中，可用于循环中存索引值<br><img src="https://i.imgur.com/ruhKqYk.png" alt=""></p><p>2.私有变量计数器，外部无法访问，只能通过对应的函数来访问；避免全局变量的污染。<br><img src="https://i.imgur.com/Yc6kQVb.png" alt=""></p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>1.document</p><blockquote><pre><code>document.referrer  //获取上一个跳转页面的地址(需要服务器环境)  </code></pre></blockquote><p>2.location</p><blockquote><pre><code>window.location.href  //获取或者重定url地址window.location.search //获取地址参数部分window.location.hash //获取页面锚点或者叫哈希值</code></pre></blockquote><p>3.Math</p><blockquote><pre><code>Math.random 获取0-1的随机数Math.floor 向下取整Math.ceil 向上取整</code></pre></blockquote><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>面向过程与面向对象编程</strong><br>1、面向过程：所有的工作都是现写现用。</p><p>2、面向对象：是一种编程思想，许多功能事先已经编写好了，在使用时，只需要关注功能的运用，而不需要这个功能的具体实现过程。</p><p><strong>javascript对象</strong><br>将相关的变量和函数组合成一个整体，这个整体叫做对象，对象中的变量叫做属性，变量中的函数叫做方法。javascript中的对象类似字典。</p><p><strong>8.1创建对象的方法</strong><br>1、单体<br><img src="https://i.imgur.com/KtEySXa.png" alt=""></p><p>2、工厂模式<br><img src="https://i.imgur.com/35AshCy.png" alt=""></p><p>3、原型模式<br><img src="https://i.imgur.com/hKOYvdj.png" alt=""></p><p>4、继承<br><img src="https://i.imgur.com/Y8sPzmq.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h2&gt;&lt;p&gt;定时器在javascript中的作用:1、制作动画;2、异步操作;3、函数缓冲与节流。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>leetcode01-两数之和</title>
    <link href="http://yoursite.com/2018/08/06/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2018/08/06/leetcode01-两数之和/</id>
    <published>2018-08-06T15:17:50.000Z</published>
    <updated>2018-08-07T01:54:59.449Z</updated>
    
    <content type="html"><![CDATA[<p>题目一<br>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br><a id="more"></a></p><blockquote><pre><code>示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre></blockquote><p>分析：目的：找到数组中和为目标值的两个数，并返回他们的索引；这里可以用两个for循环来遍历数组nums，让他们的和等于target。代码如下：<br><img src="https://i.imgur.com/jIFzDnU.png" alt=""></p><p>提交结果：超出时间限制。哈哈，用时太长了。这里用了2层for循环，时间复杂度为O(n^2)。</p><p>那么有没有更好的方法呢？既然要返回元素的索引值，不妨试试把元素和其索引存放到字典里试一试。</p><blockquote><pre><code>first：通过创建字典，将nums里的值和序号对应起来second：创建另一个字典用来存储目标值（target-nums）的值，third：判断该值是否在nums内，并返回其对应索引值</code></pre></blockquote><p><img src="https://i.imgur.com/EiH22Fh.png" alt=""></p><p>提交结果：通过！！！这个方法只遍历了一次列表，显然降低了计算时间；时间复杂度降低为O(n)<br><img src="https://i.imgur.com/D3GRGgz.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目一&lt;br&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;br&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础语法</title>
    <link href="http://yoursite.com/2018/08/06/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/08/06/JavaScript基础语法(一)/</id>
    <published>2018-08-06T12:43:24.000Z</published>
    <updated>2018-08-08T08:00:24.172Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是运行在浏览器端的脚步语言，JavaScript主要解决的是前端与用户交互的问题，包括使用交互与数据交互；JavaScript是浏览器解释执行的，使浏览器页面呈现出特定的行为。<br><a id="more"></a>  </p><h2 id="JavaScript嵌入页面的方式"><a href="#JavaScript嵌入页面的方式" class="headerlink" title="JavaScript嵌入页面的方式"></a>JavaScript嵌入页面的方式</h2><p><strong>1.1行间事件（主要用于事件）</strong>  </p><blockquote><pre><code>&lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;aler(&apos;ok！&apos;);&quot;&gt;  </code></pre></blockquote><p><strong>1.2页面script标签嵌入</strong>  </p><blockquote><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;          var a = &apos;hello！&apos;;  alert(a);&lt;/script&gt;  </code></pre></blockquote><p><strong>1.3外部引入</strong></p><blockquote><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</code></pre></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript 是一种弱类型语言，javascript的变量类型由它的值来决定。 定义变量需要用关键字 ‘var’。<br><strong>2.1变量类型</strong><br>5种基本数据类型：<br>number、string、boolean、undefined、null</p><p>1种复合类型：<br>object</p><p><strong>2.2变量、函数、属性、函数参数命名规范</strong><br>1.区分大小写</p><p>2.第一个字符必须是字母、下划线（_）或者美元符号（$)</p><p>3.其他字符可以是字母、下划线、美元符或数字<br><strong>2.3元素属性操作</strong><br>可以使用内置对象document上的getElementById方法来获取页面上设置了id属性的元素，获取到的是一个html对象，然后将它赋值给一个变量。<br><img src="https://i.imgur.com/8EPx4l3.png" alt=""><br>获取的页面元素，就可以对页面元素的属性进行操作，属性的操作包括属性的读和写。<br>操作属性的方法  </p><blockquote><pre><code>1 “.” 操作2 “[ ]”操作</code></pre></blockquote><p>属性写法</p><blockquote><pre><code>1、html的属性和js里面属性写法一样2、“class” 属性写成 “className”3、“style” 属性里面的属性，有横杠的改成驼峰式，比如：“font-size”，改成”style.fontSize”  </code></pre></blockquote><p><img src="https://i.imgur.com/uLkjIe2.png" alt=""></p><p><img src="https://i.imgur.com/hxo7iZn.png" alt=""></p><p><img src="https://i.imgur.com/46MCQHv.png" alt=""></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数就是重复执行的代码片。  </p><p><strong>3.1函数定义与执行</strong><br><img src="https://i.imgur.com/FxoRgqW.png" alt=""></p><p><strong>3.2变量与函数预解析</strong><br>JavaScript解析过程分为两个阶段，先是编译阶段，然后执行阶段，在编译阶段会将function定义的函数提前，并且将var定义的变量声明提前，将它赋值为undefined。<br><img src="https://i.imgur.com/FklDbHT.png" alt=""></p><p><strong>3.3提取行间事件</strong><br>在html行间调用的事件可以提取到javascript中调用，从而做到结构与行为分离。<br><img src="https://i.imgur.com/H1RHnep.png" alt=""></p><p><strong>3.4匿名函数</strong><br>定义的函数可以不给名称，这个叫做匿名函数，可以将匿名函数直接赋值给元素绑定的事件来完成匿名函数的调用。<br><img src="https://i.imgur.com/0OikuMg.png" alt=""></p><p><strong>3.5函数传参</strong><br><img src="https://i.imgur.com/HtgTIl5.png" alt=""></p><p><strong>3.6 return</strong><br>函数中’return’关键字的作用：</p><blockquote><pre><code>1、返回函数执行的结果2、结束函数的运行3、阻止默认行为</code></pre></blockquote><p><img src="https://i.imgur.com/bG7Mv99.png" alt=""></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>通过条件来控制程序的走向，就需要用到条件语句。<br><img src="https://i.imgur.com/T4pE7nQ.png" alt=""></p><h2 id="数组及操作方法"><a href="#数组及操作方法" class="headerlink" title="数组及操作方法"></a>数组及操作方法</h2><p>数组就是一组数据的集合，javascript中，数组里面的数据可以是不同类型的。  </p><p><strong>5.1定义数组的方法</strong>  </p><blockquote><pre><code>//对象的实例创建 var aList = new Array(1,2,3);//直接量创建var aList2 = [1,2,3,&apos;asd&apos;];</code></pre></blockquote><p><strong>5.2操作数组中数据的常用方法</strong><br><img src="https://i.imgur.com/AEeTdkI.png" alt=""></p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>程序中进行有规律的重复性操作，需要用到循环语句。主要以 for 循环为主。  </p><p>实例1：<br><img src="https://i.imgur.com/TNFemIb.png" alt=""></p><p>实例2：<br><img src="https://i.imgur.com/0gKNFFn.png" alt=""></p><h2 id="字符串处理方法"><a href="#字符串处理方法" class="headerlink" title="字符串处理方法"></a>字符串处理方法</h2><p><img src="https://i.imgur.com/WnrsXI6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript是运行在浏览器端的脚步语言，JavaScript主要解决的是前端与用户交互的问题，包括使用交互与数据交互；JavaScript是浏览器解释执行的，使浏览器页面呈现出特定的行为。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>python多任务之协程</title>
    <link href="http://yoursite.com/2018/08/04/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B9%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/04/python多任务之协程/</id>
    <published>2018-08-04T12:36:02.000Z</published>
    <updated>2018-08-04T13:04:00.847Z</updated>
    
    <content type="html"><![CDATA[<p>协程是啥呢？协程其实可以认为是比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机，我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。<br><a id="more"></a><br>通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行(注意不是通过调用函数的方式做到的)并且切换的次数以及什么时候再切换到原来的函数都由<strong>开发者自己确定</strong>。  </p><h2 id="协程和线程差异"><a href="#协程和线程差异" class="headerlink" title="协程和线程差异"></a>协程和线程差异</h2><p>从刚才的了解，协程看起来比线程差不多。其实不然, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。但是协程有一个问题，就是系统并不感知，所以操作系统不会帮你做切换。那么谁来帮你做切换？让需要执行的协程更多的获得CPU时间才是问题的关键。  </p><p>目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。 那么谁来适时的切换这些协程？<br>答案是有协程自己主动让出CPU，也就是每个协程池里面有一个调度器， 这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)， 这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。 切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出CPU的API之类，触发下一次调度。注意：假设这个线程中有一个协程是CPU密集型的他没有IO操作， 也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况， 所以这种情况下需要自己避免。 </p><h2 id="协程的好处"><a href="#协程的好处" class="headerlink" title="协程的好处"></a>协程的好处</h2><p>在IO密集型的程序中由于IO操作远远慢于CPU的操作，所以往往需要CPU去等IO操作。 同步IO下系统需要切换线程，让操作系统可以在IO过程中执行其他的东西。 这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。</p><p>所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。 但是这样的坏处也是很大的，主要的坏处就是操作被 “分片” 了，代码写的不是 “一气呵成” 这种。 而是每次来段数据就要判断 数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。这样代码的可读性很低，其实也不符合人类的习惯。</p><p>但是协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。  </p><p>协程通过这种对异步IO的封装 既保留了性能也保证了代码的容易编写和可读性。在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处(需要占用大量CPU的情况下，一般采用多线程)。</p><p><strong>协程的实现其实是采用了生成器的原理</strong><br>下面看一个协程实现的多任务打印实例：<br><img src="https://i.imgur.com/rBnmrpo.png" alt="">  </p><h2 id="协程-greenlet"><a href="#协程-greenlet" class="headerlink" title="协程-greenlet"></a>协程-greenlet</h2><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单<br><img src="https://i.imgur.com/2lf5TUK.png" alt=""></p><h2 id="协程-gevent"><a href="#协程-gevent" class="headerlink" title="协程-gevent"></a>协程-gevent</h2><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent。</p><p>其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。<br>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<br><strong>gevent的使用</strong><br><img src="https://i.imgur.com/OrGQERV.png" alt=""></p><p><strong>gevent切换执行</strong><br><img src="https://i.imgur.com/GlIdZ4U.png" alt=""></p><p><strong>gevent执行并发任务</strong><br>实际代码里，不会用gevent.sleep()去切换协程，而是在执行到IO操作时，gevent自动切换。<br><img src="https://i.imgur.com/tXaURig.png" alt=""></p><p>从上能够看到是先发送的获取baidu的相关信息，然后依次是sina、runoob，但是收到数据的先后顺序不一定与发送顺序相同，这也就体现出了异步，即不确定什么时候会收到数据，顺序不一定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协程是啥呢？协程其实可以认为是比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机，我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。&lt;br&gt;
    
    </summary>
    
      <category term="系统编程" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="协程" scheme="http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python多任务之线程</title>
    <link href="http://yoursite.com/2018/08/03/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/03/python多任务之线程/</id>
    <published>2018-08-03T13:46:35.000Z</published>
    <updated>2018-08-03T15:37:04.932Z</updated>
    
    <content type="html"><![CDATA[<p>进程可以理解为系统资源分配的单位，简单来说就是一段运行着的程序；那么线程就是系统调度的单位，可以理解为进程中执行代码的游标，系统的调度算法来决定其如何运行。<br><a id="more"></a>  </p><h2 id="1-threading模块使用"><a href="#1-threading模块使用" class="headerlink" title="1.threading模块使用"></a>1.threading模块使用</h2><p>python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用。<br><strong>1.1单线程执行</strong><br><img src="https://i.imgur.com/x67NBCR.png" alt=""></p><p><strong>1.2多线程执行</strong><br><img src="https://i.imgur.com/rQH2Xtt.png" alt=""><br>经过对比，可以明显看出使用了多线程并发的操作，花费时间要短很多。  </p><p><strong>1.3主线程,子线程执行顺序</strong><br><img src="https://i.imgur.com/iX50xhn.png" alt=""></p><h2 id="2-线程执行代码的封装"><a href="#2-线程执行代码的封装" class="headerlink" title="2.线程执行代码的封装"></a>2.线程执行代码的封装</h2><p><strong>2.1线程子类</strong><br>通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法.<br><img src="https://i.imgur.com/SQZGiNr.png" alt=""><br>python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。<br>而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。<br><strong>2.2线程的执行顺序</strong><br><img src="https://i.imgur.com/2H0gsyC.png" alt=""><br>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。<br>当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。  </p><p><strong>总结</strong><br>每个线程一定会有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。<br>当线程的run()方法结束时该线程完成。<br>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。<br>线程的几种状态:<br>新建，就绪，运行，等待（堵塞），死亡  </p><h2 id="3-多线程-共享全局变量"><a href="#3-多线程-共享全局变量" class="headerlink" title="3.多线程-共享全局变量"></a>3.多线程-共享全局变量</h2><p>实例1：<br><img src="https://i.imgur.com/kCgcdgP.png" alt=""></p><p>实例2：列表当做实参传递到线程中<br><img src="https://i.imgur.com/A27ZSCE.png" alt=""><br>在一个进程内的所有线程共享全局变量，能够在不适用其他方式的前提下完成多线程之间的数据共享（这点要比多进程要好）<br>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</p><h2 id="4-进程-线程对比"><a href="#4-进程-线程对比" class="headerlink" title="4.进程,线程对比"></a>4.进程,线程对比</h2><p><strong>4.1功能</strong>  </p><blockquote><pre><code>进程:能够完成多任务，比如 在一台电脑上能够同时运行多个QQ线程:能够完成多任务，比如 一个QQ中的多个聊天窗口</code></pre></blockquote><p><strong>4.2定义的不同</strong><br>进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><p><strong>4.3区别</strong><br>一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率;线线程不能够独立执行，必须依存在进程中</p><p><strong>4.4优缺点</strong><br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h2 id="5-同步的概念"><a href="#5-同步的概念" class="headerlink" title="5.同步的概念"></a>5.同步的概念</h2><p>在理解同步之前，先看一个问题。多线程开发可能遇到的问题：<br>假设两个线程t1和t2都要对num=0进行增1运算，t1和t2都各对num修改10次，num的最终的结果应该为20。但是由于是多线程访问，有可能出现下面情况：<br>在num=0时，t1取得num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得num=0。然后t2对得到的值进行加1并赋给num，使得num=1。然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给num。这样，明明t1和t2都完成了1次加1工作，但结果仍然是num=1。<br>下面我们就来测试一下：<br><img src="https://i.imgur.com/RmnqU61.png" alt=""><br><img src="https://i.imgur.com/0wX6ZEp.png" alt=""></p><p>问题产生的原因就是没有控制多个线程对同一资源的访问，对数据造成破坏，操作系统在调度一个线程时，执行过程出现暂停，执行另一个线程<br>使得线程运行的结果不可预期。这种现象称为“线程不安全”。</p><p><strong>5.1何为同步</strong><br>同步就是协同步调，按预定的先后次序进行运行。<br>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行; B依言执行，再将结果给A; A再继续操作。  </p><p><strong>5.2解决问题的思路</strong><br>对于上述提出的那个计算错误的问题，可以通过线程同步来进行解决思路，如下:</p><p>1.系统调用t1，然后获取到num的值为0，此时上一把锁，即不允许其他现在操作num。<br>2.对num的值进行+1<br>3.解锁，此时num的值为1，其他的线程就可以使用num了，而且是num的值不是0而是1<br>4.同理其他线程在对num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性  </p><p><strong>5.3互斥锁</strong><br>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p><p>互斥锁为资源引入一个状态：锁定/非锁定。</p><p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。<br>threading模块中定义了Lock类，可以方便的处理锁定：</p><blockquote><pre><code>#创建锁mutex = threading.Lock()#锁定mutex.acquire([blocking])#释放mutex.release()</code></pre><p>其中，锁定方法acquire可以有一个blocking参数。<br>如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True）<br>如果设定blocking为False，则当前线程不会堵塞<br>还有一个timeout参数，用来设定超时时间的。  </p></blockquote><p><img src="https://i.imgur.com/MyvGbrW.png" alt=""><br><img src="https://i.imgur.com/BxN3GGz.png" alt=""><br>可以看到，加入互斥锁后，运行结果与预期相符。  </p><p>过程分析：<br>上锁解锁过程<br>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。<br>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p><p>总结<br>锁的好处：确保了某段关键代码只能由一个线程从头到尾完整地执行<br>锁的坏处：阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了<br>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁  </p><h2 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h2><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。<br>死锁实例：<br><img src="https://i.imgur.com/Xb4rFqx.png" alt=""><br><img src="https://i.imgur.com/5q20yT9.png" alt=""><br>程序会进入死锁状态，如何避免呢？ 1.程序设计前要尽量避免，减少变量交叉调用 2.添加超时时间(timeout)等。  </p><h2 id="7-多线程-非共享数据"><a href="#7-多线程-非共享数据" class="headerlink" title="7.多线程-非共享数据"></a>7.多线程-非共享数据</h2><p>对于全局变量，在多线程中要格外小心，否则容易造成数据错乱的情况发生;那么对于非全局变量我们怎么处理呢？<br><img src="https://i.imgur.com/lD7PF52.png" alt=""></p><p>在多线程开发中，全局变量是多个线程都共享的数据，而局部变量等是各自线程的，是非共享的。  </p><h2 id="8-同步应用"><a href="#8-同步应用" class="headerlink" title="8.同步应用"></a>8.同步应用</h2><p><strong>8.1多个线程有序执行</strong><br>使用互斥锁完成多个任务，有序的进程工作，这就是线程的同步。<br><img src="https://i.imgur.com/lwoA6Hk.png" alt=""><br><img src="https://i.imgur.com/3MXMmEz.png" alt=""></p><h2 id="9-生产者与消费者模式"><a href="#9-生产者与消费者模式" class="headerlink" title="9.生产者与消费者模式"></a>9.生产者与消费者模式</h2><p>为什么要使用生产者和消费者模式？  </p><p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</p><p>什么是生产者消费者模式？  </p><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。<br><img src="https://i.imgur.com/aIvKYxg.png" alt=""><br>这个阻塞队列就是用来给生产者和消费者<strong>解耦</strong>的。</p><p>队列Queue的说明：</p><blockquote><pre><code>对于Queue，在多线程通信之间扮演重要的角色添加数据到队列中，使用put()方法从队列中取数据，使用get()方法判断队列中是否还有数据，使用qsize()方法</code></pre></blockquote><p>实例：<br><img src="https://i.imgur.com/lwVSBjD.png" alt=""><br><img src="https://i.imgur.com/klbL1LC.png" alt=""></p><h2 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10.ThreadLocal"></a>10.ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。为了解决这个问题，我们用到ThreadLocal。<br><img src="https://i.imgur.com/m07r1f6.png" alt="">  </p><p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p><p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题</p><h2 id="11-异步"><a href="#11-异步" class="headerlink" title="11.异步"></a>11.异步</h2><p>同步是按顺序执行，执行完一个再执行下一个，需要等待、协调运行。<br>与同步相反，异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。<br><img src="https://i.imgur.com/meBycn5.png" alt=""><br>从返回结果看，父进程在执行time.sleep(5)时，被系统分配去做了其他事情(执行callback)，做完后才回来执行print</p><h2 id="12-GIL-全局解释器锁"><a href="#12-GIL-全局解释器锁" class="headerlink" title="12.GIL-全局解释器锁"></a>12.GIL-全局解释器锁</h2><p>Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。这大大影响了python多线程的性能。而这个解释器锁由于历史原因，现在几乎无法消除。</p><p>python GIL 之所以会影响多线程等性能，是因为在多线程的情况下，只有当线程获得了一个全局锁的时候，那么该线程的代码才能运行，而全局锁只有一个，所以使用python多线程，在同一时刻也只有一个线程在运行，因此在即使在多核的情况下也只能发挥出单核的性能。</p><p>既然python在同一时刻下只能运行一个线程的代码，那线程之间是如何调度的呢？ </p><p>对于有io操作的线程，当一个线程在做io操作的时候，因为io操作不需要cpu，所以，这个时候，python会释放python全局锁，这样其他需要运行的线程就会使用该锁。 </p><p>对于cpu密集型的线程，比如一个线程可能一直需要使用cpu做计算，那么python中会有一个执行指令的计数器，当一个线程执行了一定数量的指令时，该线程就会停止执行并让出当前的锁，这样其他的线程就可以执行代码了。 </p><p>由上面可知，至少有两种情况python会做线程切换，一是一但有IO操作时，会有线程切换，二是当一个线程连续执行了一定数量的指令时，会出现线程切换。当然此处的线程切换不一定就一定会切换到其他线程执行，因为如果当前线程 优先级比较高的话，可能在让出锁以后，又继续获得锁，并优先执行。</p><p>在做科学计算的时候是用的单线程，因为这种计算是需要CPU一直做计算的，如果用多线程反而会降低计算速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程可以理解为系统资源分配的单位，简单来说就是一段运行着的程序；那么线程就是系统调度的单位，可以理解为进程中执行代码的游标，系统的调度算法来决定其如何运行。&lt;br&gt;
    
    </summary>
    
      <category term="系统编程" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python多任务之进程</title>
    <link href="http://yoursite.com/2018/08/02/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/02/python多任务之进程/</id>
    <published>2018-08-02T13:28:56.000Z</published>
    <updated>2018-08-03T13:48:05.975Z</updated>
    
    <content type="html"><![CDATA[<p>在讲进程之前我们先理解一下多任务。什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。<br><a id="more"></a><br>真正的并行执行多任务只能在多核CPU上实现，但在实际应用中，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行，让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>可以这样理解，编写完毕的代码，在没有运行的时候，称之为程序；正在运行着的代码，就成为进程。在Unix/Linux操作系统中，提供了一个fork()系统函数来创建子进程，由于我这里用的是Windows系统，所以没有fork调用。但Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。  </p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p><strong>multiprocessing</strong>模块提供了一个<strong>Process</strong>类来代表一个进程对象。<br>Process语法结构如下：<br><code>Process([group [, target [, name [, args [, kwargs]]]]])</code>  </p><blockquote><pre><code>target：表示这个进程实例所调用对象；</code></pre></blockquote><blockquote><pre><code>args：表示调用对象的位置参数元组；</code></pre></blockquote><blockquote><pre><code>kwargs：表示调用对象的关键字参数字典；</code></pre></blockquote><blockquote><pre><code>name：为当前进程实例的别名；</code></pre></blockquote><blockquote><pre><code>group：大多数情况下用不到；  </code></pre></blockquote><p> Process类常用方法：  </p><blockquote><pre><code>is_alive()：判断进程实例是否还在执行；</code></pre></blockquote><blockquote><pre><code>join([timeout])：是否等待进程实例执行结束，或等待多少秒；</code></pre></blockquote><blockquote><pre><code>start()：启动进程实例（创建子进程）；</code></pre></blockquote><blockquote><pre><code>run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；</code></pre></blockquote><blockquote><pre><code>terminate()：不管任务是否完成，立即终止；</code></pre></blockquote><p>Process类常用属性：</p><blockquote><pre><code>name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；</code></pre></blockquote><blockquote><pre><code>pid：当前进程实例的PID值；</code></pre></blockquote><p>进程创建实例1：<br><img src="https://i.imgur.com/Jq7MXSb.png" alt="">  </p><p>进程创建实例2：<br><img src="https://i.imgur.com/ZCtey8Z.png" alt="">  </p><p>进程创建实例3：<br><img src="https://i.imgur.com/bstU9Dm.png" alt=""><br><img src="https://i.imgur.com/zQ1O5aa.png" alt=""></p><h2 id="创建进程——Process子类"><a href="#创建进程——Process子类" class="headerlink" title="创建进程——Process子类"></a>创建进程——Process子类</h2><p>创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象。<br><img src="https://i.imgur.com/XfmluhR.png" alt=""></p><h2 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h2><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，<br>手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。<br>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；<br>但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行。  </p><p>multiprocessing.Pool常用函数解析:  </p><blockquote><pre><code>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</code></pre></blockquote><blockquote><pre><code>apply(func[, args[, kwds]])：使用阻塞方式调用func;</code></pre></blockquote><blockquote><pre><code>close()：关闭Pool，使其不再接受新的任务；</code></pre></blockquote><blockquote><pre><code>terminate()：不管任务是否完成，立即终止；</code></pre></blockquote><blockquote><pre><code>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</code></pre></blockquote><p>创建实例1-非阻塞方式：<br><img src="https://i.imgur.com/N9rWlgc.png" alt=""></p><p>创建实例2-阻塞方式：<br><img src="https://i.imgur.com/RLDT4Xo.png" alt=""></p><h2 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h2><p>Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。  </p><p><strong>Queue的使用</strong><br>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序。<br>Queue说明:</p><blockquote><pre><code>初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；</code></pre></blockquote><blockquote><pre><code>Queue.qsize()：返回当前队列包含的消息数量；</code></pre></blockquote><blockquote><pre><code>Queue.empty()：如果队列为空，返回True，反之False ；</code></pre></blockquote><blockquote><pre><code>Queue.full()：如果队列满了，返回True,反之False；</code></pre></blockquote><blockquote><pre><code>Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；</code></pre></blockquote><blockquote><pre><code>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出&quot;Queue.Empty&quot;异常；</code></pre></blockquote><blockquote><pre><code>2）如果block值为False，消息列队如果为空，则会立刻抛出&quot;Queue.Empty&quot;异常；</code></pre></blockquote><blockquote><pre><code>Queue.get_nowait()：相当Queue.get(False)；</code></pre></blockquote><blockquote><pre><code>Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；</code></pre></blockquote><blockquote><pre><code>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出&quot;Queue.Full&quot;异常；</code></pre></blockquote><blockquote><pre><code>2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出&quot;Queue.Full&quot;异常；</code></pre></blockquote><blockquote><pre><code>Queue.put_nowait(item)：相当Queue.put(item, False)；</code></pre></blockquote><p>实例1:<br><img src="https://i.imgur.com/t5fT4hS.png" alt=""></p><p>实例2：<br><img src="https://i.imgur.com/6VOpMmA.png" alt=""><br><img src="https://i.imgur.com/8fkdENa.png" alt=""></p><h2 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h2><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()。<br>进程池中的进程如何通信实例:<br><img src="https://i.imgur.com/fIsQvuz.png" alt=""><br><img src="https://i.imgur.com/VMCeJ3t.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲进程之前我们先理解一下多任务。什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。&lt;br&gt;
    
    </summary>
    
      <category term="系统编程" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多进程" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python标准库和内建函数</title>
    <link href="http://yoursite.com/2018/07/30/python%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/07/30/python标准库和内建函数/</id>
    <published>2018-07-30T13:12:17.000Z</published>
    <updated>2018-08-01T04:07:17.425Z</updated>
    
    <content type="html"><![CDATA[<p>Python有一套很有用的标准库(standard library)。标准库会随着Python解释器，一起安装在你的电脑中的。 它是Python的一个组成部分。<br><a id="more"></a>  </p><h2 id="常用标准库"><a href="#常用标准库" class="headerlink" title="常用标准库"></a>常用标准库</h2><p><img src="https://i.imgur.com/hn08bjp.png" alt=""></p><h2 id="常用扩展库"><a href="#常用扩展库" class="headerlink" title="常用扩展库"></a>常用扩展库</h2><p><img src="https://i.imgur.com/bWf8wMA.png" alt=""></p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>Build-in Function,启动python解释器，输入dir(__builtins__), 可以看到很多python解释器启动后默认加载的属性和函数，这些函数称之为内建函数， 这些函数因为在编程时使用较多，cpython解释器用c语言实现了这些函数，启动解释器 时默认加载。<br>这些函数数量众多，不宜记忆，开发时不是都用到的，待用到时再help(function), 查看如何使用，或结合百度查询即可，在这里介绍些常用的内建函数。  </p><p><strong>1.range函数</strong><br>range(stop) -&gt; list of integers  </p><p>range(start, stop[, step]) -&gt; list of integers  </p><blockquote><pre><code>start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）;stop:到stop结束，但不包括stop.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step:每次跳跃的间距，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</code></pre></blockquote><p>python2中range返回列表，python3中range返回一个迭代值。如果想得到列表,可通过list函数,也可以用列表生成式<code>List = [x for x in range(5)]</code>。  </p><p><strong>2.map函数</strong><br>map函数会根据提供的函数对指定序列做映射。  </p><blockquote><pre><code>map(...)     map(function, sequence[, sequence, ...]) -&gt; list  </code></pre></blockquote><blockquote><pre><code>function:是一个函数sequence:是一个或多个序列,取决于function需要几个参数返回值是一个list</code></pre></blockquote><p>参数序列中的每一个元素分别调用function函数，返回包含每次function函数返回值的list。<br><img src="https://i.imgur.com/xed9Pik.png" alt="">  </p><p><strong>3.filter函数</strong><br>filter函数会对指定序列执行过滤操作  </p><blockquote><pre><code>filter(...)  filter(function or None, sequence) -&gt; list, tuple, or string</code></pre></blockquote><blockquote><pre><code>Return those items of sequence for which function(item) is true.    If function is None, return the items that are true.  If sequence is a tuple or string, return the same type, else return a list.  </code></pre></blockquote><blockquote><pre><code>function:接受一个参数，返回布尔值True或Falsesequence:序列可以是str，tuple，list</code></pre></blockquote><p>filter函数会对序列参数sequence中的每个元素调用function函数，最后返回的结果包含调用结果为True的元素。返回值的类型和参数sequence的类型相同。<br><img src="https://i.imgur.com/xmTfHqc.png" alt=""></p><p><strong>4.reduce函数</strong><br>reduce函数，reduce函数会对参数序列中元素进行累积。  </p><blockquote><pre><code>reduce(...)  reduce(function, sequence[, initial]) -&gt; value</code></pre></blockquote><blockquote><pre><code>Apply a function of two arguments cumulatively to the items of a sequence,  from left to right, so as to reduce the sequence to a single value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates  ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items  of the sequence in the calculation, and serves as a default when the  sequence is empty.</code></pre></blockquote><blockquote><pre><code>function:该函数有两个参数sequence:序列可以是str，tuple，listinitial:固定初始值</code></pre></blockquote><p>reduce依次从sequence中取一个元素，和上一次调用function的结果做参数再次调用function。 第一次调用function时，如果提供initial参数，会以sequence中的第一个元素和initial 作为参数调用function，否则会以序列sequence中的前两个元素做参数调用function。 注意function函数不能为None。另外，在Python3里,reduce函数已经被从全局名字空间里移除了, 它现在被放置在fucntools模块里用的话要先引入： <code>from functools import reduce</code><br><img src="https://i.imgur.com/OJSWUm3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python有一套很有用的标准库(standard library)。标准库会随着Python解释器，一起安装在你的电脑中的。 它是Python的一个组成部分。&lt;br&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>python闭包和装饰器</title>
    <link href="http://yoursite.com/2018/07/30/python%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/30/python闭包和装饰器/</id>
    <published>2018-07-30T06:04:55.000Z</published>
    <updated>2018-08-01T03:47:34.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h2><p>所谓闭包，就是在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。下面用例子来解释闭包的实现，在理解闭包之前，先看一下函数的引用，在python语言中，一切皆对象，包括函数。<br><a id="more"></a><br><strong>1.函数的引用</strong><br><img src="https://i.imgur.com/YatHsFY.png" alt=""><br>我们在定义一个函数时，系统会给我们开辟一个空间地址用来存放这个函数体，函数名（test）用来指向这片内存；如果将函数名赋值给另一个变量，那么这个变量（ret）也会指向这片空间，也可以调用该函数。  </p><p><strong>2.闭包</strong><br>下面通过一个例子来理解闭包。<br><img src="https://i.imgur.com/42znv16.png" alt=""><br>这里我们定义了一个test()函数，返回的是内层函数test_in()的引用，test_in函数里用到外层函数test传进来的变量num。 我们看一下这个例子的执行顺序，先是<code>ret = test(1)</code>,调用test函数，传入了1，返回一个test_in，然后定义了一个变量ret用来接收test的返回值，此时，ret指向了test_in这个函数。接着我们又调用ret(),并传值100，相当于调用test_in，返回了num和num_in的和，结果为101。这就是例子运行的整个过程。  </p><p><strong>闭包实例</strong><br><img src="https://i.imgur.com/0c1BRhE.png" alt=""><br>这个例子中，函数line与变量a,b构成闭包。在创建闭包的时候，我们通过line_params的参数a,b说明了这两个变量的取值，<br>这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。我们只需要变换参数a,b，就可以获得不同的直线表达函数。<br>由此，我们可以看到，闭包也具有提高代码可复用性的作用。<br>如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。这样，我们就需要更多的参数传递，也减少了代码的可移植性。<br>闭包思考：<br>1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成<br>2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存  </p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的函数或对象添加额外的功能。<br>下面我们以一个小例子来演示<strong>装饰器的原理</strong>。<br><img src="https://i.imgur.com/YNeI5Kr.png" alt=""><br>把这个代码的流程解释一下：<br><strong>从开头看起，定义了三个函数w1,f1,f2 (f2在上图没画出来) 分别指向各自内存空间，下面执行<code>f1 = w1(f1)</code>，w1中传入了f1的引用，此时func指向f1；接下来遇到一个inner函数，inner指向一片空间，执行完w1(f1)后返回inner并又由f1去指向。第二步指向<code>f1()</code>,此时f1指向了inner，执行的便是inner函数，先执行验证部分，在执行func，也就是f1自己。这样便实现了在自己模块上扩展了验证功能</strong>  </p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p><img src="https://i.imgur.com/0h3Ki8O.png" alt=""><br>@函数名 这是python中的一种语法糖，前面所讲的就是@符号的实现原理，也就是装饰器的原理。</p><h2 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>当一个函数遇到多个装饰器，那它的装饰顺序怎么实现呢？<br><img src="https://i.imgur.com/h9eCc8q.png" alt=""><br>从上面的代码可以看出，对多个装饰器顺序，都是从里层开始进行装饰的，调用时从外层往里层调用。</p><h2 id="装饰器的执行"><a href="#装饰器的执行" class="headerlink" title="装饰器的执行"></a>装饰器的执行</h2><p><img src="https://i.imgur.com/ABaTcKl.png" alt=""></p><h2 id="对带有参数的函数进行装饰"><a href="#对带有参数的函数进行装饰" class="headerlink" title="对带有参数的函数进行装饰"></a>对带有参数的函数进行装饰</h2><p><img src="https://i.imgur.com/838ivWa.png" alt=""><br>如果说函数为不定长参数，可以把闭包中的参数改为不定长参数形式，如fn(*args，**kwargs)。</p><h2 id="对带有return的函数进行装饰"><a href="#对带有return的函数进行装饰" class="headerlink" title="对带有return的函数进行装饰"></a>对带有return的函数进行装饰</h2><p><img src="https://i.imgur.com/tK7c7vu.png" alt=""></p><h2 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h2><p><img src="https://i.imgur.com/8KbOlyx.png" alt=""></p><h2 id="装饰器带参数"><a href="#装饰器带参数" class="headerlink" title="装饰器带参数"></a>装饰器带参数</h2><p><img src="https://i.imgur.com/5lQHBl5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解闭包&quot;&gt;&lt;a href=&quot;#理解闭包&quot; class=&quot;headerlink&quot; title=&quot;理解闭包&quot;&gt;&lt;/a&gt;理解闭包&lt;/h2&gt;&lt;p&gt;所谓闭包，就是在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。下面用例子来解释闭包的实现，在理解闭包之前，先看一下函数的引用，在python语言中，一切皆对象，包括函数。&lt;br&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="装饰器" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>python异常处理和模块</title>
    <link href="http://yoursite.com/2018/07/29/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/07/29/python异常处理和模块/</id>
    <published>2018-07-29T07:35:50.000Z</published>
    <updated>2018-08-01T04:08:51.200Z</updated>
    
    <content type="html"><![CDATA[<p>当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常”。<br><a id="more"></a></p><h2 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h2><p>通常我们使用try…except语句来进行异常捕捉<br><img src="https://i.imgur.com/XHWgQn7.png" alt=""></p><h2 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h2><p>当捕获多个异常时，可以把要捕获的异常的名字，放到except 后，并使用元组的方式仅进行存储。<br><img src="https://i.imgur.com/AvFiEJ0.png" alt=""><br><strong>as</strong><br>我们可以用as来定义一个变量名，存储异常信息<br><img src="https://i.imgur.com/sUwe9nT.png" alt=""></p><h2 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h2><p>使用Exception。<br><img src="https://i.imgur.com/ZRF87UA.png" alt=""></p><h2 id="else子句"><a href="#else子句" class="headerlink" title="else子句"></a>else子句</h2><p>try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。<br><img src="https://i.imgur.com/sg7rRPB.png" alt=""></p><h2 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h2><p>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。<br><img src="https://i.imgur.com/CClp1gc.png" alt=""><br>在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。<br>比如文件关闭，释放锁，把数据库连接返还给连接池等</p><h2 id="抛出自定义的异常"><a href="#抛出自定义的异常" class="headerlink" title="抛出自定义的异常"></a>抛出自定义的异常</h2><p>你可以用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类。<br><img src="https://i.imgur.com/LUkdMYE.png" alt=""><br>以上程序中，关于代码#super().<strong>init</strong>()的说明<br>这一行代码，可以调用也可以不调用，建议调用，因为<strong>init</strong>方法往往是用来对创建完的对象进行初始化工作，<br>如果在子类中重写了父类的<strong>init</strong>方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，<br>所以在以后的开发中，如果重写了父类的<strong>init</strong>方法，最好是先调用父类的这个方法，然后再添加自己的功能。</p><h2 id="异常处理中抛出异常"><a href="#异常处理中抛出异常" class="headerlink" title="异常处理中抛出异常"></a>异常处理中抛出异常</h2><p><img src="https://i.imgur.com/B0DWaaV.png" alt=""></p><h2 id="python中的模块"><a href="#python中的模块" class="headerlink" title="python中的模块"></a>python中的模块</h2><p>在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，<br>必须用import关键字引入math这个模块，下面就来了解一下Python中的模块。<br>说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块。  </p><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><p>Python中用关键字import来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。<br>当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。<br>在调用math模块中的函数时，必须这样引用：<br>模块名.函数名  比如：<code>import math.sqrt</code></p><h2 id="from…-import语句"><a href="#from…-import语句" class="headerlink" title="from… import语句"></a>from… import语句</h2><p>有时候我们只需要用到模块中的某个函数，只需要引入该函数即可，此时可以用下面方法实现：<br><strong>from 模块名 import 函数名1,函数名2….</strong><br>不仅可以引入函数，还可以引入一些全局变量、类等。</p><h2 id="from…import"><a href="#from…import" class="headerlink" title="from…import *"></a>from…import *</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：<br>from modname import *<br>这提供了一个简单的方法来导入一个模块中的所有项目，然而这种声明不该被过多地使用。  </p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a>__name__属性</h2><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。<br><img src="https://i.imgur.com/StrmQ2a.png" alt=""><br>说明： 每个模块都有一个__name__属性，当其值是’__main__’时，表明该模块自身在运行，否则是被引入。  </p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p><p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p><p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p><p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p><p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p><p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p><p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p><p>这里给出了一种可能的包结构（在分层的文件系统中）:<br><img src="https://i.imgur.com/ff6EHAB.png" alt=""><br>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p><p>目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p><p>最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。</p><p>用户可以每次只导入一个包里面的特定模块，比如:</p><pre><code>import sound.effects.echo</code></pre><p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p><pre><code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</code></pre><p>还有一种导入子模块的方法是:</p><pre><code>from sound.effects import echo</code></pre><p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p><pre><code>echo.echofilter(input, output, delay=0.7, atten=4)</code></pre><p>还有一种变化就是直接导入一个函数或者变量:</p><pre><code>from sound.effects.echo import echofilter</code></pre><p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p><pre><code>echofilter(input, output, delay=0.7, atten=4)</code></pre><p>注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p><p>import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。</p><p>反之，如果使用形如<code>import item.subitem.subsubitem</code>这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。  </p><h2 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*,"></a>从一个包中导入*,</h2><p>设想一下，如果我们使用 from sound.effects import <em>会发生什么？<br>Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。<br>但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。<br>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。<br>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。<br>导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 `from package import </em> `的时候就把这个列表中的所有名字作为包内容导入。<br>作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/__init__.py中包含如下代码:  </p><pre><code>`__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]`</code></pre><p>这表示当你使用<code>from sound.effects import *</code>这种用法时，你只会导入包里面这三个子模块。</p><p>如果 __all__ 真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。</p><p>这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p><pre><code>import sound.effects.echoimport sound.effects.surroundfrom sound.effects import *</code></pre><p>这个例子中，在执行from…import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了__all__就更没问题了）</p><p>通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p><p>记住，使用<code>from Package import specific_submodule</code>这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p><p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包sound.effects中的模块echo，你就要写成 <code>from sound.effects import echo</code>。</p><pre><code>from . import echofrom .. import formatsfrom ..filters import equalizer</code></pre><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”__main__“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p><p>包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常”。&lt;br&gt;
    
    </summary>
    
      <category term="python基础" scheme="http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Exception" scheme="http://yoursite.com/tags/Exception/"/>
    
  </entry>
  
</feed>
