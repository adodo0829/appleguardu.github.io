<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AppleGuard的博客</title>
  
  <subtitle>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-03T14:10:44.230Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>huhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再探Promise</title>
    <link href="http://yoursite.com/2019/03/03/Promise/"/>
    <id>http://yoursite.com/2019/03/03/Promise/</id>
    <published>2019-03-03T00:43:40.000Z</published>
    <updated>2019-03-03T14:10:44.230Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:<br>第一遍学Promise时, 只是大概过了一遍, 感觉学的不够深入, 这一篇算是对之前的一个总结吧. Promise在ES6中也属于一个较难理解的一部分; 所以在学习一个比较难理解的知识点时, 我们可以围绕这个知识点进行展开,逐个去理解.<br><a id="more"></a></p><h1 id="再探Promise"><a href="#再探Promise" class="headerlink" title="再探Promise"></a>再探Promise</h1><p>理解一个知识点, 不妨先列出下面几个问题.   </p><ul><li><p>Promise是用来干什么的?</p></li><li><p>Promise是什么?</p></li><li><p>Promise如何去创建,使用?</p></li><li><p>Promise的常用形式?</p></li><li><p>Promise的使用有哪些注意点?</p></li></ul><h2 id="异步相关背景介绍"><a href="#异步相关背景介绍" class="headerlink" title="异步相关背景介绍"></a>异步相关背景介绍</h2><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>首先聊一下浏览器, 一直对浏览器的结构比较好奇,查了很多资料总结就有下面一点相关总结; 其中也借鉴其他人的一些东西.<br>浏览器是多进程的,有主进程, GPU加速进程,渲染进程(内核)等, 一般新开一个tab页面就是新启动一个进程, CPU就会给他分配资源; 但其中有一个核心进程==&gt;渲染进程(浏览器内核), 是我们前端人员需要特别关注的,它包括了多个线程…</p><ul><li><p>GUI渲染线程</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</span><br><span class="line">当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</span><br><span class="line"></span><br><span class="line">注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），</span><br><span class="line">GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</span><br></pre></td></tr></table></figure></code></pre></li><li><p>JS引擎线程</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">也称为JS内核，负责处理Javascript脚本程序.(例如V8引擎)JS引擎线程负责解析Javascript脚本，运行代码。</span><br><span class="line">JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</span><br><span class="line">同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</span><br><span class="line"></span><br><span class="line">不过H5中新增了Web Worker, 实现了多线程: js会新开线程来处理一些其他任务,但不会影响DOM结构...</span><br><span class="line">创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</span><br><span class="line">JS引擎线程与worker线程间通过特定的方式通信</span><br><span class="line">(postMessage API，需要通过序列化对象来与线程交互特定的数据）</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>事件触发线程</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个线程是归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</span><br><span class="line">当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求,</span><br><span class="line">页面滚动等），会将对应任务添加到事件线程中</span><br><span class="line">当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</span><br><span class="line">注意，</span><br><span class="line">由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>定时触发器线程</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">即setInterval与setTimeout所在线程</span><br><span class="line">浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确); </span><br><span class="line">因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</span><br><span class="line">当然setTimeout中的延时参数也不一定准确</span><br></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>异步HTTP请求线程</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在XMLHttpRequest在连接后是通过浏览器新开一个网络线程去请求</span><br><span class="line">将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，</span><br><span class="line">将这个回调再放入事件队列中。再由JavaScript引擎执行。</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>那么关于浏览器方面的背景知识就介绍到这里啦, 想要深入去了解,可以去查相关资料…</p><h4 id="事件队列和循环"><a href="#事件队列和循环" class="headerlink" title="事件队列和循环"></a>事件队列和循环</h4><p>大家都知道JavaScript引擎是单线程的工作模式, 即同一时间只能跑一段代码,还要按顺序自上而下执行; 但是碰到I/O操作, 定时器, 事件监听函数等这些耗时操作; JS引擎不会等待它们有结果了才去之下它们后面的代码, 而是会将它们扔进任务(事件)队列中, 等待同步代码执行栈空了之后, 再去任务队列将任务一个个取出来执行任务所对应的回调函数, 执行完毕后会一直等待新的任务到来; 如此循环…</p><p><img src="https://i.imgur.com/aCZzv05.png" alt=""></p><h4 id="几个类型的回调"><a href="#几个类型的回调" class="headerlink" title="几个类型的回调"></a>几个类型的回调</h4><ul><li><p>同步回调函数</p><p>  我们可以利用了函数的执行栈顺序,函数作为参数放到另一个函数中调用, 谁在后面调用谁就先被放在函数执行栈栈顶 </p></li><li><p>异步回调函数 </p><p>  事先在外面定义好一个callback; 将回调函数作为某个函数的参数, 利用函数的作用域将函数中异步任务得到的结果存在回调函数的形参中, 然后在函数体末尾调用…</p></li><li><p>定时器<br>  setTimeout的作用是在间隔一定的时间后，将回调函数插入任务队列中，等栈中的同步任务都执行完毕后，再执行, 当然这个时间不一定准确…</p></li></ul><h2 id="Promise是用来干什么的"><a href="#Promise是用来干什么的" class="headerlink" title="Promise是用来干什么的?"></a>Promise是用来干什么的?</h2><p>看阮老师的ES6出门上说Promise是JS异步编程的一种解决方案. 举个例子, Ajax的回调问题, 如果下一个ajax请求要用到上一个Ajax请求中的结果, 那么往往就会导致多个回调嵌套的问题, 那么Promise就可以解决这种代码上的嵌套问题, 是我们的代码变得更优美, 更利于维护; 我暂时先对Promise的理解就是: 处理异步任务, 保存异步结果状态, 异步代码同步化…</p><h2 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么?"></a>Promise是什么?</h2><p>Promise 它就是一个对象，相当于一个容器, 里面存的就是一个异步操作的结果; 我们可以是从中获取异步操作结果的相关信息。</p><p>Promise对象代表一个未完成、但预计将来会完成的操作。<br>它有以下三种状态：</p><p>pending：初始值，不是fulfilled，也不是rejected<br>fulfilled：代表操作成功<br>rejected：代表操作失败</p><p>Promise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。<br>注意：Promise一旦新建就会「立即执行」(它属于microtask)，无法取消。这也是它的缺点之一。</p><h2 id="Promise的创建和使用"><a href="#Promise的创建和使用" class="headerlink" title="Promise的创建和使用?"></a>Promise的创建和使用?</h2><p>1.创建promise对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.使用new Promise(func)的形式</span><br><span class="line">//2.快捷语法: Promise.resolve(func) || Promise.reject(func)</span><br><span class="line">// 参数1: 一般是一个处理异步任务的函数  </span><br><span class="line">// 返回值: 一个promise实例对象</span><br><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">// 等价于, 不过参数类型不一样执行的操作也会有所不同</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure><p>2.在函数func中 放异步处理代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 传入两个参数: 回调函数resolve, reject分别去保存异步处理的结果</span><br><span class="line">// 成功: 使用resolve(结果)</span><br><span class="line">// 失败: 使用reject(原因)</span><br></pre></td></tr></table></figure><p>3.调用实例的then(func1) 或者 catch(err)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先then方法是异步执行, 对上面的异步结果进行处理的函数</span><br><span class="line">参数: 传回调函数, 一个两个都行, 前者是成功状态的回调,后者是失败的回调</span><br></pre></td></tr></table></figure><h2 id="Promise常用的场景"><a href="#Promise常用的场景" class="headerlink" title="Promise常用的场景?"></a>Promise常用的场景?</h2><ul><li><p>promise一般的使用套路就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.先定义一个函数, 函数内部使用new Promise()的方式来返回一个promise对象, resolve用来保存 异步处理成功的结果</span><br><span class="line">reject用来保存 异常处理的结果</span><br><span class="line">2.然后函数调用,传参</span><br><span class="line">3.链式语法点出then方法, then中的回调用来处理异步结果</span><br><span class="line">4.有错误就点出catch方法, 也可以用then(null, function() &#123;&#125;)代替catch</span><br><span class="line">5.then的回调中也可return一个值, 会被包装成一个新的promise, 因此可以继续调用then方法</span><br></pre></td></tr></table></figure></li><li><p>应用场景: 在ajax中使用, 解决异步嵌套问题</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">// 请求类型, 地址, 异步</span></span><br><span class="line">        xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理响应内容, 将内容丢到成功状态的回调</span></span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="comment">// 捕获错误, 丢到失败状态的回调</span></span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 封装的ajax函数</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'http://127.0.0.1:3000/xxoo'</span>; <span class="comment">// 自己本地开的一个服务</span></span><br><span class="line">    </span><br><span class="line">ajax(url)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 输出 &#123;code: 0, msg: 'hello cors'&#125;</span></span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>其他场景</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现串行任务管道; 即当前任务的输出可以作为下一个任务的输入，形成一条数据管道;</span></span><br><span class="line"><span class="comment">// 比如: 比如从url1获取参数userId，拿到后再从url2获取第三方openId，最后再从url3货取orderList，然后把结果展示给用户，类似的逻辑都是任务管道:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(res + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(res + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="promise的好处"><a href="#promise的好处" class="headerlink" title="promise的好处"></a>promise的好处</h2><ul><li><p>在异步执行的流程中，使用Promise可以把 执行代码 和 处理结果 的代码清晰地分离<br>这样我们便可以 把执行代码 和 结果处理 分成不同的模块来写,易于维护</p><p><img src="https://i.imgur.com/ZDJ1m2V.png" alt=""></p></li><li><p>减少异步回调的嵌套, 比如ajax回调, 我们可以依次调用then方法即可, 还可以控制回调的顺序</p></li><li><p>多个异步任务是为了容错去访问用同一资源时, 可以使用Promise.race([promise实例…])</p></li><li><p>多个异步任务并行执行时,比如ajax访问两个接口, 可以用Promise.all([promise实例…])</p></li></ul><h2 id="promose使用的注意事项"><a href="#promose使用的注意事项" class="headerlink" title="promose使用的注意事项"></a>promose使用的注意事项</h2><ol><li>Promise构造函数内的同步代码立即执行</li><li>回调函数参数resolve异步执行, 将结果作为参数传给then方法中的回调函数</li><li>resolve只有第一次执行有效,状态不能二次改变</li><li>then和catch如果有return, 返回的是一个全新的promise对象, 可以链式调用</li><li>Promise构造函数只会执行一次, promise实例会保存resolve的状态,<br>以后这个实例每次调用then都是返回一个这个状态, 若链式调用then,下一个则会打印undefined, res没有值…</li><li>then中返回任意一个非 promise 的值都会被包裹成 promise 对象</li><li>.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环</li><li>.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</li><li>.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;br&gt;第一遍学Promise时, 只是大概过了一遍, 感觉学的不够深入, 这一篇算是对之前的一个总结吧. Promise在ES6中也属于一个较难理解的一部分; 所以在学习一个比较难理解的知识点时, 我们可以围绕这个知识点进行展开,逐个去理解.&lt;br&gt;
    
    </summary>
    
      <category term="JS异步中那些事" scheme="http://yoursite.com/categories/JS%E5%BC%82%E6%AD%A5%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>前端开发之功能点方案总结</title>
    <link href="http://yoursite.com/2019/02/28/%E5%8A%9F%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93%E7%AF%87/"/>
    <id>http://yoursite.com/2019/02/28/功能点总结篇/</id>
    <published>2019-02-28T00:43:40.000Z</published>
    <updated>2019-03-01T04:39:19.321Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:<br>本文章主要记录了在面对开发中一些基本功能需求时,所用到的一些技术方案总结…<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;br&gt;本文章主要记录了在面对开发中一些基本功能需求时,所用到的一些技术方案总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端开发中的那些事儿(持续更新...)" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="resolution" scheme="http://yoursite.com/tags/resolution/"/>
    
  </entry>
  
  <entry>
    <title>前端开发之简洁的JS</title>
    <link href="http://yoursite.com/2019/02/27/%E7%AE%80%E6%B4%81%E7%9A%84js%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/27/简洁的js方法/</id>
    <published>2019-02-27T00:43:40.000Z</published>
    <updated>2019-03-03T13:54:57.942Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:<br>本文章主要记录在日常开发中所用到的一些简洁的JS方法;极简的语法实现一个功能,可能有点偏向函数式编程的味道;参考GitHub上的一个项目: 30 second of code方便以后遇到此类问题能够快速拿出解决方案…<br><a id="more"></a></p><ul><li><p>1.快速生成序列化数组</p><pre><code>// 返回一个 [0-9]的数组// 参数1: 类数组或数组; 参数2: map函数; 返回值: map的处理结果Array.from( new Array(10), (item, index) =&gt; index) // 上述参数1也可以传一个对象: {length: 10}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;br&gt;本文章主要记录在日常开发中所用到的一些简洁的JS方法;极简的语法实现一个功能,可能有点偏向函数式编程的味道;参考GitHub上的一个项目: 30 second of code方便以后遇到此类问题能够快速拿出解决方案…&lt;br&gt;
    
    </summary>
    
      <category term="前端开发中的那些事儿(持续更新...)" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="resolution" scheme="http://yoursite.com/tags/resolution/"/>
    
  </entry>
  
  <entry>
    <title>Node相关总结</title>
    <link href="http://yoursite.com/2019/02/17/node%E9%98%B6%E6%AE%B5/"/>
    <id>http://yoursite.com/2019/02/17/node阶段/</id>
    <published>2019-02-17T02:53:33.000Z</published>
    <updated>2019-02-28T02:09:57.101Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:<br>文章主要是对平时在node学习中常用的一些方法做的一个总结笔记…<br><a id="more"></a></p><h1 id="node一些知识点总结"><a href="#node一些知识点总结" class="headerlink" title="node一些知识点总结"></a>node一些知识点总结</h1><h2 id="npm包管理工具"><a href="#npm包管理工具" class="headerlink" title="npm包管理工具"></a>npm包管理工具</h2><p>npm使用: 一般在项目文件夹中去下载我们所需要的第三方包,或者叫库</p><p><strong>操作步骤: 推荐本地安装,尽量不要全局安装</strong></p><pre><code>1.找到项目文件夹,执行 npm init --y 自动生成package.json配置文件2.然后执行 npm i 包名 --save (运行项目需要的包,save会自动添加包依赖) 进行安装;                  npm i 包名 --save-dev 开发时需要的包3.更新操作, 去package文件中修改 包的版本, 执行npm update4.删除 npm uninstall 包名</code></pre><h2 id="Node中的模块"><a href="#Node中的模块" class="headerlink" title="Node中的模块"></a>Node中的模块</h2><h4 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h4><h5 id="fs文件模块-负责文件读写"><a href="#fs文件模块-负责文件读写" class="headerlink" title="fs文件模块: 负责文件读写"></a>fs文件模块: 负责文件读写</h5><ul><li>模块使用: <ul><li>导包  const FS = require(‘fs’);</li><li>调用对象的API方法<br>// 文件读取, 异步操作<br>FS.readFile(路径, 编码格式, 回调(err, data) =&gt; { 失败:抛错 || 成功:处理数据 })<br>// 文件写入<br>FS.writeFile(路径, 写入内容, 编码格式, 回调(err) =&gt; {失败:抛错 || 成功})</li></ul></li></ul><h5 id="http模块-用来搭建服务器"><a href="#http模块-用来搭建服务器" class="headerlink" title="http模块: 用来搭建服务器"></a>http模块: 用来搭建服务器</h5><ul><li><p>模块使用:</p><pre><code>  1.导包 const HTTP = require(&apos;http&apos;)2.调用HTTP对象的API方法  1.创建服务器对象</code></pre></li></ul><pre><code>let server = HTTP.createServer((req, res) =&gt; {// 处理客户端传过来的请求数据 req对象: 包含了很多属性重要属性: req.url 请求服务端资源的 url服务器会根据请求的url路径 返回相对应的文件资源        // 服务端返回客户端的数据     res对象: 各种方法和属性    **注意不能直接返回js对象,因为后台是给所有客户端使用,一般返回json对象**    res.end( data ) : 给客户端返回响应数据的方法    // 设置响应头, 200正常, 302重定向    res.writeHead(302, {&apos;Location&apos;: 重定向路径})    // 返回文件: 读取文件后, res.end(data)返回二进制文件给浏览器解析})2. 开启服务器监听server.listen(port, host, 回调() =&gt; { 启动成功... })</code></pre><h5 id="path模块-一般用来合并文件路径"><a href="#path模块-一般用来合并文件路径" class="headerlink" title="path模块: 一般用来合并文件路径"></a>path模块: 一般用来合并文件路径</h5><ul><li><p>模块使用: </p><pre><code>const PATH = require(&apos;path&apos;) __dirname: 当前文件夹的绝对路径 __filename: 当前文件的绝对路径  常用path.join方法来进行拼接....  PATH.join(__dirname, 文件夹名, 文件名) ==&gt; __dirname/文件夹/文件名</code></pre></li></ul><h5 id="url模块-用来解析请求的url"><a href="#url模块-用来解析请求的url" class="headerlink" title="url模块: 用来解析请求的url"></a>url模块: 用来解析请求的url</h5><ul><li><p>模块使用: const URL = require(‘url’)</p><pre><code>URL.parse(req.url, true) // 得到一个url对象,直接去返回的对象中取相应值</code></pre></li></ul><h4 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h4><pre><code>第三方模块指的是向jquery, bootstrap, express这样的第三方库, 我们可以npm去安装...依照官方文档来进行使用</code></pre><h4 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h4><p>就是自己写的js文件,每个独立的js文件都相当于一个模块,是一个独立的作用域,外部无法访问</p><ul><li><p>自定义模块操作:</p><pre><code>1.导入模块: const 变量名 = require(&apos;模块路径&apos;)2.导出模块: module.exports = {想要导出的对象...}</code></pre></li></ul><h2 id="Web中静态资源请求"><a href="#Web中静态资源请求" class="headerlink" title="Web中静态资源请求"></a>Web中静态资源请求</h2><p>当我们打开一个页面时,即一个html文件, 文件中的href, src这些属性就回去向服务器请求对应的资源,<br>服务器要对请求的url路径进行处理, 然后返回响应数据…<br><strong>注意html中的url的路径格式要与服务端文件夹路径保持一致性,这样服务端可以直接拼接url来响应对应资源，简化代码</strong></p><p>举个栗子:<br>    假如有一个img标签: <code>&lt;img src=&quot;../images/xx.png&quot;&gt;</code><br>    假设我在html文件所在文件目录test开启本地服务,端口3000, 这个路径就是<code>http://127.0.0.1:3000/test/images/xx.png</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接下来, 我们要去写处理请求的逻辑js代码, 这里就直接写部分示例代码了</span><br><span class="line"><span class="keyword">let</span> server = HTTP.creatServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.url == <span class="string">'/images/xx.png'</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取文件返回</span></span><br><span class="line">        FS.readFile(PATH.join(__dirname, req.url), (error, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; res.end(data) &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这样便实现了静态资源从本地服务器向 页面返回数据了..., 当然后面右封装好的框架来处理这些url请求</span></span><br></pre></td></tr></table></figure><h2 id="Node处理get和post请求"><a href="#Node处理get和post请求" class="headerlink" title="Node处理get和post请求"></a>Node处理get和post请求</h2><p><strong>首先来看看http协议中完整的url路径:</strong>​</p><p><img src="https://i.imgur.com/CDUk8wg.png" alt="">​</p><ul><li>get请求的参数是直接在url路径中显示。</li><li>get的请求参数在path资源路径的后面添加，以?表示参数的开始，以key=value表示参数的键值对，多个参数以&amp;符号分割</li><li>hash部分表示的是资源定位符（滚动网页可视区域），由浏览器自动解析处理，它的作用是跳转到对应id的标签的位置</li></ul><h4 id="get请求处理-这里要用到一个url模块"><a href="#get请求处理-这里要用到一个url模块" class="headerlink" title="get请求处理: 这里要用到一个url模块"></a>get请求处理: 这里要用到一个url模块</h4><pre><code>var urlObjc = url.parse(req.url,true);// 要什么值就在返回的对象中取{    protocol: null,//协议名    slashes: null,//表示 //到第一个/之间都是host    auth: null,//认证    host: null,//主机名+ 端口号  hosetname+port    port: null,//端口号    hostname: null,//主机名  ip地址    hash: null,//资源定位符    search: &apos;?name=OldFe&amp;age=18&apos;,    query: { name: &apos;OldFe&apos;, age: &apos;18&apos; },//get请求的参数对象    pathname: &apos;/getRequest&apos;,//路径    path: &apos;/getRequest?name=OldFe&amp;age=18&apos;,//路径+请求参数    href: &apos;/getRequest?name=OldFe&amp;age=18&apos; }}</code></pre><h4 id="post请求的处理"><a href="#post请求的处理" class="headerlink" title="post请求的处理"></a>post请求的处理</h4><ul><li>post请求的参数是在请求体中，无法使用get的方式来接收post请求的参数</li><li><p>post请求的参数无法一次获取，有可能是多次 原因：post可以提交大数据，而宽带有网络限制</p><pre><code>1.需要给请求对象注册一个data事件,用来收集数据流2.再注册一个end事件, 数据流接受完毕, 3.在end事件中, 使用用querystring模块中的parse方法取解析post请求参数4.异步返回数据: 将解析好的数据作为回调函数的参数传入, 在需要用到参数的地方使用  function bodyParse(req, callback) {    let postData = &apos;&apos;;    req.on(&apos;data&apos;, (chuck) =&gt; {        //将客户端每一次的数据流放入postData中        postData += chuck;    });    req.on(&apos;end&apos;, () =&gt; {        // 使用querystring模块解析post参数        let param = querystring.parse(postData);        //异步返回: 使用回调函数的方式        callback(param);    });};</code></pre></li></ul><h2 id="Node服务端的开发流程介绍"><a href="#Node服务端的开发流程介绍" class="headerlink" title="Node服务端的开发流程介绍"></a>Node服务端的开发流程介绍</h2><p>先说一下Web开发三大项:</p><pre><code>1. 客户端发起请求: 发送url2. 服务端处理请求: 提取url参数,进行对应的增删改查处理3. 服务端响应客户端: 向客户端发送处理后的数据</code></pre><h4 id="服务端的工作流程"><a href="#服务端的工作流程" class="headerlink" title="服务端的工作流程"></a>服务端的工作流程</h4><h5 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h5><pre><code>1.创建服务器()2.开启服务(监听端口)</code></pre><h5 id="设计路由-gt-类似于接口文档"><a href="#设计路由-gt-类似于接口文档" class="headerlink" title="设计路由 ==&gt; 类似于接口文档"></a>设计路由 ==&gt; 类似于接口文档</h5><pre><code>路由: 不同的url请求 有对应的处理程序来进行处理    1. 请求的url:        包括: a.路径, b.请求方式 c.请求参数    2. 响应:        响应的数据路由的种类:    1. 静态资源路由, 返回静态文件    2. 动态路由, 处理对应的业务逻辑        比如: 登陆 /login; 注册/register等...</code></pre><h5 id="处理路由"><a href="#处理路由" class="headerlink" title="处理路由"></a>处理路由</h5><pre><code>处理过程:      1.获取req的请求参数    2.逻辑处理, 即数据库的增删改查操作    3.响应请求</code></pre><p>​    </p><h2 id="Express框架开发流程"><a href="#Express框架开发流程" class="headerlink" title="Express框架开发流程"></a>Express框架开发流程</h2><h4 id="为什么使用express"><a href="#为什么使用express" class="headerlink" title="为什么使用express?"></a>为什么使用express?</h4><pre><code>原生Node处理静态资源和路由比较繁琐,逻辑性不直观等;express框架封装原生node的处理方式,我们可以直接调用API即可...使用Express可以快速搭建出一个web项目...在Express中, 一切都是中间件...中间件?    中间件是一个函数: 如(req,res,next)=&gt;{ req:请求对象  res:响应对象  next:调用下一个中间件 }</code></pre><h4 id="Express使用-举个简单的例子-详细的还是去查官方文档"><a href="#Express使用-举个简单的例子-详细的还是去查官方文档" class="headerlink" title="Express使用: 举个简单的例子, 详细的还是去查官方文档"></a>Express使用: 举个简单的例子, 详细的还是去查官方文档</h4><pre><code>1. 静态资源托管app.use(&apos;/views&apos;, express.static(__dirname + &apos;/views&apos;));app.use(&apos;/node_modules&apos;, express.static(__dirname + &apos;/node_modules&apos;));2. 路由中间件app.get(&apos;/&apos;, function (req, res) { res.send(&apos;root&apos;)}); // 路由路径将请求与根路由 / 匹配参数二: 就是一个中间件处理函数,处理分发过来的路由...app.use(&apos;路由路径&apos;, 路由处理模块);3. 中间件    https://expressjs.com/zh-cn/guide/using-middleware.html; 官方文档    express中使用中间件: app.use() app.get() app.post()    中间件类型:        应用层中间件        路由器层中间件        错误处理中间件        内置中间件        第三方中间件: 安装, 导包, 调用4.GET请求和POST请求的参数    1.get参数:        Express中，不需要使用url模块了。可以直接使用req.query对象    1.post参数:        Express中，必须使用body-parser模块。使用后，将可以用req.body得到参数。        如果表单中含有文件上传，那么还是需要使用formidable模块</code></pre><h2 id="nodejs下操作MongoDB数据库"><a href="#nodejs下操作MongoDB数据库" class="headerlink" title="nodejs下操作MongoDB数据库"></a>nodejs下操作MongoDB数据库</h2><pre><code>1.安装并导入第三方包mongoose2.调用相关API    // 连接数据库 connect(&apos;数据库uri&apos;)    // 创建模型Model(表)        let Model = mongoose.model(&apos;表名&apos;, {字段: 数据类型})    // 新增    Model.create(条件: 对象||数组, err =&gt; {xxoo})    // 删除    Model.deleteOne(条件: 数据对象, err =&gt; {xxoo})  // 满足条件的第一个    Model.deleteMany(数据对象, err =&gt; {xxoo}) // 满足条件的所有数据    // 修改    Model.update(原对象, 新对象, err回调)    Model.updateMany(原对象, 新对象, err回调)    // 查询:     // 参数1: 条件; 参数2:回调函数 (err, docs) =&gt; { 查询结果docs是一个数组}    find(条件: 对象, (err, docs) =&gt; {xxoo})</code></pre><h2 id="基于Express下的MVC模式开发流程"><a href="#基于Express下的MVC模式开发流程" class="headerlink" title="基于Express下的MVC模式开发流程"></a>基于Express下的MVC模式开发流程</h2><p><strong>流程图:</strong></p><p><img src="https://i.imgur.com/Co8znBP.png" alt=""></p><p><strong>1.基于Express项目的MVC架构设计(确定项目文件夹中每一个文件的职责)</strong></p><pre><code>1.app.js    * 服务器入口文件(相当于主程序)    * 主程序运行起服务, 导入中间件包,配置并使用中间件(用到什么就配置什么),这些中间件一般都是为req和res服务的     * 最后调用路由模块2.router    * 负责路由分发    * 导入路由处理模块; 使用路由中间件, 一个路由 ==(映射)==&gt; 一个处理程序    * 导出模块到main主程序3.C层 (核心模块)    * 负责处理业务逻辑(负责V与C的沟通)    * 导出数据层配置好的数据模块, 并调用其增删改查方法, 对请求参数进行业务逻辑处理, 然后返回响应数据...    * 导出模块...4.M层    * 负责管理数据（配置数据库参数,字段信息等; 如mongoose中的model）    * 数据库操作层, 负责连接服务, 配置数据库操作对象等...  5.resource:静态资源    使用express中间件去托管静态资源    V层：html静态资源    images:图片静态资源</code></pre><p>2.准备工作：（安装项目中用到的模块）</p><pre><code>1.初始化npm： `cnpm init -y`2.安装：  `cnpm i 模块名 --save`    * 第三方模块 (下载项目中需要用到的模块)        * 举个栗子: 如express, juery, mongoose, bootstrap等...    * express中间件        * 用来处理 web中请求request, 响应response等..         * 如 body-parser,cookie-session, </code></pre><p>3.使用express搭建服务器入口文件</p><pre><code>* 1.导入express* 2.创建服务器app* 3.配置中间件    * 静态资源中间件    * 第三方中间件    * 自定义中间件    * // 注意中间件的使用顺序 next参数        * 4.开启服务器</code></pre><p>4.搭建router：设计接口文档</p><pre><code>路由: 即标识资源的部分 URL在收到view层的页面资源请求后服务器会的路由模块程序 进行路由分发... 即:url 到 C层处理方法的一个映射, 一个请求对应一个处理方法// 需要注意: 请求类型和路径, 调用哪个接口...</code></pre><p>5.搭建C层：负责真正处理业务逻辑</p><pre><code>对请求req传过来的get和post请求进行参数获取, 根据参数执行对应的业务逻辑操作,如权限认证, 数据的增删改查等...处理完请求, 还要返回 响应数据...// 这里要注意cookie, session, token的处理</code></pre><p>6.搭建M层：mongoose</p><pre><code>配置好数据服务</code></pre><h2 id="cookie和session以及token区别和使用"><a href="#cookie和session以及token区别和使用" class="headerlink" title="cookie和session以及token区别和使用"></a>cookie和session以及token区别和使用</h2><p>由于HTTP是一种无状态的协议，为了分辨请求是谁发起的，需自己去解决这个问题。不然有些情况下即使是同一个网站每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制,token呢? 相当于一个令牌, 有了这个令牌才能在一个客户端登陆,是基于session实现单点登陆的一种方法吧…</p><p><strong>下面便来做一下的详细介绍</strong></p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>cookie是在我们访问某些网站后在客户端本地存储的一些网站相关信息，下次访问时可以减少一些步骤。更准确的说法是：Cookies是客户端首次访问服务器, 服务器生成的小段文本并返回给客户端存储,下次客户端再向该网站发起请求时会携带在请求头中，是在客户端保持状态的方案。</p><p>Cookie的主要内容包括：</p><pre><code>以key, value的形式存储: 包括名字，值，过期时间，路径和域。过期时间可设置的，如不设，则浏览器关掉就消失了，存储在内存当中，否则就按设置的时间来存储在硬盘上的，过期后自动清除，比方说开关机关闭再打开浏览器后他都会还存在，前者称之为Session cookie 又叫 transient cookie，后者称之为Persistent cookie 又叫 permenent cookie。路径和域就是对应的域名，a网站的cookie自然不能给b用。</code></pre><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p><strong>session是存在服务器的一种用来存放用户数据的对象,也是包含在cookie当中的键值对。</strong><br>浏览器第一次发送请求时，服务器自动生成了一HashTable和一Session ID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。</p><pre><code>一般这个值会有个时间限制，超时后毁掉这个值，默认30分钟。当用户在应用程序的 Web页间跳转时，存储在 Session 对象中的变量不会丢失而是在整个用户会话中一直存在下去。Session的实现方式和Cookie有一定关系。建立一个连接就生成一个session id，打开几个页面就好几个了，这里就用到了Cookie，把session id存在Cookie中，每次访问的时候将Session id带过去就可以识别了.设置session的过期时间:    1. 修改服务端中配置的session生命周期    2. 通过时间戳来手动删除(unset)session值</code></pre><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>token也是存放在cookie中的一个键值对，主要作用是单点登入;<br>即在session存在的前提下(也就是用户已处于登录状态)使用,</p><pre><code>1.同一用户使用A设备登录，服务器会根据时间戳生成一个token1。放到cookie中发给客户端，一份存入数据库2.同一用户使用B设备登录，服务器会根据时间戳生成新的token2.放到cookie中发给客户端，一份存入数据库(token2覆盖token1)3.当用户访问服务器时候，服务器会检查用户的token和当前数据库存储的token是否一致，如果不一致则清空用户session（服务器强制下线）</code></pre><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><p><strong>cookie</strong></p><p>登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</p><p><strong>session</strong></p><p>session一个场景是购物车，添加了商品之后客户端可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</p><p><strong>token:</strong></p><p>做单点登陆使用</p><p><strong>区别:</strong></p><pre><code>1、Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。2、Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session是没有大小限制和服务器的内存大小有关。3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。5、token是在session存在的情况对用户在多设备登陆时做判断处理, 实现单点登陆。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;br&gt;文章主要是对平时在node学习中常用的一些方法做的一个总结笔记…&lt;br&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue基础总结</title>
    <link href="http://yoursite.com/2019/01/21/vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/21/vue学习/</id>
    <published>2019-01-21T02:53:33.000Z</published>
    <updated>2019-02-24T07:13:05.506Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:<br>主要记录一下vue在平时使用中和学习中的一些总结; 相关内容总结都是基于了通读&lt;Vue实战&gt;这本书来做的, 首先是基础篇的内容…<br><a id="more"></a></p><h1 id="VUE学习"><a href="#VUE学习" class="headerlink" title="VUE学习"></a>VUE学习</h1><h2 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么?"></a>vue是什么?</h2><p>根据概念来说, vue是一套用于构建用户界面的渐进式框架; 以我初学者的角度来说(基础性理解)我觉得vue就是一套用数据来渲染DOM结构的系统, 它给了模板,我们只需要把处理好的数据填充进去就好…</p><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><p>####vue使用基本步骤</p><pre><code>// 创建vue实例    1.先引入框架文件vue.js    2.使用Vue构造函数 实例化一个vue对象; new Vue({...})    3.在实例的初始化过程中添加必要的配置: 即必要的属性和方法!!!    4.这些属性和方法都是哪些呢?在之后的内容会逐一介绍        1.el属性: (DOM元素或选择器) 就是HTML结构中模板元素,也是vue实例要 操作的DOM对象        2.data属性: 模板中的数据来源  { 模板变量: 数据 }        3.生命周期钩子; vue实例在创建-执行-结束整个过程会执行的一些方法,如created, mounted, beforeDestroy        4.methods属性: 存放一些事件的处理逻辑        5.本篇先暂时介绍这几个....// 准备vue实例要用的html模板    1.vue实例与要与dom元素绑定才能对其进行相应操作,所以要准备好模板元素    2.接下来就可以向模板中传值(也可以叫插值), {{变量名}}要与实例的data属性中的字段一样    3.{{花括号中也可以使用js的简单的表达式}}// html模板中使用vue指令和事件    1.在DOM元素的标签中插入指令; 插值支持模板字符串写法    2.可以理解为往行内元素添加属性和值; 只不过它们它们的属性只是一个变量或者说对象,可以随意改变    3.当指令对应的值发生改变就会 执行值对应行为并反馈到DOM元素上    4.这一节学习的指令和事件:        v-if: 条件指令        v-html: 只会输出真正的 HTML; 慎用!!!不要使用用户的值进行插入, 容易导致XSS攻击        v-pre: 加了v-pre可以随意输出, {{}}中的内容不会被解析        v-bind: 使用v-bind:href 可以动态更新行内属性; 简写方式 :href=&quot;字段名&quot;; :src=&quot;字段名&quot;;        v-on: 用来绑定事件;&lt;button v-on:click=&quot;方法名&quot;&gt;点击&lt;/button&gt;;方法名也可以写成行内语句,                 简写的话就是 @click=&quot;方法名&quot;        v-for: 用来遍历数组和对象 (item, index) in arr        v-model指令: 表单输入绑定,监听用户的输入事件来更新数据        //&lt;input v-model=&quot;属性名&quot;&gt;:  其本质是 输入事件@input 对输入框输入值进行监听,         上面代码等价于 &lt;input :value=&quot;属性&quot; @input=&quot;属性=$event.target.value&quot;&gt;; 即绑定value值&amp;&amp;绑定input事件        v-model可以实时给input赋值和取值        // v-model在select列表(注意option的value值) &amp;&amp; radio单选 &amp;&amp; checkbox(注意v-model绑定数组)多选下 要有对应的value值</code></pre><h4 id="2-下面上两个实践的例子"><a href="#2-下面上两个实践的例子" class="headerlink" title="2.下面上两个实践的例子"></a>2.下面上两个实践的例子</h4><ol><li><p>demo1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本插值 --&gt;</span></span><br><span class="line">&#123;&#123; text &#125;&#125; <span class="tag">&lt;<span class="name">span</span>&gt;</span>  花括号中放 vue实例 data属性中的一个字段 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>当前时间:<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"font-size: 20px"</span>&gt;</span> &#123;&#123; date &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line">&#123;&#123;在这里写东西好像不起作用, 这里放的data中html标签内容&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span> 加了v-pre可以随意输出, 不会被解析  &#123;&#123; xxoo &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>在&#123;&#123;&#125;&#125;中写JavaScript代码: 只支持单个表达式, 不支持语句和流程控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123; `支持模板字符串语法: 这是一个模板字符串拼接: $&#123;name&#125;` &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">&#123;&#123; name.split('').join("=") &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span> filters属性 &#123;&#123; 变量 | 过滤器函数(), 可以串联多个; 还可以传参; 主要是对数据进行简单的文本处理 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; data | formatData &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../vuelibs/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 创建 vue实例对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,  <span class="comment">// 指定一个 DOM元素 挂载vue实例</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 也可以给data传一个已存在的变量, </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 变量中的数据和实例中的data数据是双向绑定的, 一变都变</span></span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 模板用到的数据字段 都在这里声明,这种方式为 显示声明</span></span></span><br><span class="line"><span class="javascript">            name: <span class="string">'xxxx'</span>,  <span class="comment">// 数据中name字段 对应模板中 name</span></span></span><br><span class="line"><span class="javascript">            text: <span class="string">'文本插值'</span>,</span></span><br><span class="line"><span class="javascript">            date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 输出html</span></span></span><br><span class="line"><span class="xml">            html: '<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span> 这是绑定的一个html元素, 一个a标签 <span class="tag">&lt;/<span class="name">a</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 生命周期钩子: created, mounted, beforeDestroy</span></span></span><br><span class="line"><span class="undefined">        created() &#123; </span></span><br><span class="line"><span class="javascript">            <span class="comment">// 实例创建完后, 调用; 但还未挂载到DOM节点上, 主要用于初始化处理一些数据</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> _this = <span class="keyword">this</span>; <span class="comment">// 让定时器函数可以使用vue实例对象中的 this</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="javascript">                <span class="comment">// 修改date的值</span></span></span><br><span class="line"><span class="javascript">                _this.date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">            &#125;, 1000)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        mounted() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// el挂载到实例后开始调用, 通常是第一个业务逻辑代码</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="comment">// beforeDestroy: 实例销毁前调用, 用于解绑事件</span></span></span><br><span class="line"><span class="undefined">        beforeCreate() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 清除定时器</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="keyword">this</span>.date) &#123;</span></span><br><span class="line"><span class="javascript">                clearInterval(<span class="keyword">this</span>.timer);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 过滤器filters属性: 用于处理简单的文本转换</span></span></span><br><span class="line"><span class="undefined">        filters: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// formData</span></span></span><br><span class="line"><span class="javascript">            formatData: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 过滤时间值</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> year = date.getFullYear(); <span class="comment">//年</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 月份数字为 0-11; 需要+1</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> month = <span class="built_in">String</span>(date.getMonth()+<span class="number">1</span>).padStart(<span class="number">2</span>, <span class="number">0</span>); </span></span><br><span class="line"><span class="javascript">                <span class="comment">//进行小于10的补零处理</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> day = <span class="built_in">String</span>(date.getDate()).padStart(<span class="number">2</span>, <span class="number">0</span>);   </span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> hour = <span class="built_in">String</span>(date.getHours()).padStart(<span class="number">2</span>, <span class="number">0</span>);   </span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> minutes = <span class="built_in">String</span>(date.getMinutes()).padStart(<span class="number">2</span>, <span class="number">0</span>);   </span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> seconds = <span class="built_in">String</span>(date.getSeconds()).padStart(<span class="number">2</span>, <span class="number">0</span>);  </span></span><br><span class="line"><span class="javascript">                <span class="comment">// 返回处理好的字符串</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;day&#125;</span> <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minutes&#125;</span>:<span class="subst">$&#123;seconds&#125;</span>`</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>2.demo2</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-if指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"condition"</span>&gt;</span>v-if指令: 满足条件就显示该文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"condition1"</span>&gt;</span>不满足条件就会移除文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"myLink"</span>&gt;</span>v-bind:href 动态更新行内属性; 简写,冒号:表示v-bind<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"myImg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>v-on指令: 用来绑定事件; 可以把方法名写成行内语句, 简写,@表示v-on:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"handleClose"</span>&gt;</span>点击移除上面文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"open"</span>&gt;</span>点击添加上面文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// vue指令的主要职责就是当其表达式的值改变时，相应地 将某些行为应用到 DOM 上，</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 元素</span></span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定数据</span></span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 数据驱动 DOM ; 控制对应数据的添加和移除</span></span></span><br><span class="line"><span class="undefined">        condition: 1,</span></span><br><span class="line"><span class="undefined">        condition1: 1,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// v-bind更新行内属性</span></span></span><br><span class="line"><span class="javascript">        myLink: <span class="string">'https://www.baidu.com'</span>,</span></span><br><span class="line"><span class="javascript">        myImg: <span class="string">'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Revista_t%C3%BA.jpg/200px-Revista_t%C3%BA.jpg'</span>, </span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 事件方法; 都写在实例的methods属性中</span></span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">        handleClose() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 方法中的 this 指向的是当前 Vue 实例本身</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 可以直接使用 this.xxx 的形式来访问或修改数据，</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// this.condition1 = 0;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 支持代理方法</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.close();  </span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 关闭方法</span></span></span><br><span class="line"><span class="undefined">        close() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.condition1 = <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 两种写法意思一样, 上面是简写模式</span></span></span><br><span class="line"><span class="javascript">        open: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 修改condition1的值</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.condition1 = <span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><p><strong>计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结 果就可以。当然，计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。</strong></p><p>下面直接上例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; textOutput &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>计算属性computed: 有返回值, 并且返回值可以依赖多个vue实例的数据来发生改变<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>举个栗子: 购物车价格变化<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     购物车结算: ¥&#123;&#123; goodPrice &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 1号购物栏</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> pack1 = [</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">'XPS'</span>,</span></span><br><span class="line"><span class="undefined">        price: 7999,</span></span><br><span class="line"><span class="undefined">        count: 1,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">'Mac'</span>,</span></span><br><span class="line"><span class="undefined">        price: 17999,</span></span><br><span class="line"><span class="undefined">        count: 2,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">];</span></span><br><span class="line"><span class="javascript"><span class="comment">// 2号购物栏</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> pack2 = [</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">'apple'</span>,</span></span><br><span class="line"><span class="undefined">        price: 88,</span></span><br><span class="line"><span class="undefined">        count: 3,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">'banana'</span>,</span></span><br><span class="line"><span class="undefined">        price: 19,</span></span><br><span class="line"><span class="undefined">        count: 5,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">]</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">        text: <span class="string">'123456789'</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// json的简写</span></span></span><br><span class="line"><span class="undefined">        pack1,</span></span><br><span class="line"><span class="undefined">        pack2,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 计算属性: computed; 专门用于计算</span></span></span><br><span class="line"><span class="undefined">    computed: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 所有的计算属性都以函数的形式写在 Vue 实例内的 computed 选项内，最终返回计算后的结果</span></span></span><br><span class="line"><span class="undefined">        textOutput() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="keyword">this</span>.text.split(<span class="string">''</span>).reverse().join(<span class="string">'-'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算上面商品的总价</span></span></span><br><span class="line"><span class="undefined">        goodPrice() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 分别获取到pack1 和 pack2 的price &amp;&amp; count的属性值</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> totalGoods = [...pack1, ...pack2];</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 拿到每一项元素的values().price 和values().count</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> totalGoods.reduce(</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 每一项汇总</span></span></span><br><span class="line"><span class="undefined">                (num, item, index, arr) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span>  num + item.price * item.count;</span></span><br><span class="line"><span class="undefined">                &#125;, 0);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>计算属性的缓存特性</li></ul><blockquote><p>计算属性缓存: 一个计算属性所依赖的数据发生变化时，它才会重新取值;不然他的值不会改变,可以缓存现在的值;当我们当遍历大数组和做大量计算时,就可以使用计算属性…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;br&gt;主要记录一下vue在平时使用中和学习中的一些总结; 相关内容总结都是基于了通读&amp;lt;Vue实战&amp;gt;这本书来做的, 首先是基础篇的内容…&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(五)</title>
    <link href="http://yoursite.com/2019/01/17/ES6%E6%80%BB%E7%BB%93(%E4%BA%94)/"/>
    <id>http://yoursite.com/2019/01/17/ES6总结(五)/</id>
    <published>2019-01-17T02:53:33.000Z</published>
    <updated>2019-01-17T13:41:30.036Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是关于ES6中生成器函数 和 Promise对象的相关总结和理解…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="Generator函数的定义"><a href="#Generator函数的定义" class="headerlink" title="Generator函数的定义"></a>Generator函数的定义</h2><p><strong>书中的说法是:</strong><br>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象,也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p><strong>我的理解:</strong><br>生成器函数可以理解为: 函数内部是由多个小函数组成的, 使用yield关键字将函数内部 分割成多个块区域; 并且当函数执行时, 遇到yield就会停止, 并且将yield 后面的表达式结果输出(当然外部要调用next()方法); 下次再调用next()方法时, 就从上一个停止的地方开始执行(这意味着函数有有记忆功能); 如果下面没有再遇到yield的话 就像普通函数执行完. 函数的返回值是一个可迭代对象(遍历器对象); 我喜欢叫可迭代对象, 或者说可遍历对象…</p><h2 id="说一说可迭代对象-iterator-的next-方法"><a href="#说一说可迭代对象-iterator-的next-方法" class="headerlink" title="说一说可迭代对象(iterator)的next()方法"></a>说一说可迭代对象(iterator)的next()方法</h2><pre><code>function CreateIterator(iterator) {// 定义一个初始下标用来判断let nextIndex = 0;// 返回对象: 包含的next方法, return {    next: function () {        // 返回一个对象: value是当前对象下标对应的值, done是是否遍历完成        return nextIndex &lt; iterator.length ?                // i++ 先参数运算在 自增1                 {value: iterator[nextIndex++], done: false} :                {value: undefined, done: true};        }    }}// 实例化一个遍历器let iter1 = CreateIterator([1,2,3,4,5]);console.log(iter1); // 一个具有next方法的对象console.log(iter1.next().value); // 1console.log(iter1.next().value); // 2console.log(iter1.next().value); // 3console.log(iter1.next().value); // 4console.log(iter1.next().value); // 5console.log(iter1.next().value); // undefined</code></pre><h2 id="生成器函数的使用"><a href="#生成器函数的使用" class="headerlink" title="生成器函数的使用"></a>生成器函数的使用</h2><pre><code>generator生成器函数的使用:function *fn() {    代码1;     yield;     代码2;}普通函数: 执行到底生成器函数: 遇到yield会暂停,交出执行权,下次执行从上次的停止的位置继续生成器函数返回值为: 生成器对象生成器对象.next()方法才能执行 函数体中的代码// 可以解决函数回调嵌套的问题; 解决耗时操作function *func() {    // 请求数据.    // yield ajax()     // 处理数据} // generator函数本质上 分割成多个小函数来执行... yield关键字前后// 遇到yield就暂停; 没有就往下执行...// yield 起到了 暂停函数执行的作用</code></pre><h2 id="关于yield关键字的理解"><a href="#关于yield关键字的理解" class="headerlink" title="关于yield关键字的理解"></a>关于yield关键字的理解</h2><h4 id="yield传值"><a href="#yield传值" class="headerlink" title="yield传值"></a>yield传值</h4><p><img src="https://i.imgur.com/ZwwcK9s.png" alt=""></p><h4 id="yield输出值"><a href="#yield输出值" class="headerlink" title="yield输出值"></a>yield输出值</h4><p><img src="https://i.imgur.com/s3F9ZdG.png" alt=""></p><p>举个栗子:</p><pre><code>let output = [];function *g2(x, y) {    let sum = x+y;    yield sum; // sum是第一个输出结果    let agv = sum / 2;    yield agv; // agv 是第二个输出的结果    return {&quot;和&quot;: sum, &quot;平均数&quot;: agv}; // 最后一个结果}let gg2 = g2(100, 20);console.log(gg2.next().value);  // 120console.log(gg2.next().value);  // 60console.log(gg2.next().value);  // { &apos;和&apos;: 120, &apos;平均数&apos;: 60 }</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>这里只介绍一下使用的方法, 暂时理解的还不算透彻,后面会单独写一篇文章来说的…</p><p><strong>Promise对象 ==&gt; 主要是用来消除异步操作; 用同步的方式书写异步代码</strong></p><p>同步异步:</p><pre><code>// 异步: 操作之间没关系; 可以同时进行多个操作; 并发执行 &amp;&amp; 代码相对复杂// 同步: 同时只能做一个操作; 后面的操作需要等待        &amp;&amp; 代码相对简单</code></pre><p>promise的使用:</p><pre><code>let p = new Promise(function(resolve, reject) {    // 异步代码    // resolve 成功了    // reject 失败了    $.ajax({        type: &quot;method&quot;,        url: &quot;url&quot;,        data: &quot;data&quot;,        dataType: &quot;dataType&quot;,        success: function (response) {            resolve(response); // 成功的处理函数        },        error: function (obj){            reject(obj); // 失败的处理函数        }    });})// 然后调用promise对象.then()方法; 传两个函数p.then(function (结果1) {    console.log(&apos;成功&apos;);},function (结果2) {    console.log(&apos;失败&apos;);});</code></pre><p><strong>promise的应用</strong> </p><blockquote><p>如读取文件的操作, 如果是传统的ajax回调来实现, 则需要嵌套三层ajax请求才能完成三个文件的读取…<br>promise.all().then() 主要用于一次性读取操作…批量的;<br>如果是带有逻辑异步操作, 则使用生成器函数 + promise对象的方式来实现… let output = yield $.ajax({url: “test/arr.txt”, dataType: “json”})的方式; 这个以后单独说</p></blockquote><pre><code>Promise.all([    $.ajax({url: &quot;test/arr.txt&quot;, dataType: &quot;json&quot;}),    $.ajax({url: &quot;test/json.txt&quot;, dataType: &quot;json&quot;}),    $.ajax({url: &quot;test/str.txt&quot;, dataType: &quot;json&quot;}),]).then( success =&gt; {    // 异步任务请求成功; 返回的success就是成功的结果    let [arr, json, str] = success;    alert(&apos;异步任务请求成功...&apos;)    console.log(arr, &apos;\n&apos;,  json, &apos;\n&apos;, str);},error =&gt; {    // 异步任务失败;     console.log(&apos;fail to read file&apos;);})</code></pre><p>返回结果:</p><p><img src="https://i.imgur.com/Dvfa1e9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇是关于ES6中生成器函数 和 Promise对象的相关总结和理解…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>js中的正则</title>
    <link href="http://yoursite.com/2019/01/14/js%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2019/01/14/js中的正则/</id>
    <published>2019-01-14T02:53:33.000Z</published>
    <updated>2019-01-15T00:38:11.974Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于对js中正则表达式的一些小小的总结和使用…<br><a id="more"></a></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><pre><code>正则: 专门用来处理字符的工具; 常见的处理方式: 对源字符串进行过滤,得到目标字符串; 查找到目标字符串核心: 匹配模式 =&gt; 字符串对象 但我们使用正则时:  需要想到这几个方面: 字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。</code></pre><h2 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h2><pre><code>. ： 匹配除了换行符之外的任何单个字符\ ： 对特殊字符进行转义，使其呈现字面量的意思; 例: 模式 /a\*/ 将 &apos;*&apos; 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。| ： 逻辑或操作符[] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身[^]：对上面一个集合取非- ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面</code></pre><h2 id="数量字符"><a href="#数量字符" class="headerlink" title="数量字符"></a>数量字符</h2><pre><code>{m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次+ ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次* ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词 *,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式</code></pre><h2 id="位置字符"><a href="#位置字符" class="headerlink" title="位置字符"></a>位置字符</h2><pre><code>^ ： 匹配表达式的开始\$ ： 匹配表达式的结束</code></pre><h2 id="快捷匹配模式"><a href="#快捷匹配模式" class="headerlink" title="快捷匹配模式"></a>快捷匹配模式</h2><pre><code>\d：[0-9]，表示一位数字，记忆方式 digit\D：[^0-9]，表示一位非数字\s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character\S：[^\t\v\n\r\f]，表示非空白符\w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word\W：[^0-9a-zA-Z]，表示非单词字符</code></pre><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><pre><code>// g: 全局匹配// i: 忽略大小写</code></pre><h2 id="re对象的方法"><a href="#re对象的方法" class="headerlink" title="re对象的方法"></a>re对象的方法</h2><pre><code>// re: 正则对象// 1. re.rest(&quot;str&quot;) // 正则表达式匹配模式 =&gt; 目标字符串 :  就是拿正则去源字符串中去比对, 结构相同则返回// 返回值:  包含匹配模式则返回 true 否则返回 false// 2. re.exec(&quot;str&quot;)     // 没有匹配到; 返回null    // 匹配到了(分有g 和 无g), 返回一个数组// 使用场景: 字符串对象的方法: 查找,匹配,判断,替换等...// 1.String.search(re)  // 参数: 正则对象   返回值: 子串下标 或者 -1let str1 = &apos;dsahjoa@#$#$._-=--dsa4445da++11!!!&apos;;console.log(str1.search(/\d+/));console.log(str1.search(/[A-Z]/));// 2.String.match(re)// 参数: 正则对象   返回值: 不存在则返回 null; 数组,arr[0]是匹配到的元素// 加()会返回一个group,里面包含了我们想要的目标元素let str2 = &quot;hello world hell hall hole&quot;;console.log(str2.match(/ll/g).length); // 有全局标识g时, 返回匹配成员数组: [ &apos;ll&apos;, &apos;ll&apos;, &apos;ll&apos; ]console.log(str2.match(/hell/)); // 无g时, 返回值: [ &apos;hell&apos;, index: 0, input: &apos;hello world hell hall hole&apos; ], 长度为1// 默认时贪婪模式; 量词加?则为非贪婪模式// 3. String.replace(oldStr||re, newStr||function)// 参数1: 旧字符串或者正则// 参数2: 新字符串或者回调函数// 外部替换字符串let str3 = &quot;hello world&quot;;var str4 = str3.replace(&apos;hello&apos;, &apos;hi&apos;); // hi worldconsole.log(str3, &quot;\n&quot;, str4); // 内部子字符串替换var re = /(\w+)\s(\w*)/;str4 = str3.replace(re, &quot;$2, $1&quot;); //括号(分组)匹配出的字符串按顺序替换 console.log(str4); // world, hello// 4. String.split(param1, param2)// 参数1: 分割符: 字符||正则; 不传默认为空,全部分割; // 参数2: 指定分割字符的个数; // 返回值: 一个数组; 注意:正则中若有括号,返回值包括括号中的值console.log(str2.split(/\s/)); // [ &apos;hello&apos;, &apos;world&apos;, &apos;hell&apos;, &apos;hall&apos;, &apos;hole&apos; ]console.log(str2.split(/(\s)/)); // [ &apos;hello&apos;, &apos; &apos;, &apos;world&apos;, &apos; &apos;, &apos;hell&apos;, &apos; &apos;, &apos;hall&apos;, &apos; &apos;, &apos;hole&apos; ]</code></pre><h2 id="正则的模糊匹配"><a href="#正则的模糊匹配" class="headerlink" title="正则的模糊匹配"></a>正则的模糊匹配</h2><pre><code>// 1.指定多个数量的匹配: {m, n}; 也可以使用 * + let test = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log(test.match(/ab{1,3}/g));// 2. 指定多种情况的匹配: [字符组];  [^xx]非, /^xx/开头 [a-zA-Z0-9]表示范围// [xxx|yyy]: 惰性匹配, 匹配到xxx就不再往后匹配了let test1 = &quot;123456a123b456cdefGHIJKLM&quot;;console.log(test1.match(/\d+[a-c]/g)); // [ &apos;123456a&apos;, &apos;123b&apos;, &apos;456c&apos; ]// 3.指定位置的匹配: ^，$ 匹配字符的开头和结尾// 位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o* ， *代表位置// /^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置let test2 = &quot;hellodsadhello13123 dsawfa hellocahello2132&quot;;console.log(test2.match(/hello/g));console.log(test2.match(/^h.*?\d$/g));</code></pre><h2 id="几个练习题"><a href="#几个练习题" class="headerlink" title="几个练习题"></a>几个练习题</h2><pre><code>// 1. 驼峰改横线function tuo_to_heng(str) {    // helloWorld; 将字符串中大写字符找到, 用(-和自己)去替换(匹配到的大写)    // 那么我要确定字符的位置,还要用正则去匹配,     // 这个属于字符串内部子串替换, 可以使用$    var re = /([A-Z])/g;    return str.replace(re, &quot;-$1&quot;).toLowerCase();}console.log(tuo_to_heng(&quot;helloWorldJavaPython&quot;)); // hello-world-java-python// 2.获取网页链接中的参数// window.location.search() 获取的是: ?+参数// let url = &quot;https://www.baidu.com?name=哈喽world&amp;age=24岁&amp;gender=男&quot;;let url = &quot;https://www.baidu.com?    &quot;;function get_url_params(url) {    // 方法有很多; 可以截取?字符后的子串,在通过字符&amp;进行分割,再取=左右两边的值    // 1.判空,是否有参数    if (!url.includes(&apos;?&apos;) || !url.substr(url.indexOf(&apos;?&apos;)+1) == &apos;&apos;) {        // return &quot;链接没有参数&quot;;        return null;    }    // 2.取值    let str = url.substr(url.indexOf(&apos;?&apos;)+1);    let params = str.split(&apos;&amp;&apos;);    let paramObj = {};    // 也可以使用数组的forEach方法    for (let i = 0; i &lt; params.length; i++) {        paramObj[params[i].split(&apos;=&apos;)[0]] = decodeURIComponent(params[i].split(&apos;=&apos;)[1]);    }    return paramObj;}console.log(get_url_params(url));// 3.去除前后空格; 匹配到前面和后面的空格,用空字符替换字符串function trim(str) {    var re = /(^\s*) | (\s*$)/g;    return str.replace(re, &quot;&quot;);}var test = &quot;  sdd ds   &quot;;console.log(trim(test));</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于对js中正则表达式的一些小小的总结和使用…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="正则re" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99re/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(四)</title>
    <link href="http://yoursite.com/2019/01/10/ES6%E6%80%BB%E7%BB%93(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2019/01/10/ES6总结(四)/</id>
    <published>2019-01-10T02:53:33.000Z</published>
    <updated>2019-01-18T01:13:07.914Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是关于ES6中新增的两种数据结构Set和Map…用来存放多个数据的…这里总结比较浅,主要事掌握概念; 顺便提一下class关键字<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h2><blockquote><p>Set数据结构: 可以理解为没有重复成员的一个类似数组的对象; 就叫集合吧<br>结构形式: {1, 2, 3, 4}</p></blockquote><p>使用方法:<br>// 使用构造函数Set; 参数为一个可遍历的对象<br>const set = new Set([1,2,3,4]); // 实例化一个set; set结构是可迭代的对象<br>// 返沪值: {1, 2, 3, 4}</p><p>Set的属性和方法</p><pre><code>1. size: 返回set集合的大小, 即成员个数2. Set的增删查// add(value)：添加某个值，返回 Set 结构本身。// delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。// has(value)：返回一个布尔值，表示该值是否为Set的成员。// clear()：清除所有成员，没有返回值。3. Set遍历成员; Set的遍历顺序就是插入顺序。// keys()：返回键名的遍历器// values()：返回键值的遍历器// entries()：返回键值对的遍历器// forEach()：使用回调函数遍历每个成员, 回调参数为键值和set自身</code></pre><p>使用场景:</p><pre><code>Set作为一种数据结构,主要用来存放数据,并且内部成员不重复; 我们可以利用它的这个特性来做一些事.1.比如去重    let arr = [1,2,2,3,1,1,14];    let str = &apos;dsadaedwdwa&apos;;    console.log([...new Set(arr)]);    console.log([...new Set(str)].join());</code></pre><h2 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h2><blockquote><p>其实Map有点类似 python中的字典结构;<br>ES6中Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br>也就是说，Object 结构提供了“字符串: 值”的对应，Map 结构提供了“值 =&gt; 值”的对应</p></blockquote><p>结构形式: Map: { [ 1, 2, 3 ] =&gt; ‘数组’, ‘name’ =&gt; { name: ‘bob’ } }</p><p>使用方法:<br>使用构造函数Map 进行实例化; 参数为双元素的可迭代对象(能够调用next方法的对象)</p><pre><code>const newMap = new Map([[&apos;name&apos;, &apos;Blob&apos;], [&apos;age&apos;, 24]]);// 也可实例化一个空map对象,通过set(值1, 值2)方法去添加成员</code></pre><p>Map的属性和方法: 基本与上面的Set一致</p><pre><code>1.Map的增删查// set(key1, value1)：添加一个键值对// get(key); 获取某个键值对// delete(key)：删除某个键值对// has(key)：返回一个布尔值，表示该值是否为Map的成员。// clear()：清除所有成员，没有返回值。</code></pre><p>常用场景:</p><pre><code>可以使用扩展运算符...Map 可以实现与 数组,对象,json对象的互转</code></pre><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>for…of是ES6新增的语法;用来遍历具有Iterator 接口的对象; 这种对象有next()方法,\<br>可以对自身进行遍历,每一次调用便返回对应的值…</p><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、<br>Generator 对象，以及字符串。</p><h2 id="class关键字-类"><a href="#class关键字-类" class="headerlink" title="class关键字: 类"></a>class关键字: 类</h2><ul><li><p>ES5中的类实现</p><pre><code>// ES5中对象实例化的方法: 通过构造函数实例化function Func(x, y) {    this.x = x;    this.y = y;}// 给构造函数的原型添加属性Func.prototype.toString = function() {    // 把对象转为字符串    return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;}// 实例化一个对象var f = new Func(1,100);console.log(f.toString());</code></pre></li><li><p>ES6的类实现</p><pre><code>// ES6中 通class来定义类; 其实就是构造函数的改写,是js的语法更像后台语言class Func1 {    // 构造实例对象的方法; 相当于初始化    constructor(x, y) {        this.x = x;        this.y = y;    }    // 添加类方法: toString()方法    toString() {        return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;    }}// 类: 就是一个函数, 本身为一个构造函数; 也是通过new来实例化一个对象console.log(typeof Func1);console.log(Func1 === Func1.prototype.constructor); let f1 = new Func1();console.log(f1.__proto__.constructor); // 省略了__proto__// 类的方法都定义在prototype对象上</code></pre></li><li><p>ES6中的继承</p><pre><code>// ES6面向对象写法: class 替换 构造函数class User {    // 构造器, 初始化    constructor(name, pass) {        this.name = name;        this.pass = pass;    }    // 添加方法和属性    showName() {        console.log(this.name);    }    showPass() {        console.log(this.pass);    }}// 在继承 和 封装上的优势;  扩展性强...;  不用从0开始;; 可以使用前人造好的轮子// 继承超类的属性和方法    class VipUser extends User {        // 子类的初始化        constructor(level, ...args) {            // 相当于调用父类的constructor(name, pass)            super(...args);             // super作为函数调用时，代表父类的构造函数            // super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。            this.level = level;        }        // 方法        showLevel() {            console.log(this.level);        }    }    let vip = new VipUser(77, &apos;huhua&apos;, &apos;123&apos;); // 实例化    vip.showLevel();    vip.showName();    vip.showPass();    // 面向对象中类的应用实例    // 比如一个组件: 就是一个 class 继承一个组件    // JSX: == babel;  browser.js</code></pre></li></ul><h2 id="json简写模式"><a href="#json简写模式" class="headerlink" title="json简写模式"></a>json简写模式</h2><pre><code>// 1.JSON对象: 两个方法let json = {&quot;name&quot;: &apos;哈哈&apos;, &quot;sex&quot;: &quot;女&quot;}; // json对象键值必须是双引号let str1 = &apos;http://www.baidu.com?data=&apos; + encodeURIComponent(JSON.stringify(json)) ; // JSON对象转为json字符串console.log(str1);let str2 = JSON.parse(&apos;{&quot;a&quot;: 12, &quot;b&quot;: &quot;hello world&quot;}&apos;);console.log(str2); // JSON字符串 转为 对象console.log(str2.a);// 2.JSON简写// 简写:  如果key值和value是一样的; 直接写一个就可以了...// 可以省略一个funcion; 即 success: function(obj) {}  ==&gt; 可以写成 success(obj){}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇是关于ES6中新增的两种数据结构Set和Map…用来存放多个数据的…这里总结比较浅,主要事掌握概念; 顺便提一下class关键字&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(三)</title>
    <link href="http://yoursite.com/2019/01/09/ES6%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>http://yoursite.com/2019/01/09/ES6总结(三)/</id>
    <published>2019-01-09T02:53:33.000Z</published>
    <updated>2019-01-10T12:14:12.687Z</updated>
    
    <content type="html"><![CDATA[<p>第三篇是关于函数 和 rest参数方面的内容…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="函数参数设置默认值"><a href="#函数参数设置默认值" class="headerlink" title="函数参数设置默认值"></a>函数参数设置默认值</h2><pre><code>语法: function(x=默认值x, y=默认值y); 当然也可以使用解构赋值,使用对象的形式设置,({x=xxx, y=yyy})默认值参数放在括号尾部1. ES5中设置默认值的方式    function fn1(x, y) {        y = y || &quot;world&quot;; // ES5中,在函数体内赋值一个默认值        console.log(x, y);    }    fn1(&apos;hello&apos;); // hello world    fn1(&apos;hello&apos;, &apos;bob&apos;); // hello bob    fn1(&apos;hello&apos;, &apos;&apos;); // 传空值时也使用默认值    fn1(&apos;hello&apos;, false); // 传false时也使用默认值// ES6中 直接给()中参数赋默认值, 相当于初始化形参, 函数体内不允许let和const再次声明// ES6中会事先对参数y进行类型判断: typeof y === &apos;undefined&apos;; 是才给默认值    function fn2(x, y = &apos;ES6&apos;) {        console.log(x, y);    }    fn2(&apos;learning&apos;); //learning ES6     fn2(&apos;learning&apos;, &apos;&apos;); //learning 空也能输出    fn2(&apos;learning&apos;, false); //learning false 布尔值也可以2. 构造函数中用来初始化 函数的属性function Person(name=&apos;bob&apos;) {this.name = name};    也是可以直接在()中传默认值的3.解构赋值形式给函数传参例1:    function fn3({x, y = 100}) {        // 函数的形参接受一个对象; 函数传值也要传一个对象;        console.log(x, y);    };    // ES5中我们是传一个对象,然后再定义变量 保存 对象中对应的属性值    // ES6可以直接在形参中 去接受对应的属性值    fn3({}); // undefined 100;     fn3();  // 保错例2:    // 下面我们重写一下, 注意:::这种方式的传参是设置了对象解构赋值的默认值为空对象,这样直接调用便不会报错    function fn4 ({x, y = 101} = {}) {    // 不传值的情况下: 给函数一个默认参数: 空对象    console.log(x, y);    };    fn4(); //undefined 101; 相当于 fn4({});4.默认参数的作用域    函数()中式一个单独的作用域, ES6中函数体中的运算会先去()中找对应的变量进行运算</code></pre><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><pre><code>ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，参数都放在这个数组中。要使用的话,直接在函数体中遍历即可,当然...rest放在()尾部    举个栗子:        function add (...number) {            let sum = 0;            // number变量相当于一个存放形参的数组            // 可以使用数组的方法,也就是说,我们可以当作数组来操作这个参数number            // 基本方法 和 迭代方法都能使用            for (let num of number) {                sum += num;            }            return sum;        }         console.log(add(1,2,3,4,5)); // 15</code></pre><h2 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数 =&gt;"></a>箭头函数 =&gt;</h2><pre><code>1.箭头函数基本语法:     var 变量指向这个函数 = (参数1,参数2...) =&gt; {函数体大于一行时用大括号} 理解: ES6中箭头函数 相当于函数的简写,省略了function关键字,只有一个参数时还可以省略()    箭头左边是 (参数) =&gt; 箭头右边是函数体(一行代码可以省略大括号,直接写返回值表达式)     //如果返回的是一个对象则加括号({对象})2.常用的使用场景    2.1 回调函数的简化        // 比如数组常用的迭代方法map: 常规方法是 传入一个回调函数 function(x) {return x**2};        var arr1 = [1,2,5,3,6,0];        var result1 = arr1.map(x =&gt; x**2);        // 排序        var result2 = arr1.sort((a, b) =&gt; a - b); // [0,1,2,3,5,6]        // 箭头函数传rest参数        let arr3 = (...numbers) =&gt; numbers; // 自动将参数序列转为数组    2.2 嵌套使用; 函数式编程        例如:要实现将一个值 插入到数组 某个值的后面, 然后返回一个新数组        function insert (value) {            return {into: function (array) {                return {after: function (after_value) {                    // 起始位, 要删除的项, 替换项                    array.splice(array.indexOf(after_value) + 1, 0, value);                    return array;                }}            }}        }        // 用箭头函数实现; 简化了很多        // 声明一个变量指向函数; 不要忘记对象用()包起来        var insert = (value) =&gt; ({into: (array) =&gt; ({after: (after_value) =&gt; {            array.splice(array.indexOf(after_value) + 1, 0, value);            return array;        }})});        var res = insert(100).into([1, 2, 3]).after(2);        console.log(res); // [ 1, 2, 100, 3 ]3.箭头函数注意事项;     1.this对象 ==&gt; 指向定义时的对象, 而不是谁调用就指向谁了; 相当于固定了this指向        箭头函数根本没有自己的this，导致内部的this就是外层代码块的this        箭头函数中的this 相当于ES5中 引用了外层函数的this; 在外层函数用var _this = this; 然后在箭头函数中使用    2.箭头函数不能当作构造函数,不能使用new去声明    3.没有arguments对象了, 使用rest参数替代    4.不能使用yield, 不可以作为生成器函数</code></pre><h2 id="函数的尾调用"><a href="#函数的尾调用" class="headerlink" title="函数的尾调用"></a>函数的尾调用</h2><pre><code>函数的尾调用优化function f(x){    return g(x);    // 函数f的最后一步是 调用函数g，这就叫尾调用。}function f(x){    g(x);    // 函数没有明确返回值, 默认回返回undefined; 所以不是尾调用    return undefined;}优化思路: 用内层函数的调用帧，取代外层函数的调用帧(保存了函数调用后的信息)         相当于可以不用调用外层函数注意:    只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，    否则就无法进行“尾调用优化”。尾递归优化思路: 把所有用到的内部变量改写成函数的参数    1.参数设置成默认值的方式;      2.函数柯里化currying;意思是将多参数的函数转换成单参数的形式function Fibonacci (n , ac1 = 1 , ac2 = 1) {    if( n &lt;= 1 ) {return ac2};    // 尾部调用自身; 并且参数中保存了上一次调用帧; 节省内存    return Fibonacci (n - 1, ac2, ac1 + ac2);}console.log(Fibonacci(100)); // 注意:// ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三篇是关于函数 和 rest参数方面的内容…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(二)</title>
    <link href="http://yoursite.com/2019/01/07/ES6%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/01/07/ES6总结(二)/</id>
    <published>2019-01-07T02:53:33.000Z</published>
    <updated>2019-01-18T01:25:50.313Z</updated>
    
    <content type="html"><![CDATA[<p>第二篇是关于ES6中数据类型(字符串,数值,数组,对象)部分方法的扩展, 还有扩展运算符;我这里只总结了一些较为常用的方法扩展…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><pre><code>1. 处理4个字节存储的单个字符// 测试一个字符由两个字节还是由四个字节组成的最简单方法 (Unicode 编号大于0xFFFF)// codePointAt(下标): 返回10机制字节码;function is_32bit(char) {    return char.codePointAt(0) &gt; 0xFFFF;}console.log(is_32bit(&apos;𠮷a&apos;)); // true// 识别4个字节(32位)组成的单个字符console.log(String.fromCodePoint(0x20BB7)); // 𠮷 2.字符串的遍历for oflet text = &apos;我的名字&apos;;for (const char of text) {    console.log(char);}3.确定一个字符串中是否包含另一个目标字符串// includes(), startsWith(), endsWith() // 返回true和falseconsole.log(text.startsWith(&apos;我&apos;));console.log(text.endsWith(&apos;我&apos;));console.log(text.includes(&apos;我&apos;));4.repeat(num); 将字符串重复num次并返回console.log(text.repeat(3));5.字符串补全长度的功能// padStart()用于头部补全，padEnd()用于尾部补全// 参数1: 补全后的生效长度; 参数2: 用于补全的字符串(没有参数默认空格)// 长度过了; 会截取超出位数的字符串// 长度 &lt;= 原长度; 返回自己// 用途1: 将数值补全为指定位数console.log(&quot;1&quot;.padStart(10, &apos;0&apos;)); // 0000000001// 场景2: 日期补全console.log(&apos;09-12&apos;.padStart(10, &apos;2018-MM-DD&apos;)); // 2018-09-12</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>模板字符串: 反引号 ` 标识; // 变量名使用 ${变量名}; 可以省去字符串的拼接了let name = &quot;bob&quot;;let age = 24;console.log(`Hello ${name}, how are you ${age}?`);// ${这里面可以进行运算; 函数调用; 放对象的属性等}; 相当于执行js代码// 还可以相互嵌套当然,模板字符串的用法比较复杂,后续再深入总结</code></pre><h2 id="数值类型方法"><a href="#数值类型方法" class="headerlink" title="数值类型方法"></a>数值类型方法</h2><pre><code>// 1.检查数字为有限值Number.isFinite(12); // true; 其他类型都为false// 2.检查数值是不是NANNumber.isNaN(1+NaN); // true; NaN 数值与非数值运算的结果NaN// 3.Number.parseFloat 和 Number.parseInt; 将ES5的全局方法移到Number对象上// 4.Number.EPSILON * Math.pow(2, 2): 两个浮点数之间的最小误差; // 差值小于它, 就可以认为时相等// 5.Math方法的扩展console.log(Math.round(4.5)); // 5; 四舍五入// Math.trunc方法用于去除一个数(正负都可以)的小数部分，返回整数部分。console.log(Math.trunc(3.1)); // 兼容性写法// Math.trunc = Math.trunc || function(x) {//     return x &lt; 0 ? Math.ceil(x) : Math.floor(x);//  };// Math.sign()// 判断正负, 还是0; 对非数值,能转化的转化; 不能转的就是NaN// 返回值: 正 +1; 负 -1; 0; -0; 其他值 NaN</code></pre><h2 id="数组的扩展方法"><a href="#数组的扩展方法" class="headerlink" title="数组的扩展方法"></a>数组的扩展方法</h2><p>ES6将数组空位转为undefined</p><pre><code>1.Array.from(param1, param2)方法用于将两类对象转为真正的数组：    参数1: 一个对象 ==&gt; 伪数组对象和可遍历（iterable）的对象    参数2: 回调函数 ==&gt; 类似于数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。    return值: 一个数组;示例:    let arrayLike = {        &apos;0&apos;: &apos;a&apos;,        &apos;1&apos;: &apos;b&apos;,        &apos;2&apos;: &apos;c&apos;,        length: 3        // 0: &apos;a&apos;,        // 1: &apos;b&apos;,        // 2: &apos;c&apos;,        // length: 3    };    let real_arr = Array.from(arrayLike);2.Array.of(传一组数值); 用于将一组值，转换为数组。弥补了构造函数Array()传数值的缺点    参数: 一组数值,如: 1,2,3,4...    return值: 一个数组3.实例方法    3.1 arr.find(): 类似过滤函数filter(function(value, index, arr))        使用: 传入一个回调函数, 返回第一个符合要求的成员        示例: var res = [1,2,3,4,-100].find( n =&gt; n &lt; 0 ); // -100    3.2 arr.findIndex(): 同上,只不过是返回第一个符合条件的数组成员的位置        注意: 第二个参数是传一个对象，回调函数中若使用了 this, 则指向这个对象    3.3 arr.includes(): 判断数组中是否包含我们给定的值;这样以后就不用indexOf了    3.4 实例数组的遍历方法: entries()，keys() 和 values() 用于遍历数组 返回一个遍历器对象            // keys()是对键名的遍历:   对应索引            // values()是对键值的遍历: 对应值            // entries()是对键值对的遍历: 索引+值4.数组扩展方法 [a, b, c]    map映射, reduce汇总, filter过滤, forEach迭代    1. map: 一个映射一个     // [100, 59, 22] =&gt; [及格, 不及格, 不及格]    let score = [100, 59, 22];    let res = score.map( item =&gt; item&gt;60? &apos;及格&apos;:&apos;不及格&apos; );console.log(res);    2. reduce: 一堆变成一个    // temp为中间结果; 如果不设置,则为第一个下标为0的数    let res1 = score.reduce(function(temp, item, index, arr) {        if (index != arr.length - 1) {            return item + temp;        } else {            return (temp + item) / arr.length;        }    });     console.log(res1);    3.filter: 保留我想要的结果    let res2 = score.filter( item =&gt; item%11!=0);    console.log(res2);    4.forEach: 只是操作一下每一项; 返回值为undefined    let arr = [1,2,3,4]    arr.forEach(function (item, index, arr) {        // 这里可以用外部变量接受 这里面操作的值        console.log(index +&apos;:&apos;+ item);    });    console.log(res3); // undefined</code></pre><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>这里主要介绍一下对象的多种遍历方法;其他内容在扩展运算符…中总结.</p><pre><code>1.for...in    for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。2.Object.keys(obj),values(obj),entries(obj)    返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名,值,键值对。3.Object.getOwnPropertyNames(obj)    返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。4.Object.getOwnPropertySymbols(obj)    返回一个数组，包含对象自身的所有 Symbol 属性的键名。5.Reflect.ownKeys(obj)    返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</code></pre><h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><pre><code>1.扩展运算符是什么?    扩展运算符用三个点...表示: 相当于函数rest参数的逆运算, 可以将数组,对象中的成员序列化出来    我这里暂且把它理解为一种运算符吧, 用来解析各种数据类型的成员2.扩展运算符的使用场景?    2.1 将数组成员转为一个逗号分隔的参数序列:        这样调用一些数组的API时; 可以直接传一个...arr进去,省去了传参的麻烦        例1: console.log(...[1,2,3]); // 1 2 3        例2: var date = new Date(...[2015, 01, 01]);             console.log(date); // 2015-01-31T16:00:00.000Z    2.2 取代apply方法:         // ES5 的写法        let max1 = Math.max.apply(null, [14, 3, 77]);        // ES6 的写法        let max2 = Math.max(...[14, 3, 77]);    2.3 数组的深拷贝: 将对象全部拷贝一份,是一个独立的内存空间        let arr1 = [0, 1], arr2 = [...arr1]; // 用变量去接受经过扩展运算符运算的数组        arr1[0] = 100; // 修改数组arr1        console.log(arr1); // [ 100, 1 ] 发送改变        console.log(arr2); // [ 0, 1 ]   未改变    2.4 数组的合并        注意: 合并操作是浅拷贝: 是对数组中对象成员的引用        浅拷贝: (分为简单数据类型引用: 修改数据另一个不会变; 复杂数据类型引用: 修改后会改变)        arr3 = [...arr1, ...arr2]; // 此时arr3 为一个新数组; [ 100, 1, 0, 1 ],因为内部成员都是数值,        所以修改了arr1或者arr2中的元素也不会变        那么,如果数组中成员是对象; 则会改变成员属性,合并生成的数组成员也会变        const a1 = [{ foo: 1 }];        const a2 = [{ bar: 2 }];        const a3 = [...a1, ...a2];        console.log(a3); // [ { foo: 1 }, { bar: 2 } ]        a1[0].foo = 100;        console.log(a3); // [ { foo: 100 }, { bar: 2 } ]    2.5 可以和变量的解构赋值一起使用; 右边是对象也是可以的        let [first, second, ...rest] = [1,2,3,4,5,6];        console.log(first); // 1        console.log(second); // 2        console.log(rest); // [3,4,5,6]    2.6 还有与Array.from()方法类似的作用, 将 类似数组的对象和可迭代对象 转为真数组        console.log([...&apos;hello&apos;]); // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]        注意: 如果涉及到操作四个字节的 Unicode 字符的函数; 可以使用[...string], ...能够识别;    2.7 扩展运算符在对象中的使用        // 解构赋值, 如果右边数据是undefined或null 则解构会失败        let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; // x,1; y,2; z,{a:3, b:4}        // 注意: 如果扩展运算符后面不是对象，则会自动将其转为对象。        {...1}, {...true}, {...undefined}, {...null} 都会转为 空对象{}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二篇是关于ES6中数据类型(字符串,数值,数组,对象)部分方法的扩展, 还有扩展运算符;我这里只总结了一些较为常用的方法扩展…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门读书总结(一)</title>
    <link href="http://yoursite.com/2019/01/04/ES6%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/01/04/ES6总结(一)/</id>
    <published>2019-01-04T02:53:33.000Z</published>
    <updated>2019-01-09T11:54:44.496Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于阮一峰的es6入门书籍的读书总结; 第一篇关于let和const关键字, 块级作用域, 以及变量的解构赋值…<br><a id="more"></a></p><h1 id="ECMAScript-6-语法总结"><a href="#ECMAScript-6-语法总结" class="headerlink" title="ECMAScript 6 语法总结"></a>ECMAScript 6 语法总结</h1><h2 id="let和const声明变量"><a href="#let和const声明变量" class="headerlink" title="let和const声明变量"></a>let和const声明变量</h2><pre><code>// 块级作用域ES5中:     不合理场景1: 局部内层变量 可能覆盖掉 全局变量    合理场景2: for循环中 用var声明的 变量i; 会泄露成全局变量,循环结束并没有消失ES6中:**使用严格模式: &apos;use strict&apos;;1.声明的变量a的作用域为块级,并且只在自己所在的块级作用域起作用; 外层作用域不能访问内层, 内层可以访问外层的;2.内&amp;&amp;外层的同名变量互不干扰; 内层重新赋值也不会对外层造成影响;3.变量必须先声明,再使用,否则报错...(暂时性死区特性), 没有所谓的变量提升4.同一作用域不能重复声明同一个变量; 函数function第一层作用域变量声明不能和形参一样; 否则报错//注意:1. es5中var声明变量的特性:    a. var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。    b. es5中变量只有两种作用域: 全局 和 局部(函数内声明); 全局和局部都有变量提升现象;先提前,再进行赋值.    c. es6中可以使用var, 特性还是同es5一样2. es6中,变量在for循环中的使用    每一轮的i值 只在当前的循环中有效; 相当于每一次循环i都是一个新变量     // 1.循环变量在设置的时候是: 一个父作用域    // 2.循环体内部又是一个单独的子作用域    // 3.所以当同时两个块级作用域如使用相同的变量i,循环体内部会使用自己作用域声明的i3.ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。    // 1.避免在块级作用域内使用函数时声明的方式(function fn(){xxx})声明函数    // 2.可以使用表达式方式 let f = function(){}    // 也就是外层无法调用内层声明的函数...4.const声明一个常量: 该变量不能变化,是一个恒定值    const i = 100; // 定义时就需要初始化    // const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。    // 值类型:   数据就 等同于 这个常量的地址的值    // 引用类型: 这个常量 是一直指向一个固定的地址, 不能变的(修改指向就保错,即赋值操作); 只不过对象本身可变</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>解构赋值,我按照字面意思就是 解析数据解构, 然后给一一对应的变量进行赋值的一种语法</p><ul><li><p>解构的语法:</p><pre><code>=号左边是: 匹配模式; =号右边是: 实际的数据(或者数据对应的变量);解构的结果:    解构成功: 左边变量的值 就是右边对应变量的值    解构不成功: 即没有对应值匹配, 变量的值变为undefined    不完全解构: 左边的模式之匹配到右边数组的一部分</code></pre></li></ul><ul><li><p>变量是复杂数据类型(数组,对象)</p><pre><code>1.数组解构赋值    1.右边的值需要能够被遍历     2.允许左边给默认值: let [x=1, y=x] = [&apos;xxxx&apos;];    3.支持嵌套结构的 解构赋值注意:    let [x, y=true] = [&apos;xxxx&apos;]; // 右边数组对应成员要 === undefined    // console.log(x,y); // 如果是null, 则默认值不会生效;    // 如果右边 不是undefined, 则左边 会取到值2.对象的解构赋值    1.对象本身就是无序的, 是根据左右同名变量 来做赋值操作,匹配规则和数组类似    // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者    例: let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };    2.持嵌套结构的 解构赋值        let obj = {};        let arr = [];        ({foo: obj.num, bool: arr[0]} = {foo: 123, bool: true}); // 圆括号        console.log(obj, arr);3.对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量,几个例子    3-1 let {sin, cos} = Math; // 将math对象中方法给对象    3-2 取出数组的首尾2项        let list = [1,2,323,123,12,2];        let {0: first, [list.length-1]: last} = list;</code></pre></li><li><p>变量是简单数据类型(字符串,数值,布尔值)</p><pre><code>1.字符串的解构赋值    字符串被转换成了一个类似数组的对象: 可以理解未伪数组    let [a,b,c,d,e] = &apos;hello&apos;; // 每个变量对应一个字符2.数值和布尔值的解构赋值    解构赋值的规则: 只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined 和 null无法转为对象，所以对它们进行解构赋值，都会报错    所以, 数值和布尔值会先转成其包装对象Number 和 Boolean对象;然后可以赋值对象的属性</code></pre></li><li><p>函数参数的解构</p><pre><code>1.会将实参与形参一一对应console.log([[1, 2], [3, 4]].map(([a, b]) =&gt; a + b));</code></pre></li><li><p>圆括号注意事项</p><pre><code>// 圆括号问题// 解构模式中不能使用圆括号的情况// 1.变量声明语句// 2.函数参数也属于变量声明，因此不能带有圆括号// 3.赋值语句的模式; 左边的匹配模式不能使用圆括号可以使用圆括号// 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</code></pre></li><li><p>常用的使用场景</p><pre><code>变量之间值的交换; 函数中传参和接受返回值(对象的方式); 对象遍历...1.交换变量的值let v100 = 100;let v1 = 1;[v1, v100] = [v100, v1];console.log(v1, v100);2.接受函数的多个返回值: 比如数组,对象// 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。// 有了解构赋值，取出这些值就非常方便。function example() {return [1, 2, 3];}// let [a, b, c] = example();3.函数传参// 解构赋值可以方便地将一组参数与变量名对应起来// 参数是一组有次序的值function f([x, y, z]) {  }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) {  }f({z: 3, y: 2, x: 1});4.json数据的处理// 解构赋值对提取 JSON 对象中的数据，尤其有用。let jsonData = {id: 42,status: &quot;OK&quot;,data: [867, 5309]};let {id, status, data: arr1} = jsonData;console.log(id, status, arr1);5.设置函数参数的默认值// 避免了在函数体内部再写var foo = config.foo || &apos;default foo&apos;;// 在传参时; 特别是传一个对象参数时, 可以事先配置好参数的默认值// func({参数1 = true, 参数2 = false, ...} = {外部实参没有传值的就是用默认值}){}6.遍历 Map 结构// 可迭代对象, 都可以用for...of 来遍历const map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) {console.log(key + &quot; is &quot; + value);}// 获取键名for (let [key] of map) {    console.log(key);}// 获取键值for (let [,value] of map) {    console.log(value);}7.模块导入// 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰// const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); </code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于阮一峰的es6入门书籍的读书总结; 第一篇关于let和const关键字, 块级作用域, 以及变量的解构赋值…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>关于H5的一些新特性总结</title>
    <link href="http://yoursite.com/2019/01/03/H5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/01/03/H5的一些新特性/</id>
    <published>2019-01-03T02:53:33.000Z</published>
    <updated>2019-01-09T01:28:57.375Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容是关于html5的一些新的特性和方法总结…<br><a id="more"></a></p><h1 id="H5中的新特性"><a href="#H5中的新特性" class="headerlink" title="H5中的新特性"></a>H5中的新特性</h1><h2 id="新增的一些标签"><a href="#新增的一些标签" class="headerlink" title="新增的一些标签"></a>新增的一些标签</h2><p>网页结构标签: 块级元素(可替换对应的div盒子)</p><pre><code>1.几个结构标签    header: 头部区域            nav：导航区域    main： 主体区域            section： 小区域                    aside：边栏                    article:文章    footer：页尾区域2.兼容方法(导入插件): 原理:利用JS创建标签元素，并修改为块级元素    &lt;!--[if lte IE 8]&gt;        &lt;script src=&quot;html5shiv.js&quot;&gt;&lt;/script&gt;     &lt;![endif]--&gt;3.媒体播放标签    video：播放视频    audio: 播放音频    以上两个标签的属性和方法都是一样的！只不过一个是播放视频的，一个是播放音频的    行内属性：            controls：显示播放的控件            autoplay：自动播放，谷歌新版浏览器禁用了自动播放，影响用户体验            muted： 静音的属性，而且如果谷歌浏览器要想能够用自动播放，就必须加muted静音            width: 宽度;  跟img像，给宽能自动计算出高度            height:高度</code></pre><h2 id="新增表单类型"><a href="#新增表单类型" class="headerlink" title="新增表单类型"></a>新增表单类型</h2><p>新增的一些input标签的 type类型: </p><pre><code>color:用来输入颜色的date：用来输入日期，只有年月日time：用来输入时间，只有时分datetime-local：上面两个的结合体email：用来输入邮箱，自带邮箱格式验证; 如果要进行非空判断,需加required属性number：只能输入数字; 可以加max,min,step,required属性url：只能输入网址，自带网址验证search：跟普通文本框一样，移动端有区别：它弹出的键盘是带搜索按钮tel：专门用来输入电话，移动端弹出的时候键盘是数字键盘range：滑块，设置音量可以用这个, max,min,value</code></pre><h2 id="新增的一些属性和webAPI-DOM方法"><a href="#新增的一些属性和webAPI-DOM方法" class="headerlink" title="新增的一些属性和webAPI(DOM方法)"></a>新增的一些属性和webAPI(DOM方法)</h2><p>1.行内自定义属性操作:dataset对象</p><pre><code>&lt;div class=&quot;info&quot; data-name=&quot;huahua&quot; data-age=&quot;24&quot; data-my-height=&quot;177cm&quot;&gt;&lt;/div&gt;H5中自定义属性是按data-这种形式写的，那么JS里有个属性叫 dataset可以拿到所有的自定义属性因为dataset是一个对象，所有的自定义属性都当做了它这个对象的属性var info = document.querySelector(&apos;.info&apos;);// 取值info.dataset[&apos;name&apos;]; // huahuainfo.dataset[&apos;myHeight&apos;] // 177cm// 赋值info.dataset[&apos;myHeight&apos;] = &apos;188cm&apos;;</code></pre><p>2.元素的类操作: classList属性; classList是一个伪数组，可以获取元素所有类</p><pre><code>方法：    classList.add() 加一个类    如果要加多个，就用逗号隔开，写多个参数，有几个就写几个字符串参数    例：box.classList.add(&apos;red&apos;,&apos;new&apos;);    classList.remove() 移除一个类            如果要移出多个，跟add是一样的，要写多个参数    classList.replace(); 替换一个类            参数1：被替换的类            参数2：要替换新的内容    classList.toggle(); 切换一个类            原来没这个类就加上，原来有这个类就去掉。一种开关效果;    classList.contains(); 是否有某个类，如果有返回true，没有返回false</code></pre><p>3.localStorage属性：本地存储;可以存储一些数据到本地（存到浏览器端, 而且不像cookie,他没有失效时间<br>4.sessionStorage属性: 作用同上; 只不过不能永久存储,浏览器关闭回自动清空(适用 多个页面临时传值…)</p><pre><code>几个方法:   setItem(key: value): 存储一个数据到浏览器。            严格来讲只能存字符串，如果传入复杂类型，会调用复杂类型的toString方法得到字符串再存            所以如果要存一个复杂类型，先把复杂类型转成JSON字符串(JSON.stringify)，再存到浏览器            取的时候，再把JSON字符串转为 JS数据(JSON.parse).    getItem()： 根据key来取出值;    removeItem() 根据key删除某个值;    clear(): 没有参数，直接清除所有的值；注意:    1.只要自己不删，就一直存在。    2.不同网站之间的本地存储无法共享。同一个网站里不同页面可以共享使用注意点:     1.使用local storage中存储的数据(字符串/json字符串)时;        如果是对同一key进行读写操作(可能出现覆盖的情况); 在首次加载时最好先取出来,        一般读取值进行的操作:            a. 判空处理            b. 判断是否已存在 if not existed: xxx</code></pre><p>5.地理定位</p><pre><code>navigator.geolocation.getCurrentPosition(function (loc) {    console.log(loc)    // 经纬度    console.log(loc.coords.longitude, loc.coords.latitude);})</code></pre><p>6.获取目标元素距离可视区的距离</p><pre><code>getBoundingClientRect().topgetBoundingClientRect().left// 获取鼠标点击相对于自身的位置距离可以用事件对象的clientX - 元素.getBoundingClientRect().left</code></pre><h2 id="新增的一些事件"><a href="#新增的一些事件" class="headerlink" title="新增的一些事件"></a>新增的一些事件</h2><p>1.鼠标拖拽事件<br>    // 先给拖动元素加 draggable属性为true</p><pre><code>// 跟拖动的元素相关的ondrag:  当拖动元素过程中触发ondragstart:  当拖动操作开始时触发 ondragend:  当拖动操作结束时触发 // 跟容器（目标元素）有关的事件：ondragenter:有元素进入时触发ondragleave：有元素离开时触发ondragover：有元素在容器范围内时不断触发，但这个事件主要是阻止默认行为，好方便让drop事件能得到触发ondrop：当有元素在容器范围内被放置时触发，需要先阻止over的默认行为才能触发</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇内容是关于html5的一些新的特性和方法总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>常用布局方式</title>
    <link href="http://yoursite.com/2018/12/17/%E9%A1%B5%E9%9D%A2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/12/17/页面常用的布局方式/</id>
    <published>2018-12-17T02:53:33.000Z</published>
    <updated>2019-01-24T13:18:44.632Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中经常遇到布局的问题，下面我总结几种常用的css布局方案,直接用代码展示<br><a id="more"></a></p><h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><ul><li><p>水平居中</p><pre><code>/* 以不定宽为例 *//* 1: 父盒子text-aligin + 子盒子inline-block */.father {    text-align: center;}.son {    /* 此时宽高为内容撑起 */    display: inline-block;}/* 2: 子盒子 table+margin */.son {    display: table;    margin: 0 auto;}/* 3: 子盒子: absolute,left + transform *//* 当子元素定宽时, 则采用 负margin来实现 */.father {    position: relative;}.son {    position: absolute;    left: 50%;    transform: translateX(-50%);}</code></pre></li><li><p>垂直居中</p><pre><code>/* 1. 父元素: table-cell + vertical-align */.father {    display: table-cell;    /* 会继承父元素的宽度 */    vertical-align: middle; }/* 2. absolute + transform *//* 定宽使用负margin */.father {        position: relative;}.son {        position: absolute;                   top: 50%;        transform: translateY(-50%);}/* 3.flex + align-items */.father {    display: flex;    align-items: center;}</code></pre></li><li><p>水平垂直居中</p><pre><code>/* 1.父:table-cell + text-align + vertical-align  子:inline-block*/.father {    /* display: table-cell; 拥有行内块的属性 */    /* text-align: center; */    /* vertical-align: middle; */}.son {    /* display: inline-block; 内容撑开 */}/* 2. 子:absolute + transform */.son {    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);}/* 3.定宽子元素可以采用absolute + 负 margin *//* 4.还有absolute  ltrb:0 + margin: auto */</code></pre></li></ul><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><ul><li><p>一列定宽,另一列自适应</p><pre><code>/* 1. float + margin */.left {    width: 300px;    float: left;    background: red;}.right {    /* 50px的间距 */    margin-left: 350px;     background: green;}/* 2. float + overflow */.right {    overflow: hidden; }</code></pre></li><li><p>多列定宽，一列自适应</p><pre><code>/* 1.浮动加overfloat; float + overflow: hidden */.parent {    background: #ccc;}.box1,.box2 {    float: left;    width: 200px;    margin-right: 20px;}.auto {    overflow: hidden;}/* 2. flex方式实现 */.parent {    display: flex;}.box1,.box2 {    width: 200px;    padding-right: 20px;}.auto {    flex: 1;}</code></pre></li><li><p>等分布局(百分比)</p><pre><code>.parent {    height: 300px;    /* margin-left: -10px; */}.box {    float: left;    /* 等分父盒子宽度 */    width: 25%;    height: 100%;    padding-left: 10px;    /* 子元素盒子尺寸:为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 */    box-sizing: border-box;    border: 1px solid red;}</code></pre></li><li><p>等高布局</p><pre><code>1. 浮动 + overflow实现.parent {    overflow: hidden;}.left {    float: left;    width: 300px;    background: #ccc;}.right {    overflow: hidden;    background: #0f0;}</code></pre></li><li><p>三栏式圣杯布局</p><pre><code>将中间的模块放在dom树前面，可以实现浏览器在做重绘的时候有限显示**圣杯布局的主要内容是放在 中间main这个盒子中**/* 圣杯布局: 浮动 + 相对定位 + padding */.container {    width: 1000px;    margin: 100px auto;    text-align: center;}/* 头部 &amp;&amp; 底部 */.header,.footer {    height: 100px;    background-color: yellow;}/* 中间主体内容, padding保证中间盒子居中 */.wrapper {    padding: 0 100px;}.col {    float: left;    position: relative;}/* 主要内容 */.main {    width: 100%;    height: 400px;    background: red;}/* 左边内容栏: 定宽=父盒子的padding */.left {    width: 100px;    height: 400px;    /* 负margin 回到最左边 */    margin-left: -100%;    left: -100px;    background: #0f0;}/* 右边内容栏: 定宽=父盒子的padding */.right {    background: pink;    width: 100px;    height: 400px;    /* 负margin 回到最右边 */    margin-left: -100px;    right: -100px;}</code></pre></li><li><p>三栏式的双飞翼布局</p><pre><code>双飞翼布局: 同上面的圣杯一样, 也是将主体内容浮动起来, 中间设置margin, 两侧设置负margin/* 双飞翼布局: 浮动  */.container {    width: 1000px;    margin: 100px auto;    text-align: center;}/* 头尾部分 */.header,.footer {    height: 100px;    background: greenyellow;}/* 主体 */.col {    float: left;    height: 400px;}.main {    width: 100%;}/* main-wrap居中: */.main-wrap {    margin: 0 200px;    background: red;    height: 400px;}/* 两侧布局 */.left {    width: 200px;    margin-left: -100%;    background: pink;}.right {    width: 200px;    margin-left: -200px;    background: pink;}</code></pre></li></ul><h2 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h2><ul><li><p>flex布局是什么?</p><pre><code>H5中出来的一种新的布局方式,也称伸缩布局,可以给父盒子设置相应布局属性来伸缩子元素的内容,控制其在父盒子中的排布方式...用来做尺寸适配比较好,多用于移动端布局</code></pre></li><li><p>flex布局的使用方式</p><pre><code>1.flex中有两个轴: 默认主轴X方向; 副轴Y方向    使用flex布局会让子元素依次在主轴方向排列;并且子元素永远不会超过主轴方向2.使用方法    ** 可以在父元素上加上如下属性：        1.display:flex;  让子元素用伸缩布局        2.flex-direction：设置主轴方向，也就是说设置x还是y为主轴            默认是row,即X方向            Y方向是 column        3.justify-content：设置主轴上的对齐方式            设置子元素在主轴方向的排列方式            flex-start:在主轴起点对齐（默认值）            flex-end：在主轴终点对齐            center:在主轴方向居中            space-around:元素和元素之间有间距，两边也有间距            space-between：元素和元素之间有间距，但是两边没有间距        4.align-items：设置副轴上的对齐方式            设置子元素在副轴的排列方式            stretch：默认值，在副轴起点对齐。但是如果没有给子元素副轴方向大小，会铺满整个副轴方向            flex-start:副轴的起点对齐。如果没有给子元素副轴大小，会用内容撑开                        如果给了副轴大小，以上两个没区别            flex-end:在副轴终点对齐            center：在副轴居中        5.flex-wrap:wrap  代表允许换行            换行后会形成自己独立的空间轴    ** 可以在子元素身上加的属性        1.align-self：单独设置某个子元素在副轴的排列        2.flex:设置在主轴方向的占比            不过它计算的永远是主轴方向剩下的大小, 比如有元素定了宽高,它只能按比例分配余下尺寸</code></pre></li></ul><h2 id="bootstrap中的栅格布局"><a href="#bootstrap中的栅格布局" class="headerlink" title="bootstrap中的栅格布局"></a>bootstrap中的栅格布局</h2><ul><li><p>响应式</p><pre><code>/* 响应式布局 =&gt; 媒体查询 *//* 向上兼容, 向下覆盖 *//* 对屏幕的宽度或者高度进行获取同时判断，根据判断结果重置样式 */body {    background: #000;}/* max-width: 当屏幕宽度&lt;=这个值; 以里面的修改的样式为主 */ /* 当以max为参照时: 从大写到小 *//* min-width: 当屏幕宽度&gt;=这个值时; 以里面修改的样式为主 *//* 当以min为参照时: 从小写到大 */@media screen and (min-width: 768px) {    body {        background: #00f;    }   }@media screen and (min-width: 992px) {    body {    background: #0f0;    }} @media screen and (min-width: 1200px) {    body {    background: #f00;    }} 响应式基本使用:     1.容器: container:不同宽度容器对应不同宽度  和 container-fluid: 全屏等宽    2.row类写在容器里, 下面对应着column类; 一行对应一整块块内容;每一列是一个单独的盒子     3.col-xs; sm; md; lg 分别对应着 极小,小,中,大屏的宽度条件    4.col-xs-数字: 对应了该元素所占据容器的宽度的  数字/12     5.xs,sm,md,lg 满足向上兼容,向下覆盖的规则; 只能影响比他大的宽度    &lt;!-- class=&quot;col-xs-12 col-sm-6 col-md-4 col-lg-3&quot; 省去写媒体查询,从小往大    6.工具使用    不同屏幕下的显示隐藏: hidden-xs, hidden-sm: 表示在992以下的屏幕隐藏// 基本思路:分析项目原型图: 看设计稿有哪些结构可以使用 bootstrap 框架中的组件来完成...    拆分设计稿; 去框架中找对应的结构组件a. 需求分析: DOM结构在不同屏幕(尺寸)下的展示样式;     按条件去设计结构; 给row分配栅格的时候注意每一列的比例分配,注意什么屏下需要隐藏,或者样式改变b. 套用框架的时候注意,我们要对其进行修改, 包括样式和结构;     修改结构的时候,为了不改动原有结构, 有时候需要添加自定义的类名等等...    修改样式的时候, 我们需要找到直接起作用的元素; 参照源码逐一修改c. 使用框架的插件组件    注意依赖jquery, 并且要初始化....</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中经常遇到布局的问题，下面我总结几种常用的css布局方案,直接用代码展示&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于php的一些知识点</title>
    <link href="http://yoursite.com/2018/12/15/PHP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/15/PHP相关知识点/</id>
    <published>2018-12-15T02:53:33.000Z</published>
    <updated>2018-12-25T06:15:18.013Z</updated>
    
    <content type="html"><![CDATA[<p>主要是总结一些网页中php的使用方式…<br><a id="more"></a></p><h1 id="php基础"><a href="#php基础" class="headerlink" title="php基础"></a>php基础</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一般一个语言的语法无非是由变量,数据类型,运算,流程控制,函数,然后就是封装的一些方法,库等…php可以与html一起混合使用,其语法与js大致相同,这里便不做太多介绍了,以下有几个注意点</p><pre><code>注意点:    1. 文件创建: filename.php 代码块: &lt;?php 代码块 ?&gt;    2. 变量声明: 要以$开头, 区分大小写    3. 关于字符串:         a. &quot;&quot;双引可以解析出变量名,&apos;&apos;单引号不行;        b. 字符串的拼接语法使用点 . 来拼接    4. 关于输出:        a. 简单数据类型(字符串,数值等)输出: echo         b. 复杂数据类型(数组,对象等)输出:  print_r() 或者 var_dump()输出详细信息    5. 关于数组        a. 索引数组: 与js一样, $arr = [1,2,3,4]            使用for循环遍历, 长度用count($arr)方法获取        b. 关联数组: 键值对形式的数组, $arr = [&apos;key&apos; =&gt; &apos;value&apos;,...];            b1. 取值使用$arr[&apos;key&apos;]方式            b2. 遍历使用foreach方法                foreach($arr as $key =&gt; $value){                    //循环体里$key就是当前遍历到的元素的$key                    //循环体里$value就是当前遍历到的元素的$value                }    6.指令式的混编写法         &lt;?php            $array = [&apos;php&apos;, &apos;java&apos;, &apos;python&apos;, &apos;ruby&apos;];            //循环开始            for($i = 0; $i &lt; count($array); $i++):        ?&gt;        &lt;!-- 每遍历一个元素就创建一个li标签 --&gt;        &lt;li&gt;&lt;?php echo $array[$i]; ?&gt;&lt;/li&gt;        &lt;!-- 循环结束 --&gt;        &lt;?php endfor; ?&gt;    7.文件引入:  include &quot;文件路径.php&quot;;</code></pre><h2 id="表单交互"><a href="#表单交互" class="headerlink" title="表单交互"></a>表单交互</h2><p>html中的表单(form), 主要是用来向后台提交数据…</p><ul><li><p>form表单,页面提交数据的入口</p><pre><code>&lt;!-- action属性是提交的地址，代表提交到哪个服务器页面, 默认get请求方式 --&gt;&lt;form action=&quot;./result.php&quot;&gt;// 必须要加name属性!!!!!, 后台通过name属性获取传递的数据&lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre></li><li><p>提取表单数据</p><pre><code>上面的表单数据会被提交到result.php文件,这时我们需要提取数据值通过$_GET[&apos;上面表单的name属性值&apos;]即可获取到: 如$res = $_GET[&apos;userName&apos;];isset可以用来判断是否存在某个值 isset($res);返回true/false</code></pre></li><li><p>get请求和post请求</p><pre><code>1. get请求:&lt;form action=&quot;login.php&quot; method=&quot;GET&quot;&gt;    &lt;input type=&quot;text&quot; name=&apos;id&apos; placeholder=&quot;请输入账号&quot;&gt;    &lt;input type=&quot;password&quot; name=&apos;pwd&apos; placeholder=&quot;请输入密码&quot;&gt;    &lt;input type=&quot;submit&quot; value=&apos;登录&apos;&gt;&lt;/form&gt;// 提交数据后的处理页面的链接为: 127.0.0.1/login/login.php?id=hello&amp;pwd=123// get请求会将我们输入的数据:         a. 先将我们输入的数据进行url的拼接        b. 然后以明文的方式发送服务器处理页面; 处理页面通过$_GET[&apos;name属性&apos;]方式取值进行处理// 所以get请求的特点:        1. 简单,传输快,主要用于获取        2. 不安全        3. 长度有限制(2KB)        4. 浏览器缓存// 注意点:    a标签的跳转，也可以理解为是一种get请求。因为get请求本身就是通过网址的跳转来进行的。    所以,我们可以直接构造href属性去请求其他页面, 传入参数通过$_GET方式获取</code></pre></li></ul><pre><code>2. post请求:&lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt;    &lt;input type=&quot;text&quot; name=&apos;id&apos; placeholder=&quot;请输入账号&quot;&gt;    &lt;input type=&quot;password&quot; name=&apos;pwd&apos; placeholder=&quot;请输入密码&quot;&gt;    &lt;input type=&quot;submit&quot; value=&apos;登录&apos;&gt;&lt;/form&gt;// 提交数据后的处理页面的链接为: 127.0.0.1/login/login.php// post请求会将我们输入的数据:         a. 先将我们输入的数据放入到请求体中        b. 然后发送服务器处理页面; 处理页面通过$_POST[&apos;name属性&apos;]方式取值进行处理// 所以post请求的特点:        1. 主要用于提交数据        2. 长度无限制        3. 相对安全(抓包可以抓到post的提交数据)</code></pre><ul><li><p>文件上传</p><pre><code>// 通过表单标签&lt;input type=&quot;file&quot;&gt;来上传1.上传到处理页面     &lt;!-- 表单里仅仅一个文件上传元素，提交到file.php --&gt;        &lt;form action=&quot;file.php&quot; method=&apos;POST&apos; enctype=&apos;multipart/form-data&apos;&gt;            // 需要指定enctype属性            &lt;input type=&quot;file&quot; name=&apos;icon&apos;&gt;            &lt;input type=&quot;submit&quot;&gt;        &lt;/form&gt;2.接受,处理文件: 使用$_FILES[&apos;name属性&apos;]接受, 返回结果为关联数组&lt;?php// 处理上传文件// 1.接受文件$files = $_FILES[&apos;files&apos;]; var_dump($files);// 返回一个关联数组, 有5个属性://  1.name：保存的是文件名// ​ 2.type：保存的是文件类型// ​ 3.tmp_name：保存的是客户端上传来的文件临时保存的路径// ​ 4.error：错误信息代码// ​ 5.size：文件大小// 2.保存文件到本地:  拿到临时路径, 指定文件新的路径地址$oldPath = $files[&apos;tmp_name&apos;];$newPath = &quot;./data/&quot;.$files[&apos;name&apos;]; //不转码的路径//文件名含中文需要转码$gbk = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $files[&apos;name&apos;]);$newPath = &quot;./data/&quot;.$gbk; // 转码路径// 3.转移到本地: 使用move_uploaded_file(old, new)方法$res = move_uploaded_file($oldPath, $newPath);if ($res):    echo &quot;success&quot;;    echo $res;else:    echo &quot;failed&quot;;endif;?&gt;3.文件读写操作    a. file_put_contents(&apos;文件路径&apos;,写入内容);    b. file_get_contents(&apos;文件路径&apos;)4.文件存在判断: 返回布尔值    file_exists(&apos;文件路径&apos;);</code></pre></li></ul><h2 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h2><ul><li><p>增删改查</p><pre><code>1. 增删改    // php操作数据库    // 1. 建立链接: 服务器地址, 主机用户名, 密码, 数据库名    $link = mysqli_connect(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;hh0127&apos;, &apos;userInfo&apos;);    // 2.准备sql语句    // 增    $sql = &quot;insert into user(userName, description) values(&apos;胡华&apos;, &apos;你最帅啦&apos;)&quot;;    // 删    $delete = &quot;delete from user where id = 2&quot;;    // 改    $sql = &quot;update user set userName=&apos;huhua&apos;,description=&apos;我是哈哈&apos; where id=5&quot;;    // 3.执行语句: mysqli_query(数据库链接, sql语句)  返回值: 是否成功    $res = mysqli_query($link, $sql);    $affect_row = mysqli_affected_rows($link);  // 返回受影响的行数    // 4.关闭链接    mysqli_close($link);2. 查询    // 1.建立连接    $link = mysqli_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;hh0127&apos;, &apos;userInfo&apos;);    // 2.sql查询语句    // $sql = &quot;select * from user&quot;;    // 查询语句    $sql = &quot;select userName,description,id from user&quot;;    $res = mysqli_query($link, $sql); // 返回的是一个对象,数据表结构    // 3.取数据: 使用,mysqli_fetch_all(执行sql语句后的对象)      // 传入参数MYSQLI_ASSOC或者1, 可以将返回的数组内的 键 改为 字段名    // $result = mysqli_fetch_all($res, MYSQLI_ASSOC);     $result = mysqli_fetch_all($res, 1); // 返回一个二维数组: 他的元素为: 一个个关系型数组    echo $result[2][&apos;description&apos;];    // 复杂类型输出    print_r($result);    // 断开连接    mysqli_close($link);</code></pre></li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从Web服务器传输超文本到本地浏览器的传送协议,是一个协议集。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><ul><li><p>主要特点</p><pre><code>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。</code></pre></li><li><p>http的工作原理</p><pre><code>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</code></pre></li><li><p>请求和响应的结构</p><pre><code>1.HTTP请求: 请求行（request line）、请求头部（header）、空行和请求数据(实体)</code></pre></li></ul><p><img src="https://i.imgur.com/gxdAtNS.png" alt=""></p><pre><code>GET /index.html HTTP/1.1Host    img.mukewang.comUser-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept  image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明:请求类型为GET,index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等第三部分：空行，请求头部后面的空行是必须的;即使第四部分的请求数据为空，也必须有空行。第四部分：请求数据也叫主体，可以添加任意的其他数据。post请求时所传参数也在其中...2.HTTP响应: 也包括4部分,分别是: 状态行、响应报头、空行和响应正文。举个栗子:    HTTP/1.1 200 OK    Date: Fri, 22 May 2009 06:07:21 GMT    Content-Type: text/html; charset=UTF-8    &lt;html&gt;          &lt;head&gt;&lt;/head&gt;          &lt;body&gt;                &lt;!--body goes here--&gt;          &lt;/body&gt;    &lt;/html&gt;第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）第二部分：响应报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</code></pre><p><img src="https://i.imgur.com/SAkMEA9.png" alt=""></p><pre><code>响应状态码</code></pre><h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><ul><li><p>使用方法</p><pre><code>php中关于cookie和session的使用方法:1.cookie:    // 设置cookie    // 1.设置键, 2.设置值, 3.过期时间: time()+时间段    setcookie(&apos;key1&apos;, &apos;value1&apos;, time()+60);    // 修改cookie: 在原有的cookie上修改其值    setcookie(&apos;key1&apos;, &quot;value1111&quot;, time()+60*10);    // 手动删除cookie: 设置cookie的时间为过去时间: time()-10    setcookie(&apos;key1&apos;, &apos;value1111&apos;, time()-10);    // 获取cookie: $_COOKIE方法    echo &quot;我是cookie值&quot;.$_COOKIE[&apos;key1&apos;];    // cookie的值为string类型    // cookie是在服务器中设置,并随着响应报文返回到浏览器的2.session:    // 1.只要时使用到session: 必须先开启session    session_start();    // 2.设置session: 使用超全局变量$_SESSION    $_SESSION[&apos;admin&apos;] = &apos;huhua&apos;;    $_SESSION[&apos;admin1&apos;] = &apos;huhua1&apos;;    // 3.修改: 对键重新赋值即可    $_SESSION[&apos;admin1&apos;] = &apos;huhua_hello&apos;;    // 4.删除        // 1.开启会话        session_start();        // 2.删除会话 unset        unset($_SESSION[&apos;admin&apos;]);    // 5.获取session值        // 1.开启会话        session_start();        // 2. 通过超全局变量获取        $session = $_SESSION[&apos;admin&apos;];        $session1 = $_SESSION[&apos;admin1&apos;];    注意点:    // 6.session会话: 浏览器关闭就关闭会话    // 7.服务器会生成一个sessionID, 通过响应报文(包含在cookie字段中) 返回给浏览器    // 8.Session 可以存放复杂数据类型    $_SESSION[&apos;arr&apos;] = array(1,2,3,4);</code></pre></li></ul><h2 id="cookie和session的区别和使用"><a href="#cookie和session的区别和使用" class="headerlink" title="cookie和session的区别和使用"></a>cookie和session的区别和使用</h2><p>这个在网上查看了很多资料,选择一个比较好理解的放在这里</p><p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，需自己去解决这个问题。不然有些情况下即使是同一个网站每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h4><p>cookie时在我们访问某些网站后在本地存储的一些网站相关信息，下次访问时可以减少一些步骤。更准确的说法是：Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器，是在客户端保持状态的方案。</p><p><strong>Cookie的主要内容包括：名字，值，过期时间，路径和域。</strong><br>key, value形式。过期时间可设置的，如不设，则浏览器关掉就消失了，存储在内存当中，否则就按设置的时间来存储在硬盘上的，过期后自动清除，比方说开关机关闭再打开浏览器后他都会还存在，前者称之为Session cookie 又叫 transient cookie，后者称之为Persistent cookie 又叫 permenent cookie。路径和域就是对应的域名，a网站的cookie自然不能给b用。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session是存在服务器的一种用来存放用户数据的对象。</p><p>浏览器第一次发送请求时，服务器自动生成了一HashTable和一Session ID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的HashTable。</p><blockquote><p>一般这个值会有个时间限制，超时后毁掉这个值，默认30分钟。</p><p>当用户在应用程序的 Web页间跳转时，存储在 Session 对象中的变量不会丢失而是在整个用户会话中一直存在下去。<br>Session的实现方式和Cookie有一定关系。建立一个连接就生成一个session id，打开几个页面就好几个了，这里就用到了Cookie，把session id存在Cookie中，每次访问的时候将Session id带过去就可以识别了.</p></blockquote><pre><code>设置session的过期时间:    1. 修改服务端中配置的session生命周期    2. 通过时间戳来手动删除(unset)session值</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>cookie </p><p>  登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。</p></li><li><p>session</p><p>  session一个场景是购物车，添加了商品之后客户端可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。</p></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1、Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。</p><p>2、Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session是没有大小限制和服务器的内存大小有关。</p><p>3、Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。</p><p>4、Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是总结一些网页中php的使用方式…&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性学习</title>
    <link href="http://yoursite.com/2018/12/13/CSS3%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/13/CSS3特性学习总结/</id>
    <published>2018-12-13T02:53:33.000Z</published>
    <updated>2019-01-08T15:33:29.374Z</updated>
    
    <content type="html"><![CDATA[<p>关于css3的新特性学习总结…当然c3属性的使用要考虑到浏览器的兼容性问题…<br><a id="more"></a></p><h1 id="css3新特性学习"><a href="#css3新特性学习" class="headerlink" title="css3新特性学习"></a>css3新特性学习</h1><h2 id="边框系列"><a href="#边框系列" class="headerlink" title="边框系列"></a>边框系列</h2><ul><li><p>圆角</p><pre><code>/* 圆角border-radius */div {    /* 从左上角开始 */    /* border-radius: 20px 30px 40px 50px; */    /* 左上右下, 右上左下 */    /* border-radius: 20px 40px;  */    /* 全部一样 */    border-radius: 40px;}// 当半径为50%时,就会显示一个圆</code></pre></li><li><p>阴影</p><pre><code>/* 盒子阴影box-shadow */div {    /* 阴影水平偏移距离, 垂直偏移, 模糊半径, 阴影背景色 */    box-shadow: 10px 10px 10px #ccc,20px 20px 10px green;}文字阴影text-shadow和上面一样, 也可以同时叠加多个阴影...</code></pre></li></ul><h2 id="背景系列"><a href="#背景系列" class="headerlink" title="背景系列"></a>背景系列</h2><pre><code>.box {        /* 盒子必须要有宽高,才能存放背景图片 */        width: 400px;        height: 400px;        /* 可以设置多个背景图 */        background: url(&quot;../messi.jpg&quot;) no-repeat right top,        url(&quot;../xiaoxin.jpg&quot;) no-repeat left bottom,        #ccc;        // 背景连写中可以使用 / cover或者contain来等比例缩放图片,也可以写尺寸        /* 可以改变背景图尺寸 */        background-size: 25% 25%;        /* 背景图存放区域: 默认padding-box, 还有content和border  */        background-origin: padding-box;    }</code></pre><h2 id="渐变系列"><a href="#渐变系列" class="headerlink" title="渐变系列"></a>渐变系列</h2><p>css3渐变(gradients)可以让你在两个或者多个指定的颜色之间显示平稳的过度。</p><ul><li><p>线性渐变（Linear Gradients)</p><pre><code>这种渐变可以向上、向下、向左、向右甚至是各个你想要的方向(角度45deg)。div {    width: 400px;    height: 100px;    /* 线性渐变: 指定渐变方向, 和至少两种颜色, 浏览器兼容 */    background: -webkit-linear-gradient(left, red, green, blue);    background: -o-linear-gradient(left, red, green, blue);    background: -moz-linear-gradient(left, red, green, blue);    background: linear-gradient(to right, red, green, blue);}// 按角度方向渐变.san {    width: 100px;    height: 100px;    background: linear-gradient(-135deg, blue 20px, red 0);}</code></pre></li><li><p>径向渐变（Radial Gradients）</p><pre><code>这种渐变即由中心出发，向四周渐变。创建一个径向渐变，我们至少定义两种颜色结点。同时也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是center，形状是ellipse，渐变的大小是fasthest-corner（表示最远的角落）。其中形状还可以是circle（圆形）、大小还可以是choset-side和closest-corner和farthest-side。语法:background: radial-gradient(center, shape size, start-color, ..., last-color);// 还可以写成 (半径 at 方位值, 渐变颜色 开始渐变位置 渐变结束位置,....).radial {    width: 400px;    height: 300px;    /* 默认渐变, 渐变距离位置由父容器决定 */    background: radial-gradient(red, blue);    /* 圆形渐变, 默认半径是容器对角线的一半,也可以指定渲染半径 */    background: radial-gradient(100px circle, red, yellow);    /* at指定起始位置: 距离左上角的距离, 默认是中心*/    background: radial-gradient(at 50% 50%, red, yellow);    /* 指定终止位置: 父容器的近边, 近角; 远边,远角 */    background: radial-gradient(closest-side circle at 20% 20%, red, yellow);    /* 指定颜色断点,当多个颜色一起时,默认是均匀分配渐变区域的 */    background: radial-gradient(closest-side circle, yellow 20%, orange 40%, red 60%, #ccc);    /* 椭圆渐变, 渐变叠加*/    background: radial-gradient(100px 200px ellipse, transparent 40px, yellow, red 50px, transparent),    radial-gradient(30px circle, red, red 29px, transparent);    /* background-size: 40px; */}/* 水波纹效果: 通过伪类添加效果 */.shuibo {    width: 200px; height: 100px;    background: yellow;    position: relative;}.shuibo:after {    content: &apos;&apos;;    position: absolute;    height: 10px;    left:0 ;     right: 0;    bottom: -10px;    background: radial-gradient(20px 15px ellipse at top, red 10px, transparent 11px);    background-size: 20px 10px;}</code></pre></li></ul><h2 id="transform-2d转换"><a href="#transform-2d转换" class="headerlink" title="transform 2d转换"></a>transform 2d转换</h2><pre><code>/* transform 2d方法 */img {    /* 1.translate(): 相对元素自身原来位置向X,Y轴移动 */    transform: translate(100px,100px);    /* 2.ratote(): 旋转的度数, 正数就是顺时针旋转 */    /* 会覆盖上面的位移方法 */    transform: rotate(45deg);    /* 3.scale(): 基于原图宽高放大缩小 */    /* 高度或宽度设为0就隐藏了 */    transform: scale(0.5, 1);    /* transform: scale(0.5, 0); */    /* 4.skew(): 沿X,和Y轴倾斜转换 */    transform: skew(20deg, 0deg);    /* 转换的基点属性: 默认为中心 */    // 也可以给方位值,top, right bottom left    /* transform-origin：0 0；表示以左上角为原点    transform-origin：100% 0；表示以右上角为原点    transform-origin：0 100%；表示以左下角为原点    transform-origin：100% 100%；表示以右下角为原点 */}</code></pre><h2 id="transform-3d转换"><a href="#transform-3d转换" class="headerlink" title="transform 3d转换"></a>transform 3d转换</h2><ul><li><p>rotateXYZ</p><pre><code>.box1 {    /* 2d的rotate()方法只是在平面内顺时针旋转,相当于rotateZ() */    /* 3d的方法绕X,Y,Z轴进行空间旋转 */    transform: rotateX(30deg) perspective(600-800px);      transform: rotateY(30deg);      transform: rotateZ(30deg);  }// 加上一个perspective(600-800px)立体效果更好看一些; // 注意: 视距perspective属性要给 不参与运动的 父元素加 动画效果比较合理// 还需要开启3D效果, transform-style: preserve-3d;// 通过3D转换 + animation属性可以实现比较炫酷的动画效果; 一般都是通过将元素向X,Y,Z方向平移或者旋转进行组合;注意transform属性中将 rotate,translate等...连写起来组合效果.</code></pre></li></ul><h2 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h2><p>这个属性可以轻松的实现从某种效果到另一种效果的渐变过程</p><pre><code>一般情况下，该属性即transition必须规定2项内容指定要添加效果的css属性（这样才能识别做哪个方向的过渡，通常是width、height）指定效果的持续时间（默认持续时间为0，所以必须要指定;还有运动的类型(匀速linear,ease-in...), 还有steps()参数, 分几步完成过渡</code></pre><blockquote><p>  <strong>注意：该属性必须结合伪类:hover来使用</strong>。</p></blockquote><pre><code>.box {    /* 开始的样式 */    width: 100px;    height: 100px;    background-color: rgb(75, 214, 110);    font-size: 14px;    /* transition:指定要过渡的属性, 过渡时间 */    /* transition: width 3s, height 3s, transform 3s, font-size 3s; */    /* (all表示所有属性都过渡),/*第2个时间参数是delay,过1秒才触发 */     transition: all 3s 1s;}.box:hover {    /* 最终的样式 */    width: 500px;    height: 500px;    transform: rotate(360deg);    background-color: red;    font-size: 40px;}</code></pre><h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>创建css3动画，需要使用@keyframes规则。使用该规则即创建动画，它规定了一个css样式和动画将逐步从目前的样式更新为新的样式。</p><p><strong>使用语法:</strong></p><blockquote><p> 1.先给目标元素设置一个animation属性: </p></blockquote><p><img src="https://i.imgur.com/Y0HTfzS.png" alt=""></p><pre><code>animation-name: wobble;/*动画属性名，也就是我们前面keyframes定义的动画名*/animation-duration: 10s;/*动画周期持续时间*/animation-timing-function: ease-in-out; /*动画频率，匀速为linear, 分步为steps*/ animation-delay: 2s;/*动画延迟时间*/animation-iteration-count: 10;/*定义循环次数，infinite为无限次*/animation-direction: alternate;/*动作方式:往返*/animation-play-state: 播放状态animation-fill-mode: 是否停留在动画最终样子 当然, 一般都会采用连写方式,下面举例说明</code></pre><blockquote><p>2.再来规定动画的名称 @keyframes 动画名 {阶段值}</p></blockquote><pre><code>.letter {        float: left;        padding: 10px;        line-height: 200px;        font-size: 30px;        animation: showHide 2s linear infinite;    } @keyframes showHide  // 注意 /* 百分比表示从0到动画时长的百分之多少, 执行{}中的动画; */ /* 注意,执行多种动画效果,需要将{}前面阶段的属性在写一遍; 不然会覆盖同类属性 */ /* 如果只写到80%阶段; 剩下的时间则用来复原到初始状态 */    {        0% {opacity: 1;}        50% {opacity: 0.1;}        100% {opacity: 1;}    }// 还可以使用form to语法// 多个动画使用逗号,隔开// 一般可以使用封装好的动画库</code></pre><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>img来添加border-radius属性，可以添加border属性，可以添加padding属性（注意：img是行内元素，但是也可以添加padding属性）。<br>我们还可以制作响应式图片。并且可以在图片上添加文本。以及图片滤镜。和响应式图片相册。</p><pre><code>img {        /* 图片添加边框,padding,圆角,阴影属性 */        border: thin solid red;        padding: 10px;        border-radius: 10px;        box-shadow: 5px 5px 5px greenyellow;    }img {        /* 响应式图片: 宽度随父盒子变化而变化 */        width: 100%;        height: auto;    }/* 图片过滤处理filter属性 */img {        width: 25%;        float: left;        height: auto;        max-width: 250px;    }/* 图片滤镜filter */.blur {filter: blur(4px)}    /* 模糊 */.opacity {opacity: 0.5;}     /* 透明度 */.brightness {filter: brightness(1.5)}  /* 亮度: 0变黑 大于1变亮 */.contrast {filter: contrast(2)}  /* 对比度: 0变黑 大于1变亮 */.grayscale {filter: grayscale(1)}  /* 灰度: 0-1之间  变灰*/.hue-rotate {filter: hue-rotate(180deg)}  /* 色相旋转: 0-360deg之间 */.invert {filter: invert(1)}  /* 反转输入图像: 0-1之间  曝光效果*/.sepia {filter: sepia(1)}  /* 转为深褐色: 0-1之间, 怀旧风格 */</code></pre><p>C3属性就先写到这,以后用到再继续更新…</p><h2 id="伪元素-伪类选择器"><a href="#伪元素-伪类选择器" class="headerlink" title="伪元素,伪类选择器"></a>伪元素,伪类选择器</h2><pre><code>1.伪元素选择器    ::before,::after        可以在不改变html结构的情况下，给某个元素里面再加内容        我们一般用它做清除浮动带来的影响    ::first-letter            设置首字母样式    ::first-line            设置首行样式    ::selection            设置选中样式2.伪类选择器(类选择)    // a标签类    :hover 相当于鼠标悬停的效果    :active：a标签点击时的样式（按下去没松手那个状态）    :link   默认样式    :visited 访问之后的样式    // 匹配标签元素    // 搭配其他选择器组成交集选择器（常用的写法）如 li:first-child    :first-child：找到第一个子元素    :nth-child：找到某一个                可以传入具体的数字，就代表找到第几哥。例：传8，就代表找到第8个                可以传n，代表找到所有                可以传odd，代表找到奇数                可以传even，代表找到偶数                mn：代表找到m的倍数，例：3n代表找到3和3的倍数，3,6,9……………………                n+m：代表从m开始一直到最后，例：n+12 从12开始到最后    :last-child：找到最后一个    :not() 排除()中的元素    :focus 设置获得焦点时的样式</code></pre><h2 id="css3动态计算元素的高度及宽度"><a href="#css3动态计算元素的高度及宽度" class="headerlink" title="css3动态计算元素的高度及宽度"></a>css3动态计算元素的高度及宽度</h2><pre><code>1、px    　　像素，我们在网页布局中一般都是用px。2、百分比　　百分比一般宽泛的讲是相对于父元素，自适应网页布局越来越多，百分比也经常用到了3、Viewport　　　当已知一个div的高度时，它的同胞div高度是根据窗口高度减去已知div高度而得到，此时就需要calc函数    　　viewport：可视窗口，也就是浏览器。    　　vw Viewport宽度， 1vw 等于viewport宽度的1%    　　vh Viewport高度， 1vh 等于viewport高的的1%CSS3使用Calccalc()使用通用的数学运算规则，但是也提供更智能的功能：    &gt;使用“+”、“-”、“*” 和 “/”四则运算；    &gt;可以使用百分比、px、em、rem等单位；    &gt;可以混合使用各种单位进行计算；    &gt;表达式中有“+”和“-”时，其前后必须要有空格，如&quot;width: calc(12%+5em)&quot;这种没有空格的写法是错误的；    &gt;表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。    例如 ：设置div元素的高度为 当前窗口高度-100px    div{    height: calc(100vh - 100px);         }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于css3的新特性学习总结…当然c3属性的使用要考虑到浏览器的兼容性问题…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Ajax相关总结</title>
    <link href="http://yoursite.com/2018/12/13/Ajax%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/13/Ajax基础/</id>
    <published>2018-12-13T02:53:33.000Z</published>
    <updated>2019-01-05T01:55:01.418Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是关于Ajax内容的总结,主要是总结一些基本用法和注意事项…以及封装的方法..日常使用中的一些注意事项.<br><a id="more"></a></p><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax?"></a>什么是Ajax?</h2><p>一般来说,我们向服务器发送一次HTTP请求就会对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。  </p><p>通俗的来讲,Ajax是一种技术, 一种可以让网页某个局部部分动态地给服务器发起请求，而不用整个页面刷新。是一种可以<strong>局部发请求</strong>的技术…</p><h2 id="Ajax的使用步骤"><a href="#Ajax的使用步骤" class="headerlink" title="Ajax的使用步骤"></a>Ajax的使用步骤</h2><pre><code>1.首先我们要确定好需求(使用场景), 也就是什么时候(在事件中使用,或者达到某一条件时)去使用Ajax...2.XMLHttpRequest对象, js中专门用于发送局部请求的对象    a.首先,需要使用new关键字去初始化一个xhr对象,别忘记少写new    var xhr = new XMLHttpRequest();    b.接着是构造请求: 一个请求包括: 请求行,请求头(各个字段),空行, 请求体(数据)    xhr.open(&apos;get&apos;,&apos;请求路径&apos;); // 默认异步, get方式,参数同过url拼接传入: ?key1=value1&amp;k2=v2    xhr.open(&apos;post&apos;,&apos;目标路径&apos;); // 参数通过后面的send方法传入    **b1** post方式请求时需要 构造一个请求头部,不然服务器不会返回数据    xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);    // 注意,服务器的响应体中 也会注明响应文件的content-type, 接受时也需要注意    c.发送请求    xhr.send(); // get方法不用传值,直接发送    xhr.send(&apos;name=huhua&amp;age=18&apos;) // post方式将目标参数同过键值对方式传入    d.进行事件监听,获取服务器响应回来的数据    // 需要判断  请求对象.请求状态和响应状态:   readyState 和  status    xhr.onreadystatechange = function() {        // 判断状态码        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            // 这里就可以处理 响应数据            document.getElementById(&apos;tips&apos;).innerHTML = xhr.responseText;        }    }</code></pre><h2 id="Ajax中传输的数据格式JSON"><a href="#Ajax中传输的数据格式JSON" class="headerlink" title="Ajax中传输的数据格式JSON"></a>Ajax中传输的数据格式JSON</h2><p>为了方便数据跨平台(各语言之间)传输,json对象就被发明了…<br><strong>JSON本质上就只是一个按规定格式写的字符串</strong></p><pre><code>json对象: 一种数据格式, 键为string(必须用双引号), 值为string,number,boolean类型 &apos;{&quot;key1&quot;: &quot;hello&quot;, &quot;key2&quot;: &quot;world&quot;, &quot;key3&quot;: 1, &quot;key4&quot;: true}&apos;;&apos;[{&quot;key1&quot;: &quot;hello&quot;, &quot;key2&quot;: &quot;world&quot;, &quot;key3&quot;: 1, &quot;key4&quot;: true}, {&quot;number&quot;:222}]&apos;;</code></pre><ul><li><p>json的转化</p><pre><code>json在各个语言都有对应的api进行转化,这里就讲一下js和php中的转化方法json对象(字符串包裹是对象或者数组)         通过 JSON.parse()  json转为js对象和数组        通过 stringify()   js转json字符串php中: json_encode() json编码为php对象       json_decode() php对象解码为json对象</code></pre></li></ul><h2 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h2><pre><code>XML也是一种标记语言,同json一样也是用于数据传输的...(体积较大)XML的结构:    &lt;root&gt;        &lt;item&gt;            &lt;id&gt;1&lt;/id&gt;             &lt;name&gt;华仔&lt;/name&gt;             &lt;age&gt;22&lt;/age&gt;         &lt;/item&gt;     &lt;/root&gt;由根节点,以及双标签组成, 标签名自己随意写,符合规范即可...XML和html中document相似, 也可以调用DOM方法, 比如元素的获取等等...</code></pre><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul><li><p>同源策略</p><pre><code>浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。基本上所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。 那么不同源就是跨域:    这里有两个url  http://www.example.com/index.html 和 https://www.example.com/demo.html/    以上两个url就是不同源的,他们的遵守的协议不一样; 如果协议, 域名, 端口中只要有一个不相同就为不同源;    所以, 不同源就是跨域...</code></pre></li><li><p>跨域问题地解决方案</p><pre><code>当我们需要在一个域名下请求另外一个域名的资源时,此时Ajax请求不能使用,该怎么办呢?1.jsonp    jsonp的原理就是利用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，    并且以get的方式将前端回调处理函数名称(callback=functionName)告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式(function(data))传递回去,然后script标签将返回的响应内容当作js代码执行。// 浏览器客户端实行步骤    1. 定义一个函数func用来处理接受到响应地json数据    2. 动态地创建script标签, 添加src属性,添加到body或者head标签中    3. 给这个src属性赋值, 值为api接口地址并拼接上回调函数callback=func    4. 在函数func内部处理接受到的参数args...注意: JS中还有其他三个标签可以进行跨域请求img 、iframe、link(stylesheet)但他们都有缺陷    a. img  //支持跨域但是无法实现获取服务端返回的数据    b. &lt;iframe src=&quot;https://www.baidu.com&quot;&gt;&lt;/iframe&gt; //支持跨域，可以接收服务端数据，但是过程复杂    c. &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://www.baidu.com&quot;&gt; //会在CSS处理阶段报错2.CORS    Cross-Origin Resource Sharing(跨域资源共享)是一种允许当前域（origin）的资源（比如html/js/web service）被其他域（origin）的脚本请求访问的机制。    当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头:origin,    后端在接受到请求后确定响应后会在Response Headers 中加入一个属性Access-Control-Allow-Origin: 这里是发起请求地地址, *表示所有人都能访问3.服务器跨域    在前后端分离的项目中可以借助服务器实现跨域，具体做法是：        a.前端向本地服务器发送请求，本地服务器代替前端再向api服务器接口发送请求进行服务器间通信，        b.本地服务器其实就是个中转站的角色，再将响应的数据返回给前端4.postmessage跨域    HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），    该方法可以通过绑定window的message事件来监听发送跨文档消息传输内容。    使用postMessage实现跨域的话原理就类似于jsonp，动态插入iframe标签，再从iframe里面拿回数据</code></pre></li></ul><h2 id="通过模板动态添加网页元素"><a href="#通过模板动态添加网页元素" class="headerlink" title="通过模板动态添加网页元素"></a>通过模板动态添加网页元素</h2><p>当我们从后端接口拿到数据后,需要动态的将元素添加到网页中; 一般有几种方式可以做到</p><pre><code>a. 找到数据填充的标签, 创建这个标签, 然后数据用 字符串拼接 的方式组合在一起,最后appendchild到父元素身上b. 通过 引入模板的方式 来实现元素的添加; 这种方式更为快速,方便举个粒子: obj是一个对象    a.字符串拼接法     var pList = document.querySelectorAll(&apos;p&apos;);    pList[0].innerHTML = &quot;QQ号:  &quot; +  obj.result.qq;    pList[1].innerHTML = &quot;得分:  &quot; +  obj.result.score;    pList[2].innerHTML = &quot;吉凶论断:  &quot; +  obj.result.luck;    pList[3].innerHTML = &quot;论断详情:  &quot; +  obj.result.content;    pList[4].innerHTML = &quot;性格分析:  &quot; +  obj.result.character;    pList[5].innerHTML = &quot;性格详情:  &quot; +  obj.result.characterdetail;    b.模板法添加元素    &lt;!-- 1.引入模板 --&gt;    &lt;script src=&quot;../../js/template-web.js&quot;&gt;&lt;/script&gt;    &lt;!-- 2.使用script标签创建模板, a.指定模板的 type 不能位JavaScript文件类型; b.定义一个id确定模板位置--&gt;    &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;        &lt;!-- 遍历这个data对象(单个对象) --&gt;        {{ each obj value key }}            &lt;p&gt;{{key}} : {{value}}&lt;/p&gt;        {{ /each }}    &lt;/script&gt;    // 3.调用模板的api: template函数    var html = template(&apos;tpl&apos;, {obj: obj.result}); // 返回一个html结构    document.getElementById(&apos;box&apos;).innerHTML = html; // 将内容添加到box的盒子</code></pre><h2 id="Ajax的封装"><a href="#Ajax的封装" class="headerlink" title="Ajax的封装"></a>Ajax的封装</h2><ul><li><p>原生js封装</p><pre><code>Ajax请求封装:     1.声明一个函数    2.相同部分放入函数体    3.调用函数    4.不同部分当作参数: 请求类型type 和 url    5.对请求方式大小写的处理    6.请求参数data    7.传入回调函数callback, 处理响应体    8.自动转换响应体数据的类型datatype, json,xml,或者普通json字符串(不做处理)    9.将参数作为对象    10.避免变量名污染, 定义一个对象,将参数放在一个对象中// 如果不想在回调函数内操作响应数据,可以使用一个全局变量去储存 Ajax接受到的响应体的值 xhr.responseTextdocument.getElementById(&apos;btn&apos;).onclick = function () {    // 参数: 请求方法, url, url参数, 回调处理函数function(res){}, 响应内容处理格式datatype    var params = {        type: &apos;get&apos;,        url: &apos;req.php&apos;,        data: &apos;name=helloworld&apos;,        callback: function (res) {            // 这里的函数是对Ajax响应体的处理函数            console.log(res);        },        datatype: &apos;json&apos;,    };    request.ajax(params);};var request = {}; // 定义一个对象request.ajax =  function(params) {    // 响应类型大小写转换    var type = params.type.toLocaleLowerCase();    // 判断请求类型,发送对应请求    if (type == &apos;get&apos;) {        // get请求的 url拼接        params.url += &quot;?&quot; + params.data;    }    // 创建请求    var xhr = new XMLHttpRequest();    xhr.open(type, params.url);    // 如果是发送post请求    if (type == &apos;post&apos;) {        xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);        xhr.send(params.data);    }else {        xhr.send();    }    // 响应监听    xhr.onreadystatechange = function () {        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {            var xhr_res = xhr.responseText;        }else {            return &apos;访问失败&apos;;        }        // 处理响应数据, 判断用户需要哪种数据        var res;        if (params.datatype) {            params.datatype = params.datatype.toLocaleLowerCase();             if (params.datatype == &apos;json&apos;) {                res = JSON.parse(xhr_res);            }            if (params.datatype == &apos;xml&apos;) {                var parser = new DOMParser();                res = parser.parseFromString(xhr_res, &apos;text/html&apos;);            }        } else {            res = xhr_res; // 实际字符串        }        // 回调函数处理        params.callback(res);    }}</code></pre></li><li><p>jQuery中的封装调用</p><pre><code>// btn1点击事件$(&quot;#btn1&quot;).click(function () {    // 发送get请求    $.get({        url: &quot;./get.php&quot;,        // data: {name: &apos;get&apos;},        success: function(res) {        // 处理响应体的回调函数        // header(&apos;content-type:application/text;charset=utf-8&apos;);        // 注意!!! 后端设置的文件类型格式(text/html, json等等...)也会 限制响应体格式的输出..., 有可能拿不到res        console.log(res);    },        error: function(res) {    //  处理响应体的回调函数    //      console.log(res);    //  }        // dataType: &quot;json&quot; &quot;jsonp&quot; &quot;xml&quot;, 如果后端api返回的数据是普通字符串,就不需要传这个参数        // 如果用jQuery发jsonp请求，不用创建script，只要dataType写一个jsonp    })})// btn点击事件$(&quot;#btn2&quot;).click(function () {    // 发送post请求    $.post({        url: &quot;./post.php&quot;,        data: {name: &apos;post&apos;},        success: function(res) {            //处理响应体的回调函数            console.log(res);        },    })})// btn3点击事件$(&quot;#btn3&quot;).click(function () {    // 发送任意请求    $.ajax({        url: &quot;./ajax.php&quot;,        data: {name: &apos;bob&apos;},        type: &quot;get&quot;, // 指定请求类型        success: function(res) {            // 处理响应体的回调函数            console.log(res);        },        dataType: &quot;json&quot;,    })})</code></pre></li><li><p>form表单序列化</p><pre><code>$(&apos;.submit&apos;).click(function () {    // 先获取所有数据, 通过form表单序列化方法    // jQuery中的表单序列化：$(表单).serialize方法; 表单必须有name属性    // 获取的序列化字符串的key值 就是name属性的值    var data = $(&apos;#ajaxForm&apos;).serialize();    console.log(data);    // 发送请求核对    $.post({        url: &quot;_api/register.php&quot;,        data: {data},        // 回调函数处理响应内容        success: function (res) {            console.log(res);        }    });})</code></pre></li></ul><h2 id="Ajax应用中的一些注意事项"><a href="#Ajax应用中的一些注意事项" class="headerlink" title="Ajax应用中的一些注意事项"></a>Ajax应用中的一些注意事项</h2><pre><code>1.面向接口编程:    当网站数据变化时,页面需要动态的向服务器去发送局部请求(异步方式)数据,这时我们需要弄清楚:        a. 请求的接口(即一个url)        b. 请求方式(get, post, 其他....)        c. 请求的参数(data: {data1: xxxx, data2: yyyy,....}); 键值对的形式        d. 请求的响应体格式; (jQuery中的&quot;jsonp&quot;格式 是发送的跨域请求)        e. 回调函数(obj): 也就是我们去处理响应内容的方式...        // 一般就是拿到响应体后, 取出响应体的数据,去动态给网页上要变化的标签元素赋值,        // 对于同类型的网页元素模块我们可以使用模板去赋值,(script标签中导入模板, 准备模板(数据填入模板),) 这样可以节省开发时间 模板template(&apos;元素id&apos;, {data1: xxx, data2: yyy}) 传多个值2.页码刷新内容    a.通过a标签的href属性, href=&quot;javascript: func(page值)&quot;, 来实现传参,并发送请求, 完成页面刷新;    b.通过button标签的添加行内点击事件实现,调用一个Ajax请求函数        如: &lt;button onclick=&quot;update_all(&apos;approved&apos;)&quot; class=&quot;btn btn-info btn-sm&quot;&gt;批量批准&lt;/button&gt;3.动态加载的元素的事件注册问题    当元素是动态异步加载的时候,事先的事件注册不会实现给后来加载的元素    这里一般要用到 委托注册(冒泡原理: 当元素的事件触发时,父级的同名事件也会依次触发...)给父元素注册即可4.分页组件, 页面动态加载    a.前端分页的实现: 适用于数据较少/分页较少的情况。        在前端分页的实现中，通过接口一次性获取列表的所有内容，根据数据的总长度和每页需展示的个数计算总页数；        之后的每次加载操作（滚动/点击）中，依次执行数据截取、DOM 渲染、插入结构的过程，直至最后一页。    b.在后端分页的实现:        在加载时，前端通过页码page来拉数据，若返回非空数组，则进行 DOM 渲染，插入接口的操作；        若返回空数组，则说明当前请求的为最后一页的数据，无需再发送请求。        将需要的字段通过sql语句查询出来; 返回一个data数组,和数据的长度用来当作总页数;    c.注意事项:         1.当遇到多级分页时, 一种实现的方式是, 将SQL语句进行分离,判断,和拼接;不同情况使用不同的语句;        2.select表单元素的值: 如果有value属性, 通过方法获取的值会是value值;         而不是元素标签中的文本值; 所以要想动态获取option的去掉标签的value属性        3.模板的使用: twbsPagination插件; 导入jQuery,和bootstrap;        // 这个分页插件只会默认初始化一次; 要解决页码变化的问题:            // 调用模板的初始化方法, 传入destroy, 可以清除上一次的分页状态, 下一次重新生成新的分页            $(&apos;.pagination&apos;).twbsPagination(&apos;destroy&apos;);            $(&apos;.pagination&apos;).twbsPagination({                    totalPages: obj.total_page,                    visiblePages: 5,                    initiateStartPageClick: false,                    first: &quot;首页&quot;,                    prev: &quot;上一页&quot;,                    next: &quot;下一页&quot;,                    last: &quot;尾页&quot;,                    startPage: page, // 高亮页设置                    onPageClick: function (event, page) {                        // 每次点击时会自动加载                        load_post(page);                    }                })                }            })5.批量操作表格数据 tr    一般每个tr都会对应着一条数据; 那么在动态批量操作时需要注意:    a.需要将数据库中设置的id值赋值给每一行的标签的一个属性上 作为这条数据的标识;    b.然后前端在操作行数据时, 获取目标行的状态和id值(jQuery中使用each方法:each(function (index, ele) {xxxxx}操作比较好)    然后将获取的值传给后端, 后端通过sql语句的in语法来批量修改字段值;    // 注意一些特殊处理: 一般就是末页数据加载的问题, 末页单行数据操作等等.....6. FormData对象// 前提是form表单中&amp;&amp;带name属性的 input标签:    js中 FormData对象在实例化的时候传入一个表单对象，那么它就会自动获取到表单中所有带name属性的表单元素提交给服务器    jQuery里的表单序列化(serialize): $(&apos;#ajaxForm&apos;).serialize()，但是表单序列化不能拿到文件file，所以是无法做文件异步上传的    可是FormData是可以获取文件的; 一般在做表单数据上传时,    // 先获取页面表单的内容, 这里直接通过 FormData 对象来拿到表单里面的数据;     var fm = new FormData($(&apos;form&apos;)[0]); 传入的为DOM对象!!!!    // 非表单标签元素: 如富文本插件内容 需要手动添加, 并设置对应的 key值, 即字段值    fm.append(&quot;content&quot;, editor.txt.html());    // 上面讲到的富文本插件:  导入模板, 调用对应的api方法生成即可    // 实例化一个editor对象    var editor = new wangEditor(&apos;#content&apos;);    // 调用create方法创建    editor.create();// 注意事项:    使用ajax发送 post提交请求时, 不要忘记 加上下面两个参数    data: fm,    // 使用FormData时; 需要加上两个参数: 内容格式和数据处理 都为false    contentType: false,    processData: false,// 表单元素file    // file表单元素:  files属性: files[0];  上传多个文件 + multiple属性; 提交多个文件给服务器保存时需要注明name=&quot;icon[]&quot;    console.dir(this.files[0]); //可以打印出文件详细的属性信息    当上传文件为图片时:    要实现图片的预览功能: 可以给file表单添加: onchange事件, 当值改变时, 给img标签添加 src属性     // 图片保存方案:    a.临时url方案: URL.createObjectURL(表单.files[0])    b.永久url方案: 将上传图片发送到服务器, 服务器保存; 下次在返回路径7.混编时数据的添加    数据库中查找出的数据: 由于返回的是二维数组:        a.当页面渲染时只要添加一组数据时, 直接取出来做操作arr[0];        b.当页面需要添加多组数据时, 需要遍历二维数组中的内容arr, 将每项内容添加到指定位置    关于点赞数的局部刷新: 将数据库中字段值取出来存在 行内属性上,点击后将新数据提交给服务器,自己+1    文章阅读数+1: 页面加载一次则+1, 然后更新到数据库中</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是关于Ajax内容的总结,主要是总结一些基本用法和注意事项…以及封装的方法..日常使用中的一些注意事项.&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>jQuery常用知识总结</title>
    <link href="http://yoursite.com/2018/12/06/jQuery%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/06/jQuery语法基础/</id>
    <published>2018-12-06T02:53:33.000Z</published>
    <updated>2018-12-24T12:10:52.613Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容是对jQuery和原生JS进行了对比和归纳,主要是总结一些jQuery的常用知识点…<br><a id="more"></a></p><h1 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h1><p>jQuery是一个js库, 它将原生js的一些方法封装起来,简化了js对DOM的动态操作,还做了一些浏览器的兼容处理;另外jquery的很多方法传参后返回就是自己,因此可以进行链式操作;还可以进行隐式迭代等;下面将从几个方面(jQuery对象, 选择器, css样式操作, html节点操作(增删改),位置, 动画, 事件操作等)来对jquery进行解析.</p><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p>当我们引入jquery文件时,相当于执行jquery的代码, 返回的是一个jQuery对象(也可以用$来表示),里面包含很多封装好的方法.</p><ul><li><p>jQuery对象和DOM对象</p><p>  DOM对象: 用原生JavaScript获取的DOM对象<br>  通过document.getElementById()  返回的是元素(DOM对象)<br>  通过document.getElementsByTagName()  返回伪数组(集合)，集合中的每一个对象是DOM对象</p><p>  jQuery对象: jQuery对象用$()的方式获取的对象<br>  jQuery对象又可以叫做包装集(包装的DOM对象的集合)</p><p>  <strong>jQuery对象不能使用DOM对象的成员，DOM对象不能使用jQuery对象的成员</strong></p></li><li><p>jQuery对象和DOM对象的相互转换</p><p>  jQuery对象转换成DOM对象：   </p><pre><code>jQuery对象.get(索引值); jQuery对象[索引值]; jQuery对象是包装集(集合)，从集合中取数据可以使用索引的方式</code></pre><p>  DOM对象转换成jQuery对象：   </p><pre><code>$(DOM对象) 只有这一种方法;</code></pre></li><li><p>入口函数</p><p>  关于jQuery的入口函数：</p><pre><code>// 第一种写法$(document).ready(function() {    });// 第二种写法$(function() {});</code></pre><p>  jQuery入口函数与window.onload的对比:</p><p>  JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。<br>  jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</p></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>jQuery中选择器的作用是用来快速匹配到要操作的元素,使用$(selector)获取jQuery对象, 而原生js是通过document.getElementById(‘box’)等这些方法获取到DOM对象.</p><ul><li><p>基本选择器</p><pre><code>ID选择器     $(&apos;#id&apos;);    获取指定ID的元素类选择器     $(&apos;.class&apos;);    获取同一类class的元素标签选择器     $(&apos;div&apos;);    获取同一类标签的所有元素并集选择器     $(&apos;div,p,li&apos;);    使用逗号分隔，只要符合条件之一就可。交集选择器     $(&apos;div.redClass&apos;);    获取class为redClass的div元素</code></pre></li><li><p>层级选择器</p><pre><code>子代选择器    $(&apos;ul &gt; li&apos;);    获取儿子层级的元素，注意，并不会获取孙子层级的元素后代选择器    $(&apos;ul li&apos;);     代表后代选择器，获取ul下的所有li元素，包括孙子等</code></pre></li><li><p>过滤选择器</p><pre><code>:eq（index）    $(&apos;li:eq(2)&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为2的元素，索引号index从0开始。:odd    $(&apos;li:odd&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为奇数的元素:even    $(&apos;li:even&apos;).css(&apos;color&apos;, &apos;red&apos;);    获取到的li元素中，选择索引号为偶数的元素 :enabled :disabled :checked :selected 获取到表单对象属性还有很多不常用的,用到时可以查文档...</code></pre></li><li><p>jQuery筛选选择器(这些都是jQuery对象的方法)  </p><pre><code>通常我们可以用一个$xxx变量将定位地元素先存起来,然后再调用其方法取定位到目标元素...返回地也是jQuery对象.children(selector)     $(&apos;ul&apos;).children(&apos;li&apos;)    相当于$(&apos;ul&gt;li&apos;)，子类选择器find(selector)        $(&apos;ul&apos;).find(&apos;li&apos;);    相当于$(&apos;ul li&apos;),后代选择器siblings(selector)    $(&apos;#first&apos;).siblings(&apos;li&apos;);    查找兄弟节点，不包括自己本身。parent()      $(&apos;#first&apos;).parent();      查找父亲eq(index)      $(&apos;li&apos;).eq(2);    相当于$(&apos;li:eq(2)&apos;),index从0开始next()          $(&apos;li&apos;).next()    找下一个兄弟prev()          $(&apos;li&apos;).prev()    找上一次兄弟....其他可以查阅文档</code></pre></li></ul><h2 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h2><p>属性操作一般是用来获取表单元素和其他元素地内容,以及修改删除等等…<br>原生js中的DOM对象操作属性:</p><p>自定义属性操作: setAttribute(‘attr_name’) getAttribute等…还有点语法操作行内属性</p><ul><li><p>attr的用法</p><pre><code>1. 获取, 设置属性值&lt;!-- 不传参获取不到 --&gt;$(&quot;img&quot;).attr(&quot;src&quot;); //获取文档中所有图像的src属性值。$(&quot;img&quot;).attr({ src: &quot;test.jpg&quot;, alt: &quot;Test Image&quot; }); //为所有图像设置src和alt属性值$(&quot;img&quot;).attr(&quot;title&quot;, function() { return this.src }); //把src属性的值设置为title属性的值2. 删除属性$(&quot;img&quot;).removeAttr(&quot;src&quot;);</code></pre></li></ul><ul><li><p>prop的用法</p><pre><code>对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。1.获取, 设置$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;); // 获取属性, 返回值为true or false$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop({checked: true}); // 全设置为true// 传入回调函数  // 通过函数来设置所有页面上的复选框被选中。$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, function( i, val ) {        return !val;    });2.删除属性$(&quot;input[type=&apos;checkbox&apos;]&quot;).removeProp(&apos;disabled&apos;); // 删除禁用属性</code></pre></li><li><p>addClass的用法(类名) </p><pre><code>给元素添加类名属性, 添加多个接的加空格1.添加$(&apos;.sec&apos;).addClass(&apos;hello world&apos;); // 添加了2个类名// 传入回调函数$(&apos;ul li&apos;).addClass(function() {    return &apos;index&apos; + $(this).index();  // 给所有li添加index+自己下标的类名});console.log($(&apos;ul li.index3&apos;).index()); // 返回自己在父元素中的索引2.删除$(&apos;ul li&apos;).removeClass(); // 不传参删除所有,传参删除选定类名同样可以传入一个回调函数, return你处理后的结果3.切换toggleClass$(&apos;#btn&apos;).on(&apos;click&apos;, function () {    $(&apos;.sec&apos;).toggleClass(&apos;red&apos;);  // 点击一次按钮,便切换类名})&lt;!-- 还可以传入一个布尔参数 --&gt;var count = 1;$(&apos;#btn&apos;).on(&apos;click&apos;, function () {    console.log(count);    $(&apos;.sec&apos;).toggleClass(&apos;red&apos;, count++ % 5 == 0); // 点击5次li变红})</code></pre></li><li><p>html,text,val的用法</p><pre><code>这些都是获取标签元素文本内容和设置内容的方法...1.html()方法  对应原生js中的innerHTML方法var $ht = $(&apos;.sec&apos;).html(); // 不传参返回标签网页内容console.log($ht);设置内容: 传入一个标签,会添加到网页,但会覆盖之前的内容$(&apos;.sec&apos;).html(&quot;&lt;b&gt;hello jquery&lt;/b&gt;&quot;);也可以传入回调函数...2.text()方法  对应原生js中的innerText和textContentconsole.log($(&apos;.sec&apos;).text());  // 返回文本$(&apos;.sec&apos;).text(&apos;hello text&apos;)   // 设置文本,会把子元素全部覆盖掉$(&apos;.sec a&apos;).text(&apos;hello text&apos;)// 回调函数var a = &apos;hello&apos;$(&quot;.sec&quot;).text(function(n){    return &quot;这个 li 元素的 index 是：&quot; + n;}(a));3.val()方法  对应js 中的表单元素的value属性的值的操作console.log($(&apos;input&apos;).eq(1).val()); // 获取值// 传入参数就是设置值// 也可以传回调函数$(&apos;input:text.items&apos;).val(function() {    return this.value + &apos; &apos; + this.className;});</code></pre></li></ul><h2 id="jQuery操作文档节点"><a href="#jQuery操作文档节点" class="headerlink" title="jQuery操作文档节点"></a>jQuery操作文档节点</h2><p>jQuery也可以做创建,添加,删除文档节点的操作…</p><ul><li><p>创建节点</p><pre><code>var $p = $(&apos;&lt;p&gt;Hello&lt;/p&gt;&apos;); // $(传入一个html格式字符串), 此时内存中便创建了一个节点对象,js中使用createElement(&apos;标签名&apos;)$(&apos;body&apos;).append($p);</code></pre></li><li><p>节点的增删改</p><pre><code>1.增加A.append(B) === B.appendTo(A)    在被选元素的结尾插入内容prepend prependTo    在被选元素的开头插入内容before                在被选元素之后插入内容after                在被选元素之前插入内容insertAfter() // 把所有匹配的元素插入到另一个、指定的元素元素集合的后面。 注意: appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，返回值是所有被追加的内容，sh是前者!!!而不仅仅是先前所选中的元素。所以，要选择先前选中的元素，需要使用end()方法2.替换A.replaceWith(html字符串) // 将所有匹配的元素A替换成指定的HTML或DOM元素$(html字符串).replaceAll(jQuery对象) // 与上面反过来3.清空节点与删除节点$(&apos;div&apos;).empty(); // 清空div的所有内容（使用较多，会清除子元素上绑定的内容，源码）,但会自身保留$(&apos;div&apos;).html(&apos;&apos;);// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。$(&apos;div&apos;).remove(); // 相比于empty，自身也删除（自杀）4.克隆节点// 按钮克隆$(&apos;#btn&apos;).on(&apos;click&apos;, function(){    // 布尔值（true 或者 false）参数表示事件处理函数是否会被复制    $(this).clone(true).insertAfter(this);    // $(this).clone(true).before(this); 这个方法不行!!})</code></pre></li></ul><h2 id="jQuery操作CSS样式"><a href="#jQuery操作CSS样式" class="headerlink" title="jQuery操作CSS样式"></a>jQuery操作CSS样式</h2><p>通过css()方法jQuery对象可以获取,设置或者修改样式，操作的是style属性。</p><ul><li><p>css()方法</p><pre><code>1.获取样式$(&apos;div&apos;).css(&apos;background-color&apos;)  // 获取背景色2.设置或修改$(&apos;div&apos;).css({    &apos;background&apos;:&apos;gray&apos;,    &apos;width&apos;:&apos;400px&apos;,    &apos;height&apos;:&apos;200px&apos;});注意:    设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值    获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</code></pre></li><li><p>jQuery中元素的几个位置,尺寸方法</p><pre><code>1.width()方法和height()方法// 获取内容宽高.console.log($(&apos;div&apos;).width()); //200console.log($(&apos;div&apos;).height()); //200//设置内容宽高.$(&apos;div&apos;).width(300);$(&apos;div&apos;).height(300);2.innerWidth()和innerHeight();    获取内容宽高+paddingconsole.log($(&apos;div&apos;).innerWidth());console.log($(&apos;div&apos;).innerHeight());//设置还是会把padding计算进来,修改内容的宽高.$(&apos;div&apos;).innerWidth(300);$(&apos;div&apos;).innerHeight(300);3.outerWidth(); outerHeight();    获取内容宽高+padding+border;console.log($(&apos;div&apos;).outerWidth());console.log($(&apos;div&apos;).outerHeight());//设置还是会把 padding和 border计算进来,修改内容的宽高.$(&apos;div&apos;).outerWidth(300);$(&apos;div&apos;).outerHeight(300);4.outerWidth(true); outerHeight(true); 获取内容宽高+padding+border+margin;console.log($(&apos;div&apos;).outerWidth(true));console.log($(&apos;div&apos;).outerHeight(true));5.获取页面可视区的宽高获取可视区宽度 $(window).width();获取可视区高度 $(window).height();6.offset()方法与position()方法offset()方法获取元素距离document(即当前网页窗口)的位置，var $offset = $(&apos;#son&apos;).offset();console.log($offset); // 返回一个对象, {top:200,left:200};注意: 它是可以设置的,传入一个对象参数; 如果元素没有定位, 设置offset,那么就会自动给他一个relative定位.position方法获取的是元素距离有定位的父元素(offsetParent)的位置。var $position = $(&apos;#son&apos;).position();console.log($position); // 返回一个对象, {top:100,left:100};注意: position方法不能设置7.scrollTop与scrollLeft: 设置或者获取垂直滚动条的位置//获取页面被卷曲的高度, 常用于返回顶部, window的onscroll事件$(window).scrollTop();// 获取页面被卷曲的宽度$(window).scrollLeft();</code></pre></li></ul><h2 id="jQuery操作元素动画效果"><a href="#jQuery操作元素动画效果" class="headerlink" title="jQuery操作元素动画效果"></a>jQuery操作元素动画效果</h2><p>jQuery中封装了几个基本的自定义动画的功能。</p><ul><li><p>显示隐藏show/hide</p><pre><code>这个相当于操作 display属性hide和block, 并由高度和宽度的变化1.显示  show(参数1,参数3, 参数2); // 参数3是默认缓动, 可以传入&apos;linear&apos;就是匀速//参数1: 执行动画的时长  可以是毫秒数 也可以是代表时长的字符串  slow  fast  normal  如果字符串单词写错了相当于写了一个normal//参数2: 动画执行完毕后的回调函数.$(&apos;#div1&apos;).show(1000, function () {    alert(&apos;动画执行完毕了.&apos;);});2.隐藏 hide()  同上3.toggle()  切换显示隐藏效果</code></pre></li><li><p>slideDown()/slideUp()/slideToggle()</p><pre><code>这个动画相当于调整元素的高度height, 让元素有一个缓慢滑下和向上滑的效果,用法同上</code></pre></li><li><p>fadeIn()/fadeOut();fadeToggle()/fadeTo</p><pre><code>这组动画相当于调整元素的透明度, 0~1之间</code></pre></li><li><p>自定义动画animate</p><pre><code>$(selector).animate({params},[speed],[easing],[callback]);// {params}：要执行动画的CSS属性，带数字（必选）, 属性书写为驼峰// speed：执行动画时长（可选）// easing:执行效果，默认为swing（缓动）  可以是linear（匀速）// callback：动画执行完后立即执行的回调函数（可选）$(&quot;#go&quot;).click(function(){    $(&quot;#block&quot;).animate({         width: &quot;90%&quot;,        height: &quot;100%&quot;,         fontSize: &quot;10em&quot;,         borderWidth: 10    }, 1000 );});</code></pre></li><li><p>动画队列,停止stop,延迟delay</p><pre><code>当给一个元素加动画时,我们多次触发动画效果,它会执行完所有的动画才会停止,而我们有时候需要停止动画stop([clearQueue],[jumpToEnd])方法clearQueue:如果设置成true，则清空队列。可以立即结束动画。jumpToEnd:如果设置成true，则完成队列。可以立即完成动画,跳转到最终值常用stop(true, false)来实现一些之前结束之前的动画,进行下一个动画的场景delay(时间)设置一个延时来推迟执行队列中之后的项目。$(&apos;#foo&apos;).slideUp(300).delay(800).fadeIn(400); // 在.slideUp() 和 .fadeIn()之间延时800毫秒</code></pre></li></ul><h2 id="jQuery事件操作"><a href="#jQuery事件操作" class="headerlink" title="jQuery事件操作"></a>jQuery事件操作</h2><p>这里主要讲一下事件注册,触发,解绑以及事件对象…</p><ul><li><p>on注册事件</p><pre><code>1. on注册简单事件// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on(&apos;click&apos;, function() {    alert(&apos;hello world);}); 2. on注册事件委托// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on(&apos;click&apos;,&apos;span&apos;, function() {    alert(&apos;span的父元素下的后来创建的span元素都有可以触发这个函数&apos;);})</code></pre></li><li><p>解绑事件 off(事件名)</p><pre><code>$(&apos;#btn2&apos;).on(&apos;click&apos;, function () {//给div解绑事件//$(&apos;div&apos;).off();//解绑所有的事件.     $(&apos;div&apos;).off(&apos;click&apos;);//解绑指定的事件.});</code></pre></li><li><p>触发事件trigger</p><pre><code>当事件满足某一条件或者有时候需要去出发定义自定义事件,可以使用.trigger(事件名)//2.点击按钮,满足条件触发div的单击事件.var i = 0;$(&apos;#btn1&apos;).on(&apos;click&apos;, function () {i++;//当i等于3的时候,要调用一下div的单击事件.if(i == 3){    //a.调用div的click事件.    //$(&apos;#one&apos;).click();    //b.使用触发器.    $(&apos;#one&apos;).trigger(&apos;click&apos;); //条件触发}});</code></pre></li><li><p>jQuery事件对象</p><pre><code>jQuery 事件对象是对原生js事件对象的一个封装，并做了兼容性的处理$(&apos;#one&apos;).on(&apos;click&apos;, function (e) {    console.log(e); // e就是事件对象    //三个常用的坐标. 和原生js中的一样.    console.log(e.screenX + &quot;-&quot; + e.screenY); //屏幕左上角 距离触发事件的那一点的距离    console.log(e.clientX + &quot;-&quot; + e.clientY); //页面可视区左上角距离触发事件的那一点之间的距离.    console.log(e.pageX + &quot;-&quot; + e.pageY);//页面左上角 距离触发事件那一点之间的距离.}还有几个常用的属性    event.keyCode    按下的键盘代码    event.data    存储绑定事件时传递的附加数      event.stopPropagation()    阻止事件冒泡行为    event.preventDefault()    阻止浏览器默认行为, 如跳转    return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</code></pre></li></ul><h2 id="jQuery注意事项"><a href="#jQuery注意事项" class="headerlink" title="jQuery注意事项"></a>jQuery注意事项</h2><ul><li><p>链式编程中end()方法的使用</p><pre><code>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</code></pre></li><li><p>显示迭代方法,如each,reduce,filter等等,</p><pre><code>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。举个例子:    $(function () {        //找到所有的li标签,分别设置透明度,透明度是递增到1.        var $lis = $(&apos;#ulList&gt;li&apos;);        //jQuery中的each()方法        $lis.each(function (index,ele) {            //console.log(index);//索引,下标            //console.log(ele);//遍历出来的对象,是dom对象.            //ele.style.opacity = (index+1)/10; //dom对象调用dom属性或者方法        $(ele).css(&apos;opacity&apos;,(index+1)/10); //jQuery对象调用jQuery属性或者方法        });    });</code></pre></li><li><p>多库共存</p><pre><code>jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权.当我需要引入多个jQuery文件时, 就需要规避变量名$冲突的影响1. 比如:如果要做浏览器兼容处理就要引入1.x版本, 那如果要使用最近更新的新方法,就要使用3.x版本的.现在引入2个jQuery文件, 那如何调用者两个文件中的方法呢?var _$ = $.noConflict(); //把$的控制权给释放了. 这个方法有返回值,返回值可以看成是释放$的替代.console.log($.fn.jquery); //1.12.4  // 可以使用3.0.0上面的1.12.4版,不会被覆盖console.log(jQuery.fn.jquery); //3.0.0console.log(_$.fn.jquery);//3.0.0(function ($) {//我们可以把代码放入一个自调用函数中,这里就可以继续使用$代替_$来工作了!!!    console.log($.fn.jquery);//3.0.0}(_$));2. 如果引入了3个包含$的文件, 依次释放即可    var _$30 = $.noConflict();    var _$10 = $.noConflict    console.log(_$30.fn.jquery);    console.log(_$10.fn.jquery);    console.log($);</code></pre></li><li><p>jQuery插件添加</p><pre><code>1. 静态方法,直接在jQuery($)对象身上加    直接给$添加方法. 静态方法    (function ($) {             $.add = function (a, b) {            return a + b;        }    }(jQuery));    console.log($.add(10, 20)); // 302. 实例方法, 则是给jQuery的原型添加方法    (function($) {        $.fn.method = function(参数1,参数2...){            函数体: 要实现的功能;        }      }(window.jQuery))调用的话, 直接调用并传入对应的参数就可以了.....</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇内容是对jQuery和原生JS进行了对比和归纳,主要是总结一些jQuery的常用知识点…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>css中一些常用技巧的总结</title>
    <link href="http://yoursite.com/2018/12/02/css%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/02/css技巧总结/</id>
    <published>2018-12-02T02:53:33.000Z</published>
    <updated>2019-01-18T00:59:00.061Z</updated>
    
    <content type="html"><![CDATA[<p>关于平时个人用到的一些css常用技巧的记录,持续更新ing….<br><a id="more"></a></p><h1 id="css常用技巧总结"><a href="#css常用技巧总结" class="headerlink" title="css常用技巧总结"></a>css常用技巧总结</h1><h2 id="伪类元素实现标题两侧中间加横线"><a href="#伪类元素实现标题两侧中间加横线" class="headerlink" title="伪类元素实现标题两侧中间加横线"></a>伪类元素实现标题两侧中间加横线</h2><pre><code>h3 {    /* margin: 0 auto; */    font-size: 40px;    position: relative;}.line::before,.line::after {    position: absolute;    content: &quot;&quot;;    top: 50%;    background-color: red;    width: 10%; // 父盒子的宽度    /* width: 10px; */    height: 10px;}.line::before {    left: 40%;}.line::after {    right: 40%;}&lt;!-- 百分比的数值都是基于父盒子的基础上变化的 --&gt;</code></pre><h2 id="CSS实现单行、多行文本溢出显示省略号…"><a href="#CSS实现单行、多行文本溢出显示省略号…" class="headerlink" title="CSS实现单行、多行文本溢出显示省略号…"></a>CSS实现单行、多行文本溢出显示省略号…</h2><pre><code>单行:    overflow: hidden;    text-overflow:ellipsis;    white-space: nowrap;多行:    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 3;  // 行数</code></pre><h2 id="无依赖定位"><a href="#无依赖定位" class="headerlink" title="无依赖定位"></a>无依赖定位</h2><pre><code>给一个元素设置绝对定位时，定位的元素仍会保持在html结构位置，不占据空间;其实就是脱离了标准流,层级变高了;然后可以使用margin相对于自身原始位置定位该元素以实现各种功能.还可以使用relative相对于自己原始位置进行定位.logo {        position: absolute;         width: 20px;        height: 20px;        background: url(../image/.png);        margin: 10px 0 0 10px; // 两个方向来调控位置    }</code></pre><h2 id="伪元素实现在元素内设置部分样式"><a href="#伪元素实现在元素内设置部分样式" class="headerlink" title="伪元素实现在元素内设置部分样式"></a>伪元素实现在元素内设置部分样式</h2><pre><code>.logo::after {  content: &apos;&apos;;  &lt;!-- 居中 --&gt;  position: absolute;  left: 50%;  top: 50%;  transform: translate3d(-50%, -50%, 0);  width: 10px;  height: 10px;  border-radius: 50%;  box-shadow: 0 0 0 3px rgba(255, 0, 0, .5);  background-color: #f00;}</code></pre><h2 id="not-选择器使用"><a href="#not-选择器使用" class="headerlink" title=":not()选择器使用"></a>:not()选择器使用</h2><pre><code>nav li:not(:last-child) {    /* 更语义化一点, 最后一个li标签没有右边框作为分隔符 */    border-right: 1px solid #666;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于平时个人用到的一些css常用技巧的记录,持续更新ing….&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css常用技巧" scheme="http://yoursite.com/tags/css%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>js中对this的使用和理解</title>
    <link href="http://yoursite.com/2018/11/29/js%E4%B8%ADthis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/29/js中this的使用/</id>
    <published>2018-11-29T02:53:33.000Z</published>
    <updated>2018-11-29T13:00:23.827Z</updated>
    
    <content type="html"><![CDATA[<p>之前虽然知道this的指向是指向调用它的对象,要找this的指向,就看它所在的活动环境在哪里;但是在实际的应用中还是有i点模糊,这里做一个集中总结…<br><a id="more"></a></p><h1 id="探究this的本质"><a href="#探究this的本质" class="headerlink" title="探究this的本质"></a>探究this的本质</h1><p><strong>js中this的设计,跟内存中数据的存储有很大关系</strong></p><p>下面举两个例子:</p><pre><code>var obj = { foo:  5 };上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存堆里，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。{    foo: {        [[value]]: 5        [[writable]]: true        [[enumerable]]: true        [[configurable]]: true    }}此时，foo属性的值保存在属性描述对象的value属性里面。那么当foo的属性对应的值是一个函数时呢?var obj = { foo: function () {} };这时，引擎会开辟一块内存空间,将函数单独保存在里面，然后再将函数的地址赋值给foo属性的value属性。{    foo: {        [[value]]: 函数的地址        ...    }}由于此时函数是一个单独的值，所以它可以在不同的环境（上下文）执行。如下面的这个例子:var f = function () {};var obj = { f: f };f(); // 全局环境下执行, 相当于window.f()obj.f(); // obj 环境执行由于JavaScript允许在函数体内部，引用当前环境的其他变量。var f = function () {    console.log(x);  // 函数体里面使用了变量x。该变量由运行环境提供.};现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境....var f = function () {    console.log(this.x); // 函数体里面的this.x就是指当前运行环境的x}**看下面的示例会加深一下理解:**var f = function () {    console.log(this.x);}var x = 1;var obj = {    f: f,    x: 2,};// 全局下执行, window环境f() // 1// obj 环境执行obj.f() // 2</code></pre><h1 id="常见的使用场景"><a href="#常见的使用场景" class="headerlink" title="常见的使用场景"></a>常见的使用场景</h1><ul><li><p>全局环境</p><pre><code>全局环境使用this，它指的就是顶层对象windowfunction f() {    console.log(this === window);}f() // true; 此处其实相当于window.f(),只是省略了window</code></pre></li><li><p>构造函数</p><pre><code>构造函数中的this，指的是实例对象function Person(name) {    this.name = name;}var p = new Person(&apos;huhua&apos;); 每一个实例化出来的对象都会有一个name属性    console.log(p.name) // huhua</code></pre></li><li><p>对象的方法</p><pre><code>1.如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。// 不过这里有些地方理解起来会有点难,主要是搞清楚调用的方法是通过什么方式获取的下面举个例子:    var obj ={        foo: function () {        console.log(this);        }    };    obj.foo() // 我们都知道此时this指向的是obj 但是,我这里再做一下变化,this的指向也会发生变化    (obj.foo = obj.foo)() // this指向的是window    上面的代码相当于: (function () {                console.log(this);            })() // 相当于匿名函数的调用上面的代码可以这样理解: 在JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二;obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是上面这种情况是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境window。2.如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。举个栗子:    var a = {        p: &apos;Hello&apos;,        b: {            m: function() {                console.log(this.p);            }        }    };    a.b.m(); // undefined, 此时this指向的是a.b,不是a,所以不能调用对象a中的属性    // 所以只能把属性p放在b属性中    var a = {        b: {            m: function() {                console.log(this.p);            },            p: &apos;Hello&apos;,        }    };    var hello = a.b;    hello.m() // Hello</code></pre></li></ul><h1 id="this在使用时注意点"><a href="#this在使用时注意点" class="headerlink" title="this在使用时注意点"></a>this在使用时注意点</h1><ul><li><p>避免this的多层使用</p><pre><code>由于this的指向时动态变化的,所以在函数中要避免多层使用this指向,很容易搞混淆var obj = {    f1: function () {        console.log(this); // obj环境        var f2 = function () {            console.log(this); // 全局环境下执行, 匿名函数,指向window        }();    }}obj.f1(); // obj // window为了解决上面的问题,我们可以在外层声明一个变量来存储this的指向...var obj = {    f1: function () {        console.log(this); // obj环境        var that = this;   // 在外层声明一个变量指向this        var f2 = function () {            console.log(that);  // 内层引用外层变量that,也可以保存this的指向        }();    }}obj.f1();</code></pre></li><li><p>避免回调函数中使用this</p><pre><code>回调函数中的this往往会改变指向，最好避免使用。</code></pre></li></ul><h1 id="this的绑定方法"><a href="#this的绑定方法" class="headerlink" title="this的绑定方法"></a>this的绑定方法</h1><p>JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</p><ul><li><p>call()</p><pre><code>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 func.call(对象, 参数1, 参数2...) // 适用于传入一个参数或者没有参数var n = 100;var obj = { n: 1 };function func() {    console.log(this.n);}func.call() // 100func.call(null) // 100func.call(undefined) // 100func.call(window) // 100func.call(obj) // 1func函数中的this关键字，如果指向全局对象，返回结果为100。如果使用call方法将this关键字指向obj对象，返回结果为1。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象还比如调用对象原型中的方法:    // 1.伪数组的排序(元素,下标, 长度),    var fake = {        // 指定如下属性,从0开始,长度length属性        0: 100,        1: 10,        2: 1,        3: 102,        4: 12,        5: 1220,        length: 6    }    Array.prototype.sort.call(fake, function(a, b){return a-b;}); // 直接在原数据上修改    console.log(fake); // [1,10,12,100,102,1220]</code></pre></li><li><p>apply()</p><pre><code>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。func.apply(thisValue, [arg1, arg2, ...]) // 可以接受一个参数集合应用:找出数组最大值:    var a = [10, 2, 4, 15, 9];    var res = Math.max.apply(null, a);     console.log(res); // 15转化伪数组:    var fake = {        0: &apos;java&apos;,        1: &apos;javascript&apos;,        2: &apos;css&apos;,        3: &apos;html&apos;,        length: 4,    }        // 1.通过apply的传参特点    var arr = [];    arr.push.apply(arr,fake); // 直接在原数组上修改    console.log(arr); // [&apos;java&apos;,&apos;javascript&apos;,&apos;css&apos;,&apos;html&apos;]    var arr1 = [];    arr1 = arr1.concat.apply(arr1, fake); // 返回一个新数组,需要用变量接受    console.log(arr1);  // [&apos;java&apos;,&apos;javascript&apos;,&apos;css&apos;,&apos;html&apos;]还可以用来绑定回调函数...</code></pre></li><li><p>bind()</p><pre><code>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。举个栗子: 注释的请忽略    var counter = {    count: 0,    inc: function () {            // var count = 100;            this.count++;            // console.log(this.count);  // 这里打印undefined; 因为函数是在全局中调用,无法访问函数内的count        }    };    // var func = counter.inc;    var func = counter.inc.bind(counter);    func();    console.log(counter.count);  // 这里打印1,因为修改了this指向对象counter,可以访问内部属性</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前虽然知道this的指向是指向调用它的对象,要找this的指向,就看它所在的活动环境在哪里;但是在实际的应用中还是有i点模糊,这里做一个集中总结…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>js中闭包的理解</title>
    <link href="http://yoursite.com/2018/11/28/js%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/11/28/js中闭包的理解/</id>
    <published>2018-11-28T02:53:33.000Z</published>
    <updated>2018-11-27T11:45:29.484Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要深入去理解JS中的闭包…<br><a id="more"></a>  </p><h1 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么?"></a>闭包是什么?</h1><p>闭包的定义很简单：就是函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，此时函数 B 就被称为闭包。</p><pre><code>function A() {    var a = 1    function B() {        console.log(a)    }    return B;}var b = A();b()  // 此时函数外部可以访问函数内部的变量</code></pre><blockquote><p>闭包的本质就是一个函数,可以沟通函数内部和函数外部…</p></blockquote><h1 id="闭包示例"><a href="#闭包示例" class="headerlink" title="闭包示例"></a>闭包示例</h1><pre><code>示例1: function outer() {        var a = 1;        function inner() {            a++;            return a;        };        return inner;    };var res = outer()(); var res1 = outer()();var res2 = outer()();console.log(res,res1,res2); // 2, 2, 2; 三次调用都是不同的函数,每一次访问的都是内部重新声明的变量console.log(outer()); // 函数innervar func = outer();console.log(func(), func(), func()); // 2, 3, 4; 同一个函数访问了三次这个变量示例2:for (var i = 1;i&lt;=5;i++){    function outer () {        var num = i;        function closure () {            return num;        }        return closure;    }    console.log ( &apos;循环内&apos; + outer()());// 1,2,3,4,5}console.log (&apos;循环外&apos; +  outer()());// 6,</code></pre><h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><pre><code>// 1.延长变量的生命周期// 局部变量的生命周期：从执行函数开始，到函数执行完毕被回收    function outer() {        var a = 1;        function inner() {            console.log(a);        };        return inner;    };    var func = outer();    func(); // 1//闭包唯一弊端：会消耗内存资源//如何手动回收闭包内存：  变量名 = null;// 2. 设置权限// 定义一个匿名函数用person接受var person = function () {    //声明局部变量    var age = 38;    //使用闭包访问局部变量    function getAge () {        return age;    };    function setAge (value) {        if (value &gt; 0 &amp;&amp; value &lt;= 100){            age = value;        }    };    //返回一个对象，对象中存储2个闭包函数用于操作局部变量    return {        getAge:getAge,        setAge:setAge    }};var p1 = person();//得到闭包函数对象p1.setAge(-1);//修改无效p1.setAge(33);//修改有效console.log (p1.getAge());  // 33</code></pre><h1 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h1><pre><code>当我们需要创建独立的内存空间时，隔绝外部的环境,可以用到闭包(匿名函数自调用)    a.提供不同的作用域----可以避免全局变量污染    b.模块化的开发----不同的功能对应不同的作用域// 闭包实现斐波那契数列// 从定义出发, 一个函数嵌套另一个函数,内层函数访问外层函数的变量并返回自己    function outer() {        // 在外面定义一个数组用来存储        var arr = [1,1,0];        // 创建闭包函数        function inner(num) {            // num 表示斐波那契数列第几位数            if (num == 1 || num == 2){                return 1;            }            else {                for(var i = 2; i &lt; num; i++) {                    // 让数组第三位来存储斐波那契的计算位                    arr[2] = arr[1] + arr[0];                    // 将数组数据前推一位,让第三位来存储下一个计算位                    arr[0] = arr[1];                    arr[1] = arr[2];                };                return arr[2];            }        };         return inner;    };    console.log(outer()(10));  // 55    // 等价于上面    var func = outer();    console.log(func(10)); // 55</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要深入去理解JS中的闭包…&lt;br&gt;
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
